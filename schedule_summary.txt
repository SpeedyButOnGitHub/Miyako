# Schedule System Summary (Miyako)

This document summarizes the .schedule tab: embeds/templates, functionality, auto-messages, interactions/UI, and relevant configs.

---

### Embeds

1) Staff Clock-In (template-driven)
- Source: config/clockInEmbedTemplate.json
- Shape (condensed):
  {
    "content": "",
    "embeds": [
      {
        "title": "üïí Staff Clock-In ‚Äî {{EVENT_NAME}}",
        "description": "üïí Staff Clock-In ‚Äî {{EVENT_NAME}}\n\nSelect a position from the menu below. One slot per staff (auto-updates).",
        "color": 5793266,
        "fields": [
          { "name": "üìù Instance Manager (0/1)", "value": "‚Äî", "inline": true },
          { "name": "üõ†Ô∏è Manager (0/5)", "value": "‚Äî", "inline": true },
          { "name": "üõ°Ô∏è Bouncer (0/10)", "value": "‚Äî", "inline": true },
          { "name": "üç∏ Bartender (0/15)", "value": "‚Äî", "inline": true },
          { "name": "üéØ Backup (0/20)", "value": "‚Äî", "inline": true },
          { "name": "‚è≥ Maybe/Late (0/50)", "value": "‚Äî", "inline": true }
        ],
        "footer": { "text": "" }
      }
    ],
    "components": [
      {
        "type": 1,
        "components": [
          {
            "type": 3,
            "custom_id": "clockin:{{EVENT_ID}}:{{AUTO_MESSAGE_ID}}",
            "placeholder": "üìã Select a position",
            "options": [
              { "label":"Instance Manager", "value":"instance_manager", "description":"IM slots 1" },
              { "label":"Manager",           "value":"manager",          "description":"M slots 5" },
              { "label":"Bouncer",           "value":"bouncer",          "description":"B slots 10" },
              { "label":"Bartender",         "value":"bartender",        "description":"BT slots 15" },
              { "label":"Backup",            "value":"backup",           "description":"BK slots 20" },
              { "label":"Maybe/Late",        "value":"maybe",            "description":"? slots 50" }
            ]
          }
        ]
      }
    ]
  }

2) "Midnight Bar is open!" (auto message)
- Example (condensed):
  {
    "content": "<@&1380303846877696153>",
    "embeds": [{
      "title": "Midnight Bar is open!",
      "description": "**The Midnight Bar** is now open, [come join us!](...)\n\nWe will be open until: <timestamp_close:t>",
      "fields": []
    }]
  }

3) Anchor content (dynamic, per-event)
- Built via ensureAnchor(); content starts from event.message / messageJSON.content or a standard template.
- For Midnight Bar, a "Notify Me" button is injected and an image embed may be attached.
- Timestamp placeholders (e.g., timestamp_opening1) are replaced at send/edit time.

4) Embed helpers
- utils/embeds.js:
  - createEmbed({ title, description, color, fields, footer, timestamp = true })
  - safeAddField(embed, name, value, inline)
  - addChunkedField(embed, baseName, text, chunkSize)

---

### Functionality (where things live and what they do)

A) commands/schedule.js (UI + authoring + manual send)
- handleScheduleCommand(client, message): owner-only entry. Renders the main Events Manager embed and registers an ActiveMenus session.
- UI builders (representative):
  - buildMainEmbed(guild): list events with status/summary.
  - buildDetailEmbed(guild, ev): show event details (times, days, message preview).
  - buildNotifsEmbed(guild, ev): list per-event auto messages.
  - mainRows(), buildSelectRows(kind), detailRows(ev), notifManagerRows(ev), notifSelectRows(ev), notifDetailRows(ev, notif): compose buttons/selects.
- ensureAnchor(clientOrInteraction, ev, override?):
  - Determines base content (ev.dynamicBaseContent || ev.messageJSON?.content || ev.message).
  - Applies timestamp placeholders + {{EVENT_NAME}}.
  - For Midnight Bar, injects a "Notify Me" button (custom_id: event_notify_${ev.id}) and an image embed.
  - Creates the anchor if missing, else edits when content/requirements change.
- manualTriggerAutoMessage(interaction, ev, notif):
  - TTL dedup via utils/sendOnce.seenRecently("manual:${ev.id}:${notif.id}:${channelId}", 7s).
  - Sends to CONFIG_LOG_CHANNEL in testing mode; else to notif.channelId || ev.channelId.
  - If notif.isClockIn: constructs the "Staff Clock-In" embed + select menu; dedups if a recent clock-in message exists (ev.__clockIn.lastSentTs within 5m).
  - Otherwise: if notif.messageJSON exists, prefer it; else use notif.message; applies timestamp placeholders; sanitizes mentions in testing.
  - On success (non-testing), sets notif.__skipUntil (1h) and updates lastManualTrigger.
- Modals (authoring): handleEventCreateModal, handleEventEditModal, handleEventNotificationModal
  - Parse & heal optional JSON bodies (fenced JSON -> object).
  - Update event model; refresh UI message accordingly.

B) utils/scheduler.js (engine + dispatch)
- Schedule object (schedules.json):
  - { id, name, channelId, message, messageJSON?, type: once|daily|weekly|monthly|interval, time, date, days[], intervalDays, repeats, enabled, nextRun }
- computeNextRun(schedule):
  - once: returns future ts else null; daily/weekly/monthly: next occurrence; interval: nextRun + days.
- runScheduleOnce(client, schedule):
  - Routes to testing log channel when testingMode is on.
  - TTL dedup: seenRecently(`sched:${schedule.id}:${chId}`, 8s).
  - JSON-preferred send with timestamp placeholder application.
- computeAfterRun(schedule):
  - Decrements repeats; disables "once" schedules; computes nextRun for repeating types.
- startScheduler(client, { intervalMs=15s, clockInDedupMs=5m, ... }):
  - Hydrates nextRun for schedules.
  - Every tick:
    - For each schedule: if nextRun <= now+5s -> runScheduleOnce() then update schedule via computeAfterRun().
    - For events (config/events.json, type === "multi-daily"):
      - Determine status (upcoming/open/closed) using ranges or times.
      - Auto messages:
        - For each ev.autoMessages and each event time t:
          - When curMinutes === (time - offset):
            - Minute guard: ev["__auto_${m.id}_${t}"] within 60s.
            - TTL guard: seenRecently(`auto:${ev.id}:${m.id}:${t}:${channelId}`, 8s).
            - If m.isClockIn: build the Staff Clock-In embed, dedup via ev.__clockIn.lastSentTs (configurable), send + track messageIds; prune orphans.
            - Else: send JSON payload or content with placeholders.
      - Dynamic anchor updates:
        - Recompute and minimally edit the anchor message content (e.g., "Midnight Bar is open!" vs upcoming countdown).
  - Periodically prunes ev.__clockIn.messageIds for deleted messages.

C) services/scheduleService.js (facade)
- Thin wrappers exposing start/computeNextRun/computeAfterRun and storage helpers for schedules & events.

D) Helper modules
- utils/timestampPlaceholders.js:
  - computeNextRange(ev) -> { startSec, endSec } using ev.ranges or ev.times.
  - applyTimestampPlaceholders(text, ev): replaces tokens like timestamp_opening1/opening1/closing1 (+ legacy aliases) and static opening2/closing2.
- utils/embeds.js: see Embeds section.
- utils/sendOnce.js:
  - seenRecently(key, ttlMs=30000): in-memory TTL guard used by scheduler and manual triggers.
- utils/logChannels.js:
  - CONFIG_LOG_CHANNEL, etc. Used when testingMode routes output to a log channel.
- utils/activeMenus.js:
  - Session registry for UI interactions; handles timeouts and routes presses to registered handlers.
- utils/scheduleStorage.js:
  - File-backed store for config/schedules.json (get/add/update/remove).
- utils/eventsStorage.js (not shown here):
  - Similar file-backed store for config/events.json with getEvent/getEvents/add/update/remove.

---

### Auto Messages

Data model (per event):
- ev.autoMessages: Array<AutoMessage>
- AutoMessage (fields observed):
  {
    id: string,
    offsetMinutes: number,     // minutes before the event time (0 = at start)
    enabled: boolean,
    message?: string,          // may hold JSON-as-text
    messageJSON?: object,      // parsed JSON payload (preferred when present)
    channelId?: string,        // optional override; else ev.channelId
    isClockIn?: boolean,       // when true, send Staff Clock-In embed instead
    __skipUntil?: number,      // used to delay repeat sends after manual trigger
    lastManualTrigger?: number // bookkeeping
  }

Storage & authoring:
- Stored in config/events.json under each event (via utils/eventsStorage through services/scheduleService).
- Created/edited via Events Manager UI (buttons + modals in commands/schedule.js):
  - Add/Edit Channel; Offset; Message (JSON or text); Toggle enabled; Delete; Trigger.

Dispatch:
- When scheduler tick matches (per minute) targetMin = eventStartMin - offset:
  - Per-minute guard ev["__auto_${m.id}_${t}"] ensures we don‚Äôt send twice in a minute.
  - TTL guard (utils/sendOnce) prevents race-condition duplicates.
  - Testing mode routes to CONFIG_LOG_CHANNEL and sanitizes mentions.
  - Clock-in sends embed+menu and records message id + lastSentTs for dedup; non clock-in sends JSON/content.

Manual trigger:
- ActiveMenus button "Trigger" ‚Üí manualTriggerAutoMessage():
  - TTL guard (~7s) on the (event, notif, channel) key.
  - Updates skip window (__skipUntil) and lastManualTrigger.

---

### Interactions & UI

Events Manager (ActiveMenus session: type="events"):
- Main view (mainRows): [Create] [Delete] [Select]
- Select mode (buildSelectRows): choose event to view or delete.
- Detail view (detailRows): [Enable/Disable] [Edit] [Auto Msgs] [Delete]
- Auto Msg Manager (notifManagerRows): [Add] [Select]
- Auto Msg Detail (notifDetailRows): [Enable/Disable] [Edit] [Channel] [Offset] [Msg] | [Trigger] [Delete]
- Message updates typically use interaction.update(...) to edit the same manager message; new messages are created only for anchor or actual dispatched content.

Clock-In select interaction:
- Custom ID: clockin:${EVENT_ID}:${AUTO_MESSAGE_ID}
- On selection, the interaction handler updates ev.__clockIn.positions so each user occupies exactly one position; then re-renders all clock-in embeds for that event. Capacity rules: Instance Manager capped to 1; others effectively unlimited or per template.

Notify Me button (Midnight Bar anchor):
- ensureAnchor() injects a button with custom_id event_notify_${ev.id}.
- A dedicated interaction handler toggles a NOTIFY_ROLE_ID for the user and replies ephemerally with the result. The button label is not per-user toggled (intentional).

---

### Configs

- config/botConfig.json ‚Üí loaded via utils/storage.js as `config`
  - testingMode: boolean
    - When true: scheduled and auto messages route to CONFIG_LOG_CHANNEL and mentions are sanitized.
  - commandLogging, economy, leveling, etc. (not used by schedule directly)

- utils/logChannels.js
  - CONFIG_LOG_CHANNEL: used for testing-mode routing of schedule/auto-messages.

- config/schedules.json (managed by utils/scheduleStorage.js)
  - Shape: { nextId: number, schedules: Schedule[] }
  - Schedule explained in Functionality(B).

- config/events.json (managed by utils/eventsStorage.js)
  - Each event: { id, name, description, channelId, message, messageJSON?, ranges?, enabled, times[], days[], type, dynamicBaseContent?, anchorChannelId?, anchorMessageId?, autoMessages[], nextAutoId? }
  - Clock-in runtime: __clockIn: { positions: {key: string[]}, messageIds: string[], lastSentTs: number, channelId? }
  - Per-minute guards: __auto_${notifId}_${timeHM}: number

- Environment variables
  - CLOCKIN_DEDUP_MS: ms window to dedup clock-in sends (default 5m)
  - CLOCKIN_ORPHAN_MAX: limit of tracked clock-in message IDs (default 10)

- Dedup guards
  - utils/sendOnce.seenRecently(key, ttlMs): in-memory TTL guard for race conditions (scheduler + manual triggers).
  - Per-minute ev["__auto_${id}_${time}"] and schedule.nextRun logic.
  - ev.__clockIn.lastSentTs window and orphan pruning.

---

### Call Graph (condensed)

User (.schedule) ‚Üí commands/schedule.handleScheduleCommand ‚Üí ActiveMenus session "events"
- Button/Select ‚Üí commands/schedule (handlers) ‚Üí services/scheduleService (eventsStorage)
- "Trigger" ‚Üí manualTriggerAutoMessage ‚Üí channel.send(...)

Bot runtime ‚Üí services/scheduleService.start ‚Üí utils/scheduler.startScheduler
- schedules.json loop ‚Üí runScheduleOnce ‚Üí channel.send
- events.json loop (multi-daily) ‚Üí autoMessages dispatch ‚Üí { TTL guard, minute guard, clock-in path or JSON/content send }
- anchor updates ‚Üí minimal edit of content

---

### Notes
- JSON-preferred sending: when messageJSON exists, its content/embeds/components are used; the raw JSON string in message is not echoed to avoid duplicate textual JSON.
- Testing mode guarantees: output goes to a log channel and mention strings are sanitized with backticks.
- Anchor content for Midnight Bar includes a persistent button; the anchor is updated rather than replaced when possible.
