===== BEGIN REPO CONTEXT =====
Repo: Miyako  (generated: 2025-09-10T13:06:49.904Z)
Notes:
- Sensitive runtime files are excluded (e.g., .env, pid/lock).
- Sections are delimited by FILE markers and fenced code blocks.


===== FILE: ARCHITECTURE.md =====
```markdown
# Miyako Architecture

This document summarizes the refactored structure and design conventions.

## Goals
- Uniform UI styling (centralized embed helpers)
- Clear layering: commands -> services -> utils -> storage (JSON files)
- Easier future migration to database or caching layer
- Maintain CommonJS for compatibility

## Layers
1. Commands (`commands/`): Parse user input, orchestrate services, assemble responses.
2. Services (`services/`): High-level domain operations (status, economy, leveling). Thin wrappers now; can add caching, batching, analytics later.
3. Utils (`utils/`): Low-level modules (file-backed persistence, embed helpers, logging, scheduling, events).
4. Config (`config/`): JSON state and configuration snapshots.

## Key Services
- `statusService`: Startup/shutdown announcements and channel name updates.

## UI Conventions (Semantic Layer)
All interactive UIs use `utils/ui.js` helpers:
* `semanticButton(kind, opts)` enforces styling (nav, primary, success, danger, toggle) and auto Title-Case labels.
* Back buttons are suppressed globally (inline expansion pattern replaces hierarchical back navigation).
* `applyToggleVisual(embed,{on})` standardizes success/neutral coloring + ✅/❌ prefix.
* `getToggleVisual(on)` central mapping for emoji/color/prefix.
* `buildSettingEmbedUnified` builds per-setting embeds with optional toggle state and last-updated metadata.

### Inline Expansion Pattern
Menus (config, schedule; others in progress) render all navigation context inline:
1. Category rows always visible (no hidden stack).
2. Selecting a category adds setting rows beneath without destroying category context.
3. Selecting a setting adds its action rows while preserving above rows.
4. No empty component rows permitted (health check enforces).

### Toggle Registry
`registerToggle({ key, getter, kind, on })` records boolean or mode states for uniform UI updates and future automation (bulk refresh, analytics, tests).

## Error & Crash Pipeline
* Early `crashReporter.initEarly()` attaches uncaught/unhandled/signal handlers before other imports.
* `errorUtil` wraps and persists errors (bounded retention) and supports live listener embeds.
* Instrumentation layer in `interactionEvents` logs deprecated `ephemeral` usage to trace regressions.

## Health Checks
`utils/health.runHealthChecks()` validates:
* Event anchor messages (existence & Midnight Bar button repair, timestamp auto-fix).
* Staff team message regeneration.
* ActiveMenus snapshot: no stale expired sessions and no rows with zero components.

## Performance Notes
* Write queue batches JSON persistence.
* Leaderboard service caches sorted data for short TTL.
* Planned: diff-aware component update helper to reduce interaction edit churn (placeholder; not yet implemented).

## Testing Aids
Minimal Jest tests cover leveling progression, tax calculation, leaderboard caching, VC leveling, XP modifier streak. Future: embed/toggle diagnostics command verifying capitalization & indicator compliance.
- `economyService`: Deposit / withdraw orchestration and aggregate balances.
- `levelingService`: XP & levels access (text + VC) + message handling entry point.
- `scheduleService`: Thin facade over scheduler + schedule/event storage (enables future validations & caching).
- `leaderboardService`: 5s TTL cached leaderboard construction (text + VC) to avoid repeated full sorts.

## Embed Standardization
All embeds originate via `utils/embeds.js` (`createEmbed`, `successEmbed`, etc.). Field additions must use `safeAddField` or `addChunkedField` for safety.

## Active Menus
`utils/activeMenus.js` manages interactive state. Commands register handlers with a session descriptor. Services should remain stateless relative to session objects.

## Scheduling & Events
`utils/scheduler.js` runs periodic dispatch for schedules and multi-daily events. `scheduleService` wraps start + compute helpers and exposes event CRUD used by `schedule` command.

## Economy
- `utils/cash.js`, `utils/bank.js` perform file-backed persistence with debounce writes.
- Progressive tax logic lives in `bank.js`; service exposes simplified operations.

## Leveling
- XP accrual throttled per-user (60s) with streak-based multiplier.
- Level XP curve: `xpForLevel(level) = 150 * level^(1/0.7)`.

## Future Enhancements
- Potential DB migration (introduce adapters under a `data/` layer) if JSON scaling becomes limiting.
- Optional extended metrics collection (message XP distribution, bank tax histograms) feeding analytics service.
- Snapshot diffing for leaderboards if generating large paginated variants for external export.

## Error Handling
- Central utility: `utils/errorUtil.js`.
- Errors (console, uncaughtException, unhandledRejection, explicit logError calls) are captured and appended to `config/errorLog.json` (rotating; max ~500 kept).
- On startup a summary of the latest errors (up to 5) is appended to the status/startup embed; log then cleared (toggle via future retention flag if needed).

## Deployment Notes
- Graceful shutdown flushes pending queued writes (`writeQueue.flushAll`) before exit, then emits shutdown message via status service.
- Level + VC level persistence now batched via writeQueue (250ms coalescing) to reduce sync fs churn.
- Restart logic includes inline changelog summary.

---
This file will evolve as new services or caching layers are added.

```

===== FILE: README.md =====
```markdown
# Miyako

A modular Discord bot for moderation, leveling, and utilities.

## Quick start

1. Install dependencies

```powershell
npm install
```

2. Configure environment

- Copy `.env.example` to `.env` and fill in your values.
- Ensure your log channel IDs in `utils/logChannels.js` match your server.

3. Run a quick smoke test (loads modules only)

```powershell
npm run smoke
```

4. Start the bot

```powershell
npm start
```

## Commands

- `.help` — interactive help menu
- `.config` — owner-only config menu
- `.level`, `.profile`, `.leaderboard` — leveling
- `.mute`, `.unmute`, `.timeout`, `.untimeout`, `.ban`, `.kick`, `.warn`, `.removewarn`, `.warnings` — moderation
- `.snipe`, `.ds` — snipes
- `.schedule` — schedules (owner)
- `.scripts` — JS files leaderboard

## Notes

- Testing Mode banner and config changes are logged to the config log channel.
- Interactive menus time out and are cleaned up on restart.
- Services layer introduced (see ARCHITECTURE.md) for status, economy, and leveling to simplify future caching or DB migration.

## Development

Start the bot:

```powershell
npm start
```

Run module smoke load only:

```powershell
npm run smoke
```

### Pre-commit guard (ephemeral deprecation)

Discord.js v14 deprecates `ephemeral:true` in favor of interaction `flags` (64). A helper shim converts, but new code should use `flags: 1<<6` directly.

Add a local pre-commit hook to block deprecated usage:

```powershell
echo node scripts/check-ephemeral.js > .git/hooks/pre-commit
chmod +x .git/hooks/pre-commit
```

The hook aborts the commit if any `ephemeral:true` remains.

```

===== FILE: REFCHANGE-2025-09-10.md =====
```markdown
# REFCHANGE — 2025-09-10

Scope: idempotent attach, TTL-based send guards, scheduler/manual trigger dedup, small unit test.

Changes
- events/interactionEvents.js
  - Add client.__interactionListenerAttached sentinel to avoid double registration of interactionCreate.
- utils/sendOnce.js (new)
  - Small in-memory TTL guard: seenRecently(key, ttlMs) used to prevent rapid duplicate sends.
- utils/scheduler.js
  - runScheduleOnce(): uses TTL guard keyed by schedule + channel to avoid rare double fires due to drift.
  - autoMessages loop: add TTL guard per (eventId, notifId, time, channel) before sending. Keep existing 60s per-fireKey protection.
  - Preserve existing clock-in dedup (lastSentTs + message age) and pruning.
- commands/schedule.js
  - manualTriggerAutoMessage(): add TTL send guard for rapid double-clicks; no behavior change otherwise.
- __tests__/sendOnce.test.js (new)
  - Unit test validating TTL guard behavior.

Notes
- Guards are in-memory and per-process; if you run multiple instances, consider a shared store (Redis) for cross-process dedup.
- TTLs used: 7–8 seconds for manual/scheduled sends; clock-in keeps 5-minute window via existing state.
- No user-visible changes except fewer accidental duplicates under race conditions.

Quality gates
- Build: N/A (Node runtime)
- Lint/Typecheck: N/A (no TS)
- Tests: jest run expected to pass for new test.


```

===== FILE: __tests__/sendOnce.test.js =====
```javascript
const { seenRecently } = require('../utils/sendOnce');

describe('sendOnce TTL guard', () => {
  test('returns false on first sight, true if seen within TTL, then false after TTL', async () => {
    const key = 'unit:abc';
    const ttl = 100; // 100ms TTL
    const first = seenRecently(key, ttl);
    expect(first).toBe(false);
    const second = seenRecently(key, ttl);
    expect(second).toBe(true);
    // wait past TTL
    await new Promise(r => setTimeout(r, ttl + 30));
    const third = seenRecently(key, ttl);
    expect(third).toBe(false);
  });
});

```

===== FILE: commands/balance.js =====
```javascript
const { EmbedBuilder, ActionRowBuilder, ButtonBuilder, ButtonStyle, ModalBuilder, TextInputBuilder, TextInputStyle } = require("discord.js");
const { createEmbed, safeAddField } = require('../utils/embeds');
const theme = require("../utils/theme");
const { progressBar: sharedProgressBar, applyStandardFooter, semanticButton, buildNavRow } = require("../utils/ui");
const { cash: cashUtils } = require("../services/economyService");
const { bank: bankUtils } = require("../services/economyService");
const { getUserModifier } = require("../services/levelingService");

// Color logic based on bank status
function bankColor(bank, base) {
  if (bank < base) return theme.colors.primary;
  if (bank === base) return theme.colors.warning;
  return theme.colors.danger;
}

function buildStatusLine(bank, base) {
  if (bank < base) return `Below daily limit (${(bank / base * 100).toFixed(1)}%)`;
  if (bank === base) return "At daily limit";
  const ratio = (bank / base).toFixed(2);
  return `Above limit (${ratio}x)`;
}

// Root wallet view (public message)
const progressBar = (current, max, size = 14) => sharedProgressBar(current, max, size, { allowOverflow: true, showNumbers: false });

function buildBalancePayload(userId) {
  const { config } = require("../utils/storage");
  const cash = (config.testingMode ? cashUtils.getTestingCash(userId) : cashUtils.getCash(userId)) || 0;
  const mult = getUserModifier(userId) || 1.0;
  const bank = bankUtils.getBank(userId) || 0;
  const base = bankUtils.getBaseLimit();
  const { getProgress } = require("../utils/depositProgress");
  const prog = getProgress(userId);
  const used = prog.amount;
  const bar = progressBar(used, base);
  const over = used > base;
  const embed = createEmbed({
    title: `${theme.emojis.bank} Wallet & Bank`,
    color: bankColor(bank, base)
  });
  safeAddField(embed, 'Cash', `**$${cash.toLocaleString()}**`, true);
  safeAddField(embed, 'Bank', `**$${bank.toLocaleString()}**`, true);
  safeAddField(embed, 'Multiplier', `${mult.toFixed(2)}x`, true);
  safeAddField(embed, 'Daily Deposit Progress', `${bar}\n$${used.toLocaleString()}/$${base.toLocaleString()}${over ? ' ⚠️' : ''}`);
  applyStandardFooter(embed, null, { testingMode: config.testingMode });
  embed.setFooter({ text: `Deposit to grow your bank${config.testingMode ? ' • Testing Mode' : ''}. Taxes apply above the limit.` });

  const row = buildNavRow([
    semanticButton('nav', { id: 'bank:menu:deposit', label: 'Deposit', emoji: theme.emojis.deposit }),
    semanticButton('primary', { id: 'bank:menu:withdraw', label: 'Withdraw', emoji: theme.emojis.withdraw })
  ]);
  return { embeds: [embed], components: [row] };
}

function buildDepositMenuPayload(userId) {
  const { config } = require("../utils/storage");
  const cash = (config.testingMode ? cashUtils.getTestingCash(userId) : cashUtils.getCash(userId)) || 0;
  const bank = bankUtils.getBank(userId) || 0;
  const base = bankUtils.getBaseLimit();
  // thresholds removed per new spec; allow overfill display only
  const { getProgress } = require("../utils/depositProgress");
  const prog = getProgress(userId);
  const used = prog.amount;
  const resetAt = prog.resetAt;
  const bar = progressBar(used, base);
  const over = used > base;
  const lines = [
    `**Cash:** $${cash.toLocaleString()} • **Bank:** $${bank.toLocaleString()}`,
    `Daily Limit: $${base.toLocaleString()}`,
    `${bar} $${used.toLocaleString()}/$${base.toLocaleString()}${over ? " ⚠️" : ""}`
  ];
  if (resetAt) {
    lines.push(`⏰ Resets: <t:${Math.floor(resetAt/1000)}:R>`);
  }
  if (bank >= base) {
    lines.push(bank === base ? "At limit: further deposits will incur tax." : "Warning: Above limit – deposits incur heavy progressive tax.");
  }
  const embed = createEmbed({
    title: `${theme.emojis.deposit} Deposit Menu`,
    description: lines.join('\n'),
    color: bankColor(bank, base)
  });
  applyStandardFooter(embed, null, { testingMode: config.testingMode });
  embed.setFooter({ text: `Choose Deposit Amount or Deposit Max. Back returns to Wallet.${config.testingMode ? ' • Testing Mode' : ''}` });
  const row = buildNavRow([
    semanticButton('nav', { id: 'bank:deposit:amount', label: 'Deposit', emoji: theme.emojis.deposit }),
    semanticButton('nav', { id: 'bank:deposit:max', label: 'Deposit Max', emoji: theme.emojis.deposit }),
    semanticButton('nav', { id: 'bank:back', label: 'Back', emoji: theme.emojis.back })
  ]);
  return { embeds: [embed], components: [row] };
}

function buildWithdrawMenuPayload(userId) {
  const { config } = require("../utils/storage");
  const cash = (config.testingMode ? cashUtils.getTestingCash(userId) : cashUtils.getCash(userId)) || 0;
  const bank = bankUtils.getBank(userId) || 0;
  const base = bankUtils.getBaseLimit();
  const lines = [
    `**Cash:** $${cash.toLocaleString()} • **Bank:** $${bank.toLocaleString()}`,
    "Withdrawals have no penalties."
  ];
  const embed = createEmbed({
    title: `${theme.emojis.withdraw} Withdraw Menu`,
    description: lines.join('\n'),
    color: bankColor(bank, base)
  });
  applyStandardFooter(embed, null, { testingMode: config.testingMode });
  embed.setFooter({ text: `Choose Withdraw Amount or Withdraw Max. Back returns to Wallet.${config.testingMode ? ' • Testing Mode' : ''}` });
  const row = buildNavRow([
    semanticButton('nav', { id: 'bank:withdraw:amount', label: 'Withdraw Amount', emoji: theme.emojis.withdraw }),
    semanticButton('nav', { id: 'bank:withdraw:max', label: 'Withdraw Max', emoji: theme.emojis.withdraw }),
    semanticButton('nav', { id: 'bank:back', label: 'Back', emoji: theme.emojis.back })
  ]);
  return { embeds: [embed], components: [row] };
}

async function handleBalanceCommand(client, message) {
  const payload = buildBalancePayload(message.author.id);
  try {
    const { activeDrops } = require('../utils/cashDrops');
    const dropActive = activeDrops && Array.from(activeDrops.values()).some(d => d && !d.claimedBy && d.expiresAt > Date.now());
    if (dropActive) {
      const BROADCAST_CHANNEL_ID = '1232701768987578462';
      const channel = await client.channels.fetch(BROADCAST_CHANNEL_ID).catch(()=>null);
      let linkMsg = null;
      if (channel && channel.send) {
        // Public broadcast with ping
        linkMsg = await channel.send({ content: `🔍 Balance Check: <@${message.author.id}>`, ...payload, allowedMentions:{ users:[message.author.id] } }).catch(()=>null);
      }
      // Ephemeral redirect style reply: minimal message linking to broadcast
      const jumpLink = linkMsg ? `https://discord.com/channels/${linkMsg.guildId}/${linkMsg.channelId}/${linkMsg.id}` : null;
      await message.reply({ content: jumpLink ? `Balance posted here → ${jumpLink}` : 'Balance posted.', allowedMentions:{ repliedUser:false } }).catch(()=>{});
      return;
    }
  } catch {}
  await message.reply({ ...payload, allowedMentions: { repliedUser: false } }).catch(() => {});
}

module.exports = { 
  handleBalanceCommand,
  buildBalancePayload,
  buildDepositMenuPayload,
  buildWithdrawMenuPayload,
  bankColor,
  buildStatusLine
};

```

===== FILE: commands/cash.js =====
```javascript
const { formatCash, getCash } = require("../utils/cash");

async function handleCashCommand(client, message) {
  const amount = getCash(message.author.id);
  await message.reply(`💸 You have ${formatCash(amount)}.`).catch(() => {});
}

module.exports = { handleCashCommand };

```

===== FILE: commands/clockin.js =====
```javascript
const { createEmbed, safeAddField } = require('../utils/embeds');
const theme = require('../utils/theme');
const { getEvents } = require('../utils/eventsStorage');
const { OWNER_ID } = require('./moderation/permissions');

function buildClockInStateEmbed() {
  const events = getEvents();
  const clockEvents = events.filter(e => e.__clockIn && e.__clockIn.positions);
  const embed = createEmbed({
    title: '🕒 Clock-In State',
    description: clockEvents.length ? `${clockEvents.length} event(s) with active clock-in state.` : 'No clock-in state found.',
    color: theme.colors.primary
  });
  for (const ev of clockEvents.slice(0, 10)) { // cap to avoid overlong embed
    const pos = ev.__clockIn.positions || {};
    const roles = ['instance_manager','manager','bouncer','bartender','backup','maybe'];
    const lines = [];
    let total = 0;
    for (const r of roles) {
      const arr = Array.isArray(pos[r]) ? pos[r] : [];
      if (!arr.length) continue;
      total += arr.length;
      const label = r.replace('_',' ').replace(/\b\w/g,c=>c.toUpperCase());
      lines.push(`${label}: ${arr.map(id=>`<@${id}>`).join(', ')}`.slice(0, 250));
    }
    if (!lines.length) lines.push('(empty)');
    const lastSent = ev.__clockIn.lastSentTs ? `<t:${Math.floor(ev.__clockIn.lastSentTs/1000)}:R>` : '—';
    lines.push(`Last Msg: ${lastSent}`);
    safeAddField(embed, ev.name || `Event ${ev.id}`, lines.join('\n').slice(0, 1024));
  }
  if (clockEvents.length > 10) {
    safeAddField(embed, 'Note', `+${clockEvents.length - 10} more event(s) truncated.`);
  }
  return embed;
}

async function handleClockInStateCommand(client, message) {
  if (message.author.id !== OWNER_ID) return; // restrict
  try {
    const embed = buildClockInStateEmbed();
    await message.reply({ embeds:[embed], allowedMentions:{ repliedUser:false } });
  } catch (e) {
    await message.reply({ content: 'Failed to build clock-in state: ' + (e.message||e), allowedMentions:{ repliedUser:false } }).catch(()=>{});
  }
}

module.exports = { handleClockInStateCommand };

```

===== FILE: commands/configMenu.js =====
```javascript
// Thin compatibility layer: re-export modular API used elsewhere
const { renderSettingEmbed } = require("./configMenu/render");
const { OWNER_ID } = require("./moderation/permissions");

async function handleMessageCreate(client, message) {
  // Delegate to new modular menu (lazy require to avoid circular warnings)
  if (String(message.author?.id) !== String(OWNER_ID)) {
    try { await message.reply("⚙️ Only the Owner can use the config menu."); } catch {}
    return;
  }
  const { handleConfigMenuCommand } = require("./configMenu/index.js");
  return handleConfigMenuCommand(message);
}

// Legacy CLI handler can be gradually ported later; for now export a stub that shows the menu
async function handleConfigCommand(client, message) {
  if (String(message.author?.id) !== String(OWNER_ID)) {
    try { await message.reply("⚙️ Only the Owner can use the config menu."); } catch {}
    return;
  }
  const { handleConfigMenuCommand } = require("./configMenu/index.js");
  return handleConfigMenuCommand(message);
}

module.exports = { renderSettingEmbed, handleMessageCreate, handleConfigCommand };
```

===== FILE: commands/configMenu/constants.js =====
```javascript
const { ButtonStyle } = require("discord.js");
const { config } = require("../../utils/storage");

// Keep same file path semantics as legacy implementation
const ACTIVE_MENUS_FILE = "./config/activeMenus.json";

// Category/setting registry used by UI builders and handlers
const configCategories = {
  Sniping: {
    description: "Settings for sniping commands.",
    settings: {
  ChannelList: {
        description: () =>
          config.snipeMode === "blacklist"
            ? "Channels where snipes are **not** allowed."
            : "Channels where snipes are allowed.",
        getDisplay: () => {
          if (config.snipeMode === "whitelist") {
            return config.snipingWhitelist && config.snipingWhitelist.length
              ? config.snipingWhitelist.map(id => `<#${id}>`).join("\n")
              : "*None*";
          } else {
            return config.snipingChannelList && config.snipingChannelList.length
              ? config.snipingChannelList.map(id => `<#${id}>`).join("\n")
              : "*None*";
          }
        },
        getLabel: () => 'Channels',
        getSummary: () => {
          const count = config.snipeMode === 'whitelist'
            ? (config.snipingWhitelist?.length || 0)
            : (config.snipingChannelList?.length || 0);
          return `${count}`;
        },
        buttons: [
          { id: "addChannel", label: "Add", style: ButtonStyle.Secondary, emoji: "#️⃣" },
          { id: "removeChannel", label: "Remove", style: ButtonStyle.Secondary, emoji: "🚫" }
        ]
      }
    }
  },
  Moderation: {
    description: "Settings for moderation commands.",
    settings: {
      ModeratorRoles: {
        description: "Roles allowed to use moderation commands.",
        getDisplay: () =>
          config.moderatorRoles.length
            ? config.moderatorRoles.map(id => `<@&${id}>`).join("\n")
            : "*None*",
        getLabel: () => "Moderator Roles",
        getSummary: () => {
          const n = config.moderatorRoles?.length || 0;
          return `${n}`;
        },
        buttons: [
          { id: "addRole", label: "Add", style: ButtonStyle.Secondary, emoji: "🛡️" },
          { id: "removeRole", label: "Remove", style: ButtonStyle.Secondary, emoji: "🧹" }
        ]
      },
      RoleLogBlacklist: {
        description: "Roles that will NOT be logged in role logs.",
        getDisplay: () =>
          (config.roleLogBlacklist && config.roleLogBlacklist.length)
            ? config.roleLogBlacklist.map(id => `<@&${id}>`).join("\n")
            : "*None*",
        getLabel: () => "Role Log Blacklist",
        getSummary: () => {
          const n = config.roleLogBlacklist?.length || 0;
          return `${n}`;
        },
        buttons: [
          { id: "addBlacklistRole", label: "Add", style: ButtonStyle.Secondary, emoji: "➕" },
          { id: "removeBlacklistRole", label: "Remove", style: ButtonStyle.Secondary, emoji: "🚫" }
        ]
      }
    }
  },
  Leveling: {
    description: "Settings for the leveling system.",
    settings: {
      LevelingChannels: {
        description: () =>
          config.levelingMode === "blacklist"
            ? "Channels where leveling XP is NOT awarded."
            : "Channels where leveling XP is awarded.",
        getDisplay: () => {
          const list = config.levelingChannelList || [];
          return list.length ? list.map(id => `<#${id}>`).join("\n") : "*None*";
        },
        getLabel: () => 'Channels',
        getSummary: () => `${config.levelingChannelList?.length || 0}`,
        buttons: [
          { id: "addChannel", label: "Add", style: ButtonStyle.Secondary, emoji: "#️⃣" },
          { id: "removeChannel", label: "Remove", style: ButtonStyle.Secondary, emoji: "🚫" }
        ]
      },
      RoleXPBlacklist: {
        description: "Members with these roles will not gain XP.",
        getDisplay: () => (config.roleXPBlacklist && config.roleXPBlacklist.length)
          ? config.roleXPBlacklist.map(id => `<@&${id}>`).join("\n")
          : "*None*",
        getLabel: () => "roles",
        getSummary: () => `${config.roleXPBlacklist?.length || 0}`,
        buttons: [
          { id: "addRole", label: "Add", style: ButtonStyle.Secondary, emoji: "🚫" },
          { id: "removeRole", label: "Remove", style: ButtonStyle.Secondary, emoji: "🧹" }
        ]
      },
      GlobalXPMultiplier: {
        description: () => `Set a global XP multiplier applied to all XP gains. Current: **x${(config.globalXPMultiplier ?? 1).toFixed(2)}**`,
        getDisplay: () => {
          const mult = typeof config.globalXPMultiplier === 'number' ? config.globalXPMultiplier : 1;
          const badge = mult > 1 ? "🔥 Boost Active" : (mult === 1 ? "➖ Normal" : "🧪 Custom");
          return `Multiplier: **x${mult.toFixed(2)}**  •  ${badge}`;
        },
        getLabel: () => "xp",
        getSummary: () => {
          const mult = typeof config.globalXPMultiplier === 'number' ? config.globalXPMultiplier : 1;
          return `x${mult.toFixed(2)}`;
        },
        buttons: [
          { id: "set", label: "Set", style: ButtonStyle.Secondary, emoji: "📈" },
          { id: "reset", label: "Reset", style: ButtonStyle.Secondary, emoji: "🔄" }
        ]
      },
      LevelRewards: {
        description: "Configure roles automatically granted at levels. Supports multiple roles per level.",
        getDisplay: () => {
          const entries = Object.entries(config.levelRewards || {});
          if (!entries.length) return "*None*";
          entries.sort((a,b) => Number(a[0]) - Number(b[0]));
          return entries.map(([lvl, roleIds]) => {
            const list = (Array.isArray(roleIds) ? roleIds : [roleIds]).map(id => `<@&${id}>`).join(", ");
            return `Lvl ${lvl} → ${list}`;
          }).join("\n");
        },
        getLabel: () => "rewards",
        getSummary: () => {
          const levels = Object.keys(config.levelRewards || {}).length;
          return `${levels} tier${levels === 1 ? '' : 's'}`;
        },
        buttons: [
          { id: "addLevel", label: "Add Lvl", style: ButtonStyle.Secondary, emoji: "🏆" },
          { id: "addReward", label: "Add", style: ButtonStyle.Secondary, emoji: "🎁" },
          { id: "removeReward", label: "Rm Rwd", style: ButtonStyle.Secondary, emoji: "✖️" },
          { id: "removeLevel", label: "Rm Lvl", style: ButtonStyle.Secondary, emoji: "🗑️" }
        ]
      },
      VCLevelRewards: {
        description: "Configure roles granted at VC levels (voice leveling). Separate from text chat rewards.",
        getDisplay: () => {
          const entries = Object.entries(config.vcLevelRewards || {});
          if (!entries.length) return "*None*";
          entries.sort((a,b) => Number(a[0]) - Number(b[0]));
          return entries.map(([lvl, roleIds]) => {
            const list = (Array.isArray(roleIds) ? roleIds : [roleIds]).map(id => `<@&${id}>`).join(", ");
            return `Lvl ${lvl} → ${list}`;
          }).join("\n");
        },
        getLabel: () => "vc rewards",
        getSummary: () => {
          const levels = Object.keys(config.vcLevelRewards || {}).length;
          return `${levels} tier${levels === 1 ? '' : 's'}`;
        },
        buttons: [
          { id: "addLevel", label: "Add Lvl", style: ButtonStyle.Secondary, emoji: "🎙️" },
          { id: "addReward", label: "Add", style: ButtonStyle.Secondary, emoji: "🔊" },
          { id: "removeReward", label: "Rm Rwd", style: ButtonStyle.Secondary, emoji: "✖️" },
          { id: "removeLevel", label: "Rm Lvl", style: ButtonStyle.Secondary, emoji: "🗑️" }
        ]
      }
    }
  },
  Economy: {
    description: "Economy and cash drops settings.",
    settings: {
      CashDrops: {
        description: () => {
          const e = config.cashDrops || {};
          const chance = (e.dropChance ?? 0.02) * 100;
          const min = e.minAmount ?? 25;
          const max = e.maxAmount ?? 125;
          const life = Math.floor((e.lifetimeMs ?? 60000) / 1000);
          return `Random cash drops during active chat. Chance: ${chance.toFixed(1)}% per message, Amount: ${min}-${max}, Lifetime: ${life}s.`;
        },
        getDisplay: () => {
          const e = config.cashDrops || {};
          return [
            `Chance per message: ${(Math.max(0, Math.min(1, e.dropChance ?? 0.02)) * 100).toFixed(2)}%`,
            `Amount range: ${e.minAmount ?? 25} - ${e.maxAmount ?? 125}`,
            `Lifetime: ${Math.floor((e.lifetimeMs ?? 60000) / 1000)}s`,
          ].join("\n");
        },
        getLabel: () => "Cash Drops",
        getSummary: () => {
          const e = config.cashDrops || {};
          const chance = (e.dropChance ?? 0.02) * 100;
          return `${chance.toFixed(1)}%`;
        },
        buttons: [
          { id: "setChance", label: "Chance", style: ButtonStyle.Secondary, emoji: "🎲" },
          { id: "setAmount", label: "Amounts", style: ButtonStyle.Secondary, emoji: "💰" },
          { id: "setLifetime", label: "Lifetime", style: ButtonStyle.Secondary, emoji: "⏱️" },
        ]
      }
    }
  },
  Testing: {
    description: "Owner-only testing utilities.",
    settings: {
      TestingMode: {
        description: () => `Toggle testing mode. When enabled, certain logs route to a test channel and the warnings UI can use seeded data. Currently: **${config.testingMode ? "Enabled" : "Disabled"}**`,
        getDisplay: () => (config.testingMode ? "Enabled" : "Disabled"),
        getLabel: () => "Testing Mode",
        getSummary: () => (config.testingMode ? "On" : "Off"),
        buttons: [
          { id: "enable", label: "Enable", style: ButtonStyle.Secondary, emoji: "✅" },
          { id: "disable", label: "Disable", style: ButtonStyle.Secondary, emoji: "🛑" }
        ]
      },
      TestingWarnings: {
        description: () => {
          const explicitUsers = Object.keys(config.testingWarnings || {}).length;
          const seededUsers = Object.keys(config.testingSeed || {}).length;
          return `Manage testing warnings used by the .warnings UI. Explicit: ${explicitUsers}, Seeded: ${seededUsers}.`;
        },
        getDisplay: () => {
          const explicitUsers = Object.keys(config.testingWarnings || {}).length;
          const seededUsers = Object.keys(config.testingSeed || {}).length;
          return `Explicit users: ${explicitUsers}\nSeeded users: ${seededUsers}`;
        },
        getLabel: () => "Testing Warnings",
        getSummary: () => {
          const explicitUsers = Object.keys(config.testingWarnings || {}).length;
          const seededUsers = Object.keys(config.testingSeed || {}).length;
          return `${explicitUsers} explicit • ${seededUsers} seeded`;
        },
        buttons: [
          { id: "reseed", label: "Reseed", style: ButtonStyle.Secondary, emoji: "🌱" },
          { id: "clear", label: "Clear", style: ButtonStyle.Secondary, emoji: "🧹" }
        ]
      }
    }
  }
};

module.exports = { ACTIVE_MENUS_FILE, configCategories };

```

===== FILE: commands/configMenu/handlers.js =====
```javascript
const { PermissionFlagsBits, ModalBuilder, TextInputBuilder, TextInputStyle, ActionRowBuilder } = require('discord.js');
const { saveConfig, config, touchSettingMeta } = require('../../utils/storage');
const { logConfigChange } = require('../../utils/configLogs');
const { updateTestingStatus } = require('../../utils/testingBanner');
const { buildCategoryEmbed, buildSettingEmbed, buildSettingButtons, buildSettingSelect } = require('./render');

async function refreshSettingMessage(message, categoryName, settingName) {
  try {
    await message.edit({
      embeds: [buildSettingEmbed(categoryName, settingName)],
      components: [buildSettingSelect(categoryName), ...buildSettingButtons(categoryName, settingName)],
    });
  } catch {}
}

async function openCategory(interaction, categoryName) {
  await interaction.update({ embeds: [buildCategoryEmbed(categoryName)], components: [buildSettingSelect(categoryName)] });
}

async function openSetting(interaction, categoryName, settingName) {
  const { buildSettingRow } = require('./render');
  await interaction.update({ embeds: [buildSettingEmbed(categoryName, settingName)], components: [buildSettingRow(categoryName, settingName)] });
}

// Minimal flows for a subset of buttons. More specialized flows can be added as needed.
async function handleButton(interaction, [categoryName, settingName, action]) {
  const ensureArray = (arr) => (Array.isArray(arr) ? arr : []);
  const parseId = (raw) => (raw || '').replace(/[^0-9]/g, '');

  // Economy > CashDrops
  if (categoryName === 'Economy' && settingName === 'CashDrops') {
    if (!interaction.memberPermissions.has(PermissionFlagsBits.Administrator)) {
  return interaction.reply({ content: 'Admin only.', flags: 1<<6 });
    }
    const e = (config.cashDrops = typeof config.cashDrops === 'object' && config.cashDrops ? config.cashDrops : { dropChance: 0.02, minAmount: 25, maxAmount: 125, lifetimeMs: 60000 });

    if (action === 'setChance') {
      const modalId = `config:modal:cashdrops:chance:${Date.now()}`;
      const modal = new ModalBuilder().setCustomId(modalId).setTitle('Set Drop Chance');
      const input = new TextInputBuilder()
        .setCustomId('chance')
        .setLabel('Chance per message (percent 0-100)')
        .setStyle(TextInputStyle.Short)
        .setMaxLength(6)
        .setRequired(true);
      modal.addComponents(new ActionRowBuilder().addComponents(input));
      await interaction.showModal(modal);
      const submitted = await interaction.awaitModalSubmit({ time: 30000, filter: i => i.customId === modalId && i.user.id === interaction.user.id }).catch(() => null);
      if (!submitted) return;
      const raw = submitted.fields.getTextInputValue('chance');
      const n = Number(raw);
      if (!Number.isFinite(n) || n < 0 || n > 100) {
  return submitted.reply({ content: 'Enter a valid percent between 0 and 100.', flags: 1<<6 });
      }
  const prev = e.dropChance;
  e.dropChance = Math.max(0, Math.min(1, n / 100));
	await saveConfig(); touchSettingMeta(`${categoryName}.${settingName}`);
  await logConfigChange(interaction.client, { user: interaction.user, change: `Set Cash Drop Chance`, before: prev, after: e.dropChance });
  await submitted.reply({ content: `Drop chance set to ${(e.dropChance * 100).toFixed(2)}% per message.`, flags: 1<<6 });
      await refreshSettingMessage(interaction.message, categoryName, settingName);
      return;
    }

    if (action === 'setAmount') {
      const modalId = `config:modal:cashdrops:amount:${Date.now()}`;
      const modal = new ModalBuilder().setCustomId(modalId).setTitle('Set Drop Amount Range');
      const minInput = new TextInputBuilder()
        .setCustomId('min')
        .setLabel('Minimum amount')
        .setStyle(TextInputStyle.Short)
        .setMaxLength(8)
        .setRequired(true);
      const maxInput = new TextInputBuilder()
        .setCustomId('max')
        .setLabel('Maximum amount')
        .setStyle(TextInputStyle.Short)
        .setMaxLength(8)
        .setRequired(true);
      modal.addComponents(new ActionRowBuilder().addComponents(minInput));
      modal.addComponents(new ActionRowBuilder().addComponents(maxInput));
      await interaction.showModal(modal);
      const submitted = await interaction.awaitModalSubmit({ time: 30000, filter: i => i.customId === modalId && i.user.id === interaction.user.id }).catch(() => null);
      if (!submitted) return;
      const min = Math.floor(Number(submitted.fields.getTextInputValue('min')));
      const max = Math.floor(Number(submitted.fields.getTextInputValue('max')));
      if (!Number.isFinite(min) || !Number.isFinite(max) || min < 0 || max < 0 || max < min) {
  return submitted.reply({ content: 'Enter valid non-negative integers (max >= min).', flags: 1<<6 });
      }
  const beforeRange = { min: e.minAmount, max: e.maxAmount };
  e.minAmount = min; e.maxAmount = max;
	await saveConfig(); touchSettingMeta(`${categoryName}.${settingName}`);
  await logConfigChange(interaction.client, { user: interaction.user, change: `Set Cash Drop Amount Range`, before: beforeRange, after: { min, max } });
  await submitted.reply({ content: `Drop amount range set to ${min}-${max}.`, flags: 1<<6 });
      await refreshSettingMessage(interaction.message, categoryName, settingName);
      return;
    }

    if (action === 'setLifetime') {
      const modalId = `config:modal:cashdrops:lifetime:${Date.now()}`;
      const modal = new ModalBuilder().setCustomId(modalId).setTitle('Set Drop Lifetime');
      const input = new TextInputBuilder()
        .setCustomId('secs')
        .setLabel('Lifetime in seconds (>= 5)')
        .setStyle(TextInputStyle.Short)
        .setMaxLength(8)
        .setRequired(true);
      modal.addComponents(new ActionRowBuilder().addComponents(input));
      await interaction.showModal(modal);
      const submitted = await interaction.awaitModalSubmit({ time: 30000, filter: i => i.customId === modalId && i.user.id === interaction.user.id }).catch(() => null);
      if (!submitted) return;
      const s = Math.floor(Number(submitted.fields.getTextInputValue('secs')));
      if (!Number.isFinite(s) || s < 5 || s > 86400) {
  return submitted.reply({ content: 'Enter a valid seconds value between 5 and 86400.', flags: 1<<6 });
      }
  const prev = e.lifetimeMs;
  e.lifetimeMs = s * 1000;
	await saveConfig(); touchSettingMeta(`${categoryName}.${settingName}`);
  await logConfigChange(interaction.client, { user: interaction.user, change: `Set Cash Drop Lifetime`, before: prev, after: e.lifetimeMs });
  await submitted.reply({ content: `Drop lifetime set to ${s}s.`, flags: 1<<6 });
      await refreshSettingMessage(interaction.message, categoryName, settingName);
      return;
    }

    return openSetting(interaction, categoryName, settingName);
  }

  // Simple numeric setter for GlobalXPMultiplier
  if (categoryName === 'Leveling' && settingName === 'GlobalXPMultiplier') {
    if (action === 'set') {
      const modalId = `config:modal:xpmult:${Date.now()}`;
      const modal = new ModalBuilder().setCustomId(modalId).setTitle('Set XP Multiplier');
      const input = new TextInputBuilder()
        .setCustomId('xpmult')
        .setLabel('Enter a number, e.g., 1, 1.5, 2')
        .setStyle(TextInputStyle.Short)
        .setMaxLength(8)
        .setRequired(true);
      modal.addComponents(new ActionRowBuilder().addComponents(input));
      await interaction.showModal(modal);
      const submitted = await interaction.awaitModalSubmit({ time: 30000, filter: i => i.customId === modalId && i.user.id === interaction.user.id }).catch(() => null);
      if (!submitted) return;
      const v = submitted.fields.getTextInputValue('xpmult');
      const num = Number(v);
      if (!Number.isFinite(num) || num <= 0 || num > 100) {
  return submitted.reply({ content: 'Enter a valid number >0 and <=100.', flags: 1<<6 });
      }
  const prev = config.globalXPMultiplier;
  config.globalXPMultiplier = num;
	await saveConfig(); touchSettingMeta(`${categoryName}.${settingName}`);
  await logConfigChange(interaction.client, { user: interaction.user, change: `Set Global XP Multiplier`, before: prev, after: num });
  await submitted.reply({ content: `XP multiplier set to x${num.toFixed(2)}.`, flags: 1<<6 });
      return;
    }
    if (action === 'reset') {
  const prev = config.globalXPMultiplier;
  config.globalXPMultiplier = 1;
	await saveConfig(); touchSettingMeta(`${categoryName}.${settingName}`);
  await logConfigChange(interaction.client, { user: interaction.user, change: `Reset Global XP Multiplier`, before: prev, after: 1 });
      return openSetting(interaction, categoryName, settingName);
    }
  }

  // Testing Mode toggle
  if (categoryName === 'Testing' && settingName === 'TestingMode') {
    if (!interaction.memberPermissions.has(PermissionFlagsBits.Administrator)) {
  return interaction.reply({ content: 'Admin only.', flags: 1<<6 });
    }
    const prev = !!config.testingMode;
    if (action === 'enable') config.testingMode = true; else if (action === 'disable') config.testingMode = false;
    await saveConfig();
    if (prev !== config.testingMode) {
      await logConfigChange(interaction.client, { user: interaction.user, change: `Testing Mode ${config.testingMode ? 'enabled' : 'disabled'}` });
      await updateTestingStatus(interaction.client, config.testingMode, interaction.user).catch(() => {});
    }
    return openSetting(interaction, categoryName, settingName);
  }

  // Testing Warnings utilities
  if (categoryName === 'Testing' && settingName === 'TestingWarnings') {
    if (String(interaction.user.id) !== String(process.env.OWNER_ID || '')) {
      // owner-only by environment guard; fall back to admin
      if (!interaction.memberPermissions.has(PermissionFlagsBits.Administrator)) {
  return interaction.reply({ content: 'Owner/Admin only.', flags: 1<<6 });
      }
    }
    if (action === 'reseed') {
      const seed = config.testingSeed || {};
      config.testingWarnings = JSON.parse(JSON.stringify(seed));
  await saveConfig(); touchSettingMeta(`${categoryName}.${settingName}`);
      await logConfigChange(interaction.client, { user: interaction.user, change: `Reseeded testing warnings from seed (${Object.keys(seed).length} users).` });
  await interaction.reply({ content: 'Reseeded testing warnings from seed.', flags: 1<<6 });
      await refreshSettingMessage(interaction.message, categoryName, settingName);
      return;
    }
    if (action === 'clear') {
      config.testingWarnings = {};
  await saveConfig(); touchSettingMeta(`${categoryName}.${settingName}`);
      await logConfigChange(interaction.client, { user: interaction.user, change: `Cleared testing warnings.` });
  await interaction.reply({ content: 'Cleared testing warnings.', flags: 1<<6 });
      await refreshSettingMessage(interaction.message, categoryName, settingName);
      return;
    }
  }

  // Sniping Channel management via modal
  if (categoryName === 'Sniping' && settingName === 'ChannelList' && (action === 'addChannel' || action === 'removeChannel')) {
  if (!interaction.guild) return interaction.reply({ content: 'Guild only.', flags: 1<<6 });
    const modalId = `config:modal:sniping:${action}:${Date.now()}`;
    const modal = new ModalBuilder().setCustomId(modalId).setTitle(action === 'addChannel' ? 'Add Channel' : 'Remove Channel');
    const input = new TextInputBuilder()
      .setCustomId('channel')
      .setLabel('Channel ID or mention')
      .setStyle(TextInputStyle.Short)
      .setRequired(true)
      .setMaxLength(32);
    modal.addComponents(new ActionRowBuilder().addComponents(input));
    await interaction.showModal(modal);
    const submitted = await interaction.awaitModalSubmit({ time: 30000, filter: i => i.customId === modalId && i.user.id === interaction.user.id }).catch(() => null);
    if (!submitted) return;
    const raw = submitted.fields.getTextInputValue('channel');
    const id = parseId(raw);
    const channel = interaction.guild.channels.cache.get(id);
  if (!channel) return submitted.reply({ content: 'Invalid or unknown channel.', flags: 1<<6 });
    const mode = (config.snipeMode === 'blacklist') ? 'blacklist' : 'whitelist';
    if (mode === 'whitelist') {
      config.snipingWhitelist = ensureArray(config.snipingWhitelist);
      if (action === 'addChannel') {
        if (!config.snipingWhitelist.includes(id)) config.snipingWhitelist.push(id);
        await saveConfig();
        await logConfigChange(interaction.client, { user: interaction.user, change: `Added <#${id}> to sniping whitelist.` });
  await submitted.reply({ content: `Added <#${id}> to whitelist.`, flags: 1<<6 });
      } else {
        config.snipingWhitelist = config.snipingWhitelist.filter(x => x !== id);
        await saveConfig();
        await logConfigChange(interaction.client, { user: interaction.user, change: `Removed <#${id}> from sniping whitelist.` });
  await submitted.reply({ content: `Removed <#${id}> from whitelist.`, flags: 1<<6 });
      }
    } else {
      config.snipingChannelList = ensureArray(config.snipingChannelList);
      if (action === 'addChannel') {
        if (!config.snipingChannelList.includes(id)) config.snipingChannelList.push(id);
        await saveConfig();
        await logConfigChange(interaction.client, { user: interaction.user, change: `Added <#${id}> to sniping blacklist.` });
  await submitted.reply({ content: `Added <#${id}> to blacklist.`, flags: 1<<6 });
      } else {
        config.snipingChannelList = config.snipingChannelList.filter(x => x !== id);
        await saveConfig();
        await logConfigChange(interaction.client, { user: interaction.user, change: `Removed <#${id}> from sniping blacklist.` });
  await submitted.reply({ content: `Removed <#${id}> from blacklist.`, flags: 1<<6 });
      }
    }
    await refreshSettingMessage(interaction.message, categoryName, settingName);
    return;
  }

  // Leveling Channel management via modal
  if (categoryName === 'Leveling' && settingName === 'LevelingChannels' && (action === 'addChannel' || action === 'removeChannel')) {
  if (!interaction.guild) return interaction.reply({ content: 'Guild only.', flags: 1<<6 });
    const modalId = `config:modal:leveling:${action}:${Date.now()}`;
    const modal = new ModalBuilder().setCustomId(modalId).setTitle(action === 'addChannel' ? 'Add Leveling Channel' : 'Remove Leveling Channel');
    const input = new TextInputBuilder()
      .setCustomId('channel')
      .setLabel('Channel ID or mention')
      .setStyle(TextInputStyle.Short)
      .setRequired(true)
      .setMaxLength(32);
    modal.addComponents(new ActionRowBuilder().addComponents(input));
    await interaction.showModal(modal);
    const submitted = await interaction.awaitModalSubmit({ time: 30000, filter: i => i.customId === modalId && i.user.id === interaction.user.id }).catch(() => null);
    if (!submitted) return;
    const raw = submitted.fields.getTextInputValue('channel');
    const id = parseId(raw);
    const channel = interaction.guild.channels.cache.get(id);
  if (!channel) return submitted.reply({ content: 'Invalid or unknown channel.', flags: 1<<6 });
    config.levelingChannelList = ensureArray(config.levelingChannelList);
    if (action === 'addChannel') {
      if (!config.levelingChannelList.includes(id)) config.levelingChannelList.push(id);
  await saveConfig(); touchSettingMeta(`${categoryName}.${settingName}`);
      await logConfigChange(interaction.client, { user: interaction.user, change: `Added <#${id}> to leveling channel list.` });
  await submitted.reply({ content: `Added <#${id}>.`, flags: 1<<6 });
    } else {
      config.levelingChannelList = config.levelingChannelList.filter(x => x !== id);
    await saveConfig(); touchSettingMeta(`${categoryName}.${settingName}`);
      await logConfigChange(interaction.client, { user: interaction.user, change: `Removed <#${id}> from leveling channel list.` });
  await submitted.reply({ content: `Removed <#${id}>.`, flags: 1<<6 });
    }
    await refreshSettingMessage(interaction.message, categoryName, settingName);
    return;
  }

  // Moderation roles management
  if (categoryName === 'Moderation' && settingName === 'ModeratorRoles' && (action === 'addRole' || action === 'removeRole')) {
  if (!interaction.guild) return interaction.reply({ content: 'Guild only.', flags: 1<<6 });
    const modalId = `config:modal:modroles:${action}:${Date.now()}`;
    const modal = new ModalBuilder().setCustomId(modalId).setTitle(action === 'addRole' ? 'Add Moderator Role' : 'Remove Moderator Role');
    const input = new TextInputBuilder()
      .setCustomId('role')
      .setLabel('Role ID or mention')
      .setStyle(TextInputStyle.Short)
      .setRequired(true)
      .setMaxLength(32);
    modal.addComponents(new ActionRowBuilder().addComponents(input));
    await interaction.showModal(modal);
    const submitted = await interaction.awaitModalSubmit({ time: 30000, filter: i => i.customId === modalId && i.user.id === interaction.user.id }).catch(() => null);
    if (!submitted) return;
    const raw = submitted.fields.getTextInputValue('role');
    const id = parseId(raw);
    const role = interaction.guild.roles.cache.get(id);
  if (!role) return submitted.reply({ content: 'Invalid or unknown role.', flags: 1<<6 });
    config.moderatorRoles = ensureArray(config.moderatorRoles);
    if (action === 'addRole') {
      if (!config.moderatorRoles.includes(id)) config.moderatorRoles.push(id);
  await saveConfig(); touchSettingMeta(`${categoryName}.${settingName}`);
      await logConfigChange(interaction.client, { user: interaction.user, change: `Added <@&${id}> to moderatorRoles.` });
  await submitted.reply({ content: `Added <@&${id}>.`, flags: 1<<6 });
    } else {
      config.moderatorRoles = config.moderatorRoles.filter(x => x !== id);
  await saveConfig(); touchSettingMeta(`${categoryName}.${settingName}`);
      await logConfigChange(interaction.client, { user: interaction.user, change: `Removed <@&${id}> from moderatorRoles.` });
  await submitted.reply({ content: `Removed <@&${id}>.`, flags: 1<<6 });
    }
    await refreshSettingMessage(interaction.message, categoryName, settingName);
    return;
  }

  // Role Log Blacklist management
  if (categoryName === 'Moderation' && settingName === 'RoleLogBlacklist' && (action === 'addBlacklistRole' || action === 'removeBlacklistRole')) {
  if (!interaction.guild) return interaction.reply({ content: 'Guild only.', flags: 1<<6 });
    const modalId = `config:modal:rolelog:${action}:${Date.now()}`;
    const modal = new ModalBuilder().setCustomId(modalId).setTitle(action === 'addBlacklistRole' ? 'Add Role to Blacklist' : 'Remove Role from Blacklist');
    const input = new TextInputBuilder()
      .setCustomId('role')
      .setLabel('Role ID or mention')
      .setStyle(TextInputStyle.Short)
      .setRequired(true)
      .setMaxLength(32);
    modal.addComponents(new ActionRowBuilder().addComponents(input));
    await interaction.showModal(modal);
    const submitted = await interaction.awaitModalSubmit({ time: 30000, filter: i => i.customId === modalId && i.user.id === interaction.user.id }).catch(() => null);
    if (!submitted) return;
    const raw = submitted.fields.getTextInputValue('role');
    const id = parseId(raw);
    const role = interaction.guild.roles.cache.get(id);
  if (!role) return submitted.reply({ content: 'Invalid or unknown role.', flags: 1<<6 });
    config.roleLogBlacklist = ensureArray(config.roleLogBlacklist);
    if (action === 'addBlacklistRole') {
      if (!config.roleLogBlacklist.includes(id)) config.roleLogBlacklist.push(id);
  await saveConfig(); touchSettingMeta(`${categoryName}.${settingName}`);
      await logConfigChange(interaction.client, { user: interaction.user, change: `Blacklisted <@&${id}> from role logs.` });
  await submitted.reply({ content: `Blacklisted <@&${id}> from role logs.`, flags: 1<<6 });
    } else {
      config.roleLogBlacklist = config.roleLogBlacklist.filter(x => x !== id);
  await saveConfig(); touchSettingMeta(`${categoryName}.${settingName}`);
      await logConfigChange(interaction.client, { user: interaction.user, change: `Removed <@&${id}> from role log blacklist.` });
  await submitted.reply({ content: `Removed <@&${id}> from role log blacklist.`, flags: 1<<6 });
    }
    await refreshSettingMessage(interaction.message, categoryName, settingName);
    return;
  }

  // Leveling Role XP Blacklist management
  if (categoryName === 'Leveling' && settingName === 'RoleXPBlacklist' && (action === 'addRole' || action === 'removeRole')) {
  if (!interaction.guild) return interaction.reply({ content: 'Guild only.', flags: 1<<6 });
    const modalId = `config:modal:rolexp:${action}:${Date.now()}`;
    const modal = new ModalBuilder().setCustomId(modalId).setTitle(action === 'addRole' ? 'Add Blocked Role' : 'Remove Blocked Role');
    const input = new TextInputBuilder()
      .setCustomId('role')
      .setLabel('Role ID or mention')
      .setStyle(TextInputStyle.Short)
      .setRequired(true)
      .setMaxLength(32);
    modal.addComponents(new ActionRowBuilder().addComponents(input));
    await interaction.showModal(modal);
    const submitted = await interaction.awaitModalSubmit({ time: 30000, filter: i => i.customId === modalId && i.user.id === interaction.user.id }).catch(() => null);
    if (!submitted) return;
    const raw = submitted.fields.getTextInputValue('role');
    const id = parseId(raw);
    const role = interaction.guild.roles.cache.get(id);
  if (!role) return submitted.reply({ content: 'Invalid or unknown role.', flags: 1<<6 });
    config.roleXPBlacklist = ensureArray(config.roleXPBlacklist);
    if (action === 'addRole') {
      if (!config.roleXPBlacklist.includes(id)) config.roleXPBlacklist.push(id);
      await saveConfig();
      await logConfigChange(interaction.client, { user: interaction.user, change: `Added <@&${id}> to XP blacklist.` });
  await submitted.reply({ content: `Added <@&${id}> to XP blacklist.`, flags: 1<<6 });
    } else {
      config.roleXPBlacklist = config.roleXPBlacklist.filter(x => x !== id);
      await saveConfig();
      await logConfigChange(interaction.client, { user: interaction.user, change: `Removed <@&${id}> from XP blacklist.` });
  await submitted.reply({ content: `Removed <@&${id}> from XP blacklist.`, flags: 1<<6 });
    }
    await refreshSettingMessage(interaction.message, categoryName, settingName);
    return;
  }

  // Level Rewards management
  if (categoryName === 'Leveling' && settingName === 'LevelRewards' && (action === 'addLevel' || action === 'removeLevel' || action === 'addReward' || action === 'removeReward')) {
  if (!interaction.guild) return interaction.reply({ content: 'Guild only.', flags: 1<<6 });
    const parseRolesCsv = (txt) =>
      (txt || '')
        .split(',')
        .map(s => s.trim())
        .filter(Boolean)
        .map(s => s.replace(/[^0-9]/g, ''))
        .filter(Boolean);
    const ensureLevelArr = (lvl) => {
      if (typeof config.levelRewards !== 'object' || !config.levelRewards) config.levelRewards = {};
      if (!Array.isArray(config.levelRewards[lvl])) config.levelRewards[lvl] = [];
      return config.levelRewards[lvl];
    };

    if (action === 'addLevel' || action === 'removeLevel') {
      const modalId = `config:modal:levelrewards:${action}:${Date.now()}`;
      const modal = new ModalBuilder().setCustomId(modalId).setTitle(action === 'addLevel' ? 'Add Level' : 'Remove Level');
      const levelInput = new TextInputBuilder()
        .setCustomId('level')
        .setLabel('Level (number)')
        .setStyle(TextInputStyle.Short)
        .setRequired(true)
        .setMaxLength(6);
      modal.addComponents(new ActionRowBuilder().addComponents(levelInput));
      await interaction.showModal(modal);
      const submitted = await interaction.awaitModalSubmit({ time: 30000, filter: i => i.customId === modalId && i.user.id === interaction.user.id }).catch(() => null);
      if (!submitted) return;
      const levelStr = submitted.fields.getTextInputValue('level');
      const lvlNum = Number(levelStr);
      if (!Number.isInteger(lvlNum) || lvlNum < 0 || lvlNum > 10000) {
  return submitted.reply({ content: 'Enter a valid non-negative integer level (<= 10000).', flags: 1<<6 });
      }
      if (action === 'addLevel') {
        ensureLevelArr(String(lvlNum));
        await saveConfig();
        await logConfigChange(interaction.client, { user: interaction.user, change: `Created Level ${lvlNum} in levelRewards.` });
  await submitted.reply({ content: `Created level ${lvlNum}.`, flags: 1<<6 });
      } else {
        if (config.levelRewards && config.levelRewards[String(lvlNum)]) delete config.levelRewards[String(lvlNum)];
        await saveConfig();
        await logConfigChange(interaction.client, { user: interaction.user, change: `Removed Level ${lvlNum} from levelRewards.` });
  await submitted.reply({ content: `Removed level ${lvlNum}.`, flags: 1<<6 });
      }
      await refreshSettingMessage(interaction.message, categoryName, settingName);
      return;
    }

    if (action === 'addReward' || action === 'removeReward') {
      const modalId = `config:modal:levelrewards:${action}:${Date.now()}`;
      const modal = new ModalBuilder().setCustomId(modalId).setTitle(action === 'addReward' ? 'Add Rewards' : 'Remove Rewards');
      const levelInput = new TextInputBuilder()
        .setCustomId('level')
        .setLabel('Level (number)')
        .setStyle(TextInputStyle.Short)
        .setRequired(true)
        .setMaxLength(6);
      const rolesInput = new TextInputBuilder()
        .setCustomId('roles')
        .setLabel('Role IDs or mentions (comma-separated)')
        .setStyle(TextInputStyle.Paragraph)
        .setRequired(true)
        .setMaxLength(400);
      modal.addComponents(new ActionRowBuilder().addComponents(levelInput));
      modal.addComponents(new ActionRowBuilder().addComponents(rolesInput));
      await interaction.showModal(modal);
      const submitted = await interaction.awaitModalSubmit({ time: 30000, filter: i => i.customId === modalId && i.user.id === interaction.user.id }).catch(() => null);
      if (!submitted) return;
      const levelStr = submitted.fields.getTextInputValue('level');
      const rolesStr = submitted.fields.getTextInputValue('roles');
      const lvlNum = Number(levelStr);
      if (!Number.isInteger(lvlNum) || lvlNum < 0 || lvlNum > 10000) {
  return submitted.reply({ content: 'Enter a valid non-negative integer level (<= 10000).', flags: 1<<6 });
      }
      const ids = parseRolesCsv(rolesStr);
  if (!ids.length) return submitted.reply({ content: 'Provide at least one role.', flags: 1<<6 });
      const validIds = ids.filter(id => !!interaction.guild.roles.cache.get(id));
  if (!validIds.length) return submitted.reply({ content: 'No valid roles found in input.', flags: 1<<6 });

      const key = String(lvlNum);
      const arr = ensureLevelArr(key);
      if (action === 'addReward') {
        for (const id of validIds) if (!arr.includes(id)) arr.push(id);
        await saveConfig();
        await logConfigChange(interaction.client, { user: interaction.user, change: `Added ${validIds.map(id => `<@&${id}>`).join(', ')} to Level ${lvlNum}.` });
  await submitted.reply({ content: `Added ${validIds.map(id => `<@&${id}>`).join(', ')} to level ${lvlNum}.`, flags: 1<<6 });
      } else {
        const before = arr.length;
        const set = new Set(validIds);
        config.levelRewards[key] = arr.filter(id => !set.has(id));
        const after = config.levelRewards[key].length;
        await saveConfig();
        await logConfigChange(interaction.client, { user: interaction.user, change: `Removed ${before - after} role(s) from Level ${lvlNum}.` });
  await submitted.reply({ content: `Removed ${before - after} role(s) from level ${lvlNum}.`, flags: 1<<6 });
      }
      await refreshSettingMessage(interaction.message, categoryName, settingName);
      return;
    }
  }

  // VC Level Rewards management
  if (categoryName === 'Leveling' && settingName === 'VCLevelRewards' && (action === 'addLevel' || action === 'removeLevel' || action === 'addReward' || action === 'removeReward')) {
  if (!interaction.guild) return interaction.reply({ content: 'Guild only.', flags: 1<<6 });
    const parseRolesCsv = (txt) =>
      (txt || '')
        .split(',')
        .map(s => s.trim())
        .filter(Boolean)
        .map(s => s.replace(/[^0-9]/g, ''))
        .filter(Boolean);
    const ensureLevelArr = (lvl) => {
      if (typeof config.vcLevelRewards !== 'object' || !config.vcLevelRewards) config.vcLevelRewards = {};
      if (!Array.isArray(config.vcLevelRewards[lvl])) config.vcLevelRewards[lvl] = [];
      return config.vcLevelRewards[lvl];
    };

    if (action === 'addLevel' || action === 'removeLevel') {
      const modalId = `config:modal:vclevelrewards:${action}:${Date.now()}`;
      const modal = new ModalBuilder().setCustomId(modalId).setTitle(action === 'addLevel' ? 'Add VC Level' : 'Remove VC Level');
      const levelInput = new TextInputBuilder()
        .setCustomId('level')
        .setLabel('Level (number)')
        .setStyle(TextInputStyle.Short)
        .setRequired(true)
        .setMaxLength(6);
      modal.addComponents(new ActionRowBuilder().addComponents(levelInput));
      await interaction.showModal(modal);
      const submitted = await interaction.awaitModalSubmit({ time: 30000, filter: i => i.customId === modalId && i.user.id === interaction.user.id }).catch(() => null);
      if (!submitted) return;
      const levelStr = submitted.fields.getTextInputValue('level');
      const lvlNum = Number(levelStr);
      if (!Number.isInteger(lvlNum) || lvlNum < 0 || lvlNum > 10000) {
  return submitted.reply({ content: 'Enter a valid non-negative integer level (<= 10000).', flags: 1<<6 });
      }
      if (action === 'addLevel') {
        ensureLevelArr(String(lvlNum));
        await saveConfig();
        await logConfigChange(interaction.client, { user: interaction.user, change: `Created VC Level ${lvlNum} in vcLevelRewards.` });
  await submitted.reply({ content: `Created VC level ${lvlNum}.`, flags: 1<<6 });
      } else {
        if (config.vcLevelRewards && config.vcLevelRewards[String(lvlNum)]) delete config.vcLevelRewards[String(lvlNum)];
        await saveConfig();
        await logConfigChange(interaction.client, { user: interaction.user, change: `Removed VC Level ${lvlNum} from vcLevelRewards.` });
  await submitted.reply({ content: `Removed VC level ${lvlNum}.`, flags: 1<<6 });
      }
      await refreshSettingMessage(interaction.message, categoryName, settingName);
      return;
    }

    if (action === 'addReward' || action === 'removeReward') {
      const modalId = `config:modal:vclevelrewards:${action}:${Date.now()}`;
      const modal = new ModalBuilder().setCustomId(modalId).setTitle(action === 'addReward' ? 'Add VC Rewards' : 'Remove VC Rewards');
      const levelInput = new TextInputBuilder()
        .setCustomId('level')
        .setLabel('Level (number)')
        .setStyle(TextInputStyle.Short)
        .setRequired(true)
        .setMaxLength(6);
      const rolesInput = new TextInputBuilder()
        .setCustomId('roles')
        .setLabel('Role IDs or mentions (comma-separated)')
        .setStyle(TextInputStyle.Paragraph)
        .setRequired(true)
        .setMaxLength(400);
      modal.addComponents(new ActionRowBuilder().addComponents(levelInput));
      modal.addComponents(new ActionRowBuilder().addComponents(rolesInput));
      await interaction.showModal(modal);
      const submitted = await interaction.awaitModalSubmit({ time: 30000, filter: i => i.customId === modalId && i.user.id === interaction.user.id }).catch(() => null);
      if (!submitted) return;
      const levelStr = submitted.fields.getTextInputValue('level');
      const rolesStr = submitted.fields.getTextInputValue('roles');
      const lvlNum = Number(levelStr);
      if (!Number.isInteger(lvlNum) || lvlNum < 0 || lvlNum > 10000) {
  return submitted.reply({ content: 'Enter a valid non-negative integer level (<= 10000).', flags: 1<<6 });
      }
      const ids = parseRolesCsv(rolesStr);
  if (!ids.length) return submitted.reply({ content: 'Provide at least one role.', flags: 1<<6 });
      const validIds = ids.filter(id => !!interaction.guild.roles.cache.get(id));
  if (!validIds.length) return submitted.reply({ content: 'No valid roles found in input.', flags: 1<<6 });

      const key = String(lvlNum);
      const arr = ensureLevelArr(key);
      if (action === 'addReward') {
        for (const id of validIds) if (!arr.includes(id)) arr.push(id);
        await saveConfig();
        await logConfigChange(interaction.client, { user: interaction.user, change: `Added ${validIds.map(id => `<@&${id}>`).join(', ')} to VC Level ${lvlNum}.` });
  await submitted.reply({ content: `Added ${validIds.map(id => `<@&${id}>`).join(', ')} to VC level ${lvlNum}.`, flags: 1<<6 });
      } else {
        const before = arr.length;
        const set = new Set(validIds);
        config.vcLevelRewards[key] = arr.filter(id => !set.has(id));
        const after = config.vcLevelRewards[key].length;
        await saveConfig();
        await logConfigChange(interaction.client, { user: interaction.user, change: `Removed ${before - after} role(s) from VC Level ${lvlNum}.` });
  await submitted.reply({ content: `Removed ${before - after} role(s) from VC level ${lvlNum}.`, flags: 1<<6 });
      }
      await refreshSettingMessage(interaction.message, categoryName, settingName);
      return;
    }
  }

  return interaction.reply({ content: 'This action is not implemented yet in the modular UI.', flags: 1<<6 });
}

// No-op for now; kept for future modal routes if needed from elsewhere
async function handleModal() { return; }

module.exports = { openCategory, openSetting, handleButton, handleModal };

```

===== FILE: commands/configMenu/index.js =====
```javascript
const { buildRootEmbed, buildCategorySelect, buildCategoryEmbed, buildSettingEmbed, buildSettingSelect, buildSettingRow, renderSettingEmbed } = require('./render');
const { handleButton } = require('./handlers');
const { OWNER_ID } = require('../moderation/permissions');
const { config, saveConfig } = require('../../utils/storage');
const { logConfigChange } = require('../../utils/configLogs');
const ActiveMenus = require('../../utils/activeMenus');

function buildRootComponents(currentCat) {
  // buildCategorySelect already returns an array of ActionRowBuilders; return directly (avoid nested array)
  return buildCategorySelect(currentCat || null);
}

async function handleConfigMenuCommand(message) {
  if (String(message.author.id) !== String(OWNER_ID)) {
    await message.reply({ content: 'Only the Owner can use this.' });
    return;
  }
  const embed = buildRootEmbed();
  const components = buildRootComponents();
  let sent;
  try {
    sent = await message.channel.send({ embeds: [embed], components });
  } catch (e) {
    console.error('[configMenu] send failed', e);
    try { await message.reply({ content: 'Failed to open config menu (logged).', flags: 1<<6 }); } catch {}
    return;
  }
  ActiveMenus.registerMessage(sent, { type: 'configMenu', userId: message.author.id, data: { view: 'root' } });
}

// ActiveMenus handler
ActiveMenus.registerHandler('configMenu', async (interaction, session) => {
  if (!interaction.isButton() && !interaction.isModalSubmit()) return;
  if (interaction.user.id !== session.userId) {
  if (interaction.isRepliable()) return interaction.reply({ content: 'Not your session.', flags: 1<<6 }).catch(()=>{});
    return;
  }
  try {
    if (interaction.isButton()) {
      const id = interaction.customId;
      // Category navigation
      if (id.startsWith('cfg:cat:')) {
        const categoryName = id.split(':')[2];
        session.data.view = 'category';
        session.data.category = categoryName;
        const catRows = buildCategorySelect(categoryName);
        const setRows = buildSettingSelect(categoryName);
        return interaction.update({ embeds: [buildCategoryEmbed(categoryName)], components: [...catRows, ...setRows].slice(0,5) });
      }
      if (id.startsWith('cfg:set:')) {
        const [, , catName, settingName] = id.split(':');
        session.data.view = 'setting';
        session.data.category = catName; session.data.setting = settingName;
        const catRows = buildCategorySelect(catName);
        const settingRows = buildSettingRow(catName, settingName);
        return interaction.update({ embeds: [buildSettingEmbed(catName, settingName)], components: [...catRows, ...settingRows].slice(0,5) });
      }
      if (id.startsWith('config:')) {
        // legacy setting action buttons
        const parts = id.split(':').slice(1); // category:setting:action
        await handleButton(interaction, parts);
        return;
      }
      if (id.startsWith('settingMode_')) {
        const [, cat, key, mode] = id.split('_');
        if (cat === 'Sniping' && key === 'ChannelList') {
          const newMode = mode === 'whitelist' ? 'whitelist' : 'blacklist';
          if (config.snipeMode !== newMode) { config.snipeMode = newMode; await saveConfig(); try { await logConfigChange(interaction.client, { user: interaction.user, change: `Set Sniping mode to ${newMode}.` }); } catch {} }
          const catRows = buildCategorySelect(cat);
          const rows = buildSettingRow('Sniping', 'ChannelList');
          return interaction.update({ embeds: [buildSettingEmbed('Sniping', 'ChannelList')], components: [...catRows, ...rows].slice(0,5) });
        }
        if (cat === 'Leveling' && key === 'LevelingChannels') {
          const newMode = mode === 'whitelist' ? 'whitelist' : 'blacklist';
          if (config.levelingMode !== newMode) { config.levelingMode = newMode; await saveConfig(); try { await logConfigChange(interaction.client, { user: interaction.user, change: `Set Leveling mode to ${newMode}.` }); } catch {} }
          const catRows = buildCategorySelect(cat);
          const rows = buildSettingRow('Leveling', 'LevelingChannels');
          return interaction.update({ embeds: [buildSettingEmbed('Leveling', 'LevelingChannels')], components: [...catRows, ...rows].slice(0,5) });
        }
        return;
      }
    } else if (interaction.isModalSubmit()) {
      // Modal submits are handled inside handleButton flows which reply/update separately; nothing extra here.
      return;
    }
  } catch (err) {
    console.error('[configMenu] handler error:', err);
    if (interaction.isRepliable() && !interaction.replied) {
  try { await interaction.reply({ content: 'Error handling config interaction.', flags: 1<<6 }); } catch {}
    }
  }
});

// Legacy exports
const handleMessageCreate = handleConfigMenuCommand;

module.exports = { handleConfigMenuCommand, handleMessageCreate, renderSettingEmbed };

```

===== FILE: commands/configMenu/render.js =====
```javascript
const { EmbedBuilder, ActionRowBuilder, StringSelectMenuBuilder, ButtonBuilder, ButtonStyle } = require("discord.js");
const { semanticButton, buildNavRow, applyToggleVisual, buildSettingEmbedUnified, registerToggle } = require('../../utils/ui');
const theme = require("../../utils/theme");
const { config, settingMeta } = require("../../utils/storage");
const { configCategories } = require("./constants");

function buildRootEmbed() {
  const e = new EmbedBuilder()
    .setTitle(`${theme.emojis.settings} Configuration`)
    .setColor(theme.colors.primary)
    .setDescription(
      "Select a category to view and manage settings.\n\n" +
        Object.entries(configCategories)
          .map(
            ([name, cat]) =>
              `• **${name}** — ${
                typeof cat.description === "function" ? cat.description() : cat.description
              }`
          )
          .join("\n")
    )
    .setFooter({ text: `Testing Mode: ${config.testingMode ? "ON" : "OFF"}` });
  return e;
}

// Build category navigation as buttons (uniform with Help UI)
function buildCategorySelect(currentCategory) {
  // Multi-row adaptive: show all categories; no Back concept
  const rows = [];
  const emojiByCat = { Sniping: '🔭', Moderation: '🛡️', Leveling: '📈', Economy: '💰', Testing: '🧪' };
  let current = buildNavRow([]);
  for (const name of Object.keys(configCategories)) {
    const active = currentCategory === name;
    const btn = semanticButton(active ? 'primary' : 'nav', { id: `cfg:cat:${name}`, label: name, emoji: emojiByCat[name] || theme.emojis.settings, active });
    if (current.components.length >= 5) { rows.push(current); current = buildNavRow([]); }
    current.addComponents(btn);
  }
  if (current.components.length) rows.push(current);
  return rows;
}

function buildSettingButtons(categoryName, settingName) {
  const cat = configCategories[categoryName];
  const setting = cat?.settings?.[settingName];
  if (!setting) return [];

  const rows = [];
  let row = buildNavRow([]);
  for (const btn of (setting.buttons || [])) {
  const compact = (btn.label || '').length > 14 ? btn.label.slice(0,11) + '…' : btn.label;
  const kind = btn.style === ButtonStyle.Danger ? 'danger' : (btn.style === ButtonStyle.Success ? 'success' : (btn.style === ButtonStyle.Primary ? 'primary' : 'nav'));
  const b = semanticButton(kind, { id: `config:${categoryName}:${settingName}:${btn.id}`, label: compact, emoji: btn.emoji });
    if (row.components.length >= 5) {
      rows.push(row);
      row = new ActionRowBuilder();
    }
    row.addComponents(b);
  }
  if (row.components.length) rows.push(row);
  return rows;
}

function buildCategoryEmbed(categoryName) {
  const cat = configCategories[categoryName];
  const e = new EmbedBuilder()
  .setTitle(`${theme.emojis.select} ${categoryName}`)
    .setColor(theme.colors.primary)
    .setDescription(
      typeof cat.description === "function" ? cat.description() : cat.description || ""
    );

  const lines = [];
  for (const [settingName, setting] of Object.entries(cat.settings)) {
    const label = setting.getLabel ? setting.getLabel() : settingName;
    const summary = setting.getSummary ? setting.getSummary() : '';
    lines.push(`• **${label}** — ${summary}`);
  }
  if (lines.length) e.addFields({ name: "Settings", value: lines.join("\n") });

  return e;
}

function buildSettingEmbed(categoryName, settingName) {
  const cat = configCategories[categoryName];
  const setting = cat?.settings?.[settingName];
  const toggleKey = (categoryName === 'Testing' && settingName === 'TestingMode') ? 'testingMode'
    : (categoryName === 'Sniping' && settingName === 'ChannelList') ? 'snipeMode'
    : (categoryName === 'Leveling' && settingName === 'LevelingChannels') ? 'levelingMode'
    : null;
  const title = `${theme.emojis.edit} ${categoryName} • ${setting.getLabel ? setting.getLabel() : settingName}`;
  const metaKey = `${categoryName}.${settingName}`;
  const lastUpdatedTs = settingMeta?.[metaKey]?.lastUpdated;
  const e = buildSettingEmbedUnified({
    title,
    description: (typeof setting.description === 'function' ? setting.description() : setting.description) || '',
    current: setting.getDisplay ? setting.getDisplay() : '—',
    toggleKey,
    lastUpdatedTs
  });
  return e;
}

// Build per-category setting list as a single row of buttons + Back
function buildSettingSelect(categoryName) {
  const cat = configCategories[categoryName];
  const rows = [];
  let row = buildNavRow([]);
  for (const name of Object.keys(cat.settings)) {
    const s = cat.settings[name];
    const label = s.getLabel ? s.getLabel() : name;
    const compact = label.length > 12 ? label.slice(0,9)+'…' : label;
    const btn = semanticButton('primary', { id: `cfg:set:${categoryName}:${name}`, label: compact, emoji: theme.emojis.edit });
    if (row.components.length >= 5) { rows.push(row); row = buildNavRow([]); }
    row.addComponents(btn);
  }
  if (row.components.length) rows.push(row);
  return rows;
}

// Build a single row for a specific setting: optional mode toggles + actions + Back
function buildSettingRow(categoryName, settingName) {
  const rows = [];
  let row = buildNavRow([]);
  const isSnipingChannels = categoryName === 'Sniping' && settingName === 'ChannelList';
  const isLevelingChannels = categoryName === 'Leveling' && settingName === 'LevelingChannels';
  if (isSnipingChannels || isLevelingChannels) {
    const mode = isSnipingChannels ? (config.snipeMode || 'whitelist') : (config.levelingMode || 'blacklist');
    const wlActive = mode === 'whitelist';
    const blActive = mode === 'blacklist';
    row.addComponents(semanticButton(wlActive ? 'success':'nav', { id: `settingMode_${categoryName}_${settingName}_whitelist`, label: 'White', emoji: theme.emojis.enable, active: wlActive }));
    if (row.components.length >=5) { rows.push(row); row = buildNavRow([]); }
    row.addComponents(semanticButton(blActive ? 'danger':'nav', { id: `settingMode_${categoryName}_${settingName}_blacklist`, label: 'Black', emoji: theme.emojis.disable, active: blActive }));
  }
  const cat = configCategories[categoryName];
  const setting = cat?.settings?.[settingName];
  for (const btn of (setting?.buttons || [])) {
    const compactBtn = btn.label.length > 12 ? btn.label.slice(0,9)+'…' : btn.label;
    const kind = btn.style === ButtonStyle.Danger ? 'danger' : (btn.style === ButtonStyle.Success ? 'success' : (btn.style === ButtonStyle.Primary ? 'primary' : 'nav'));
    const b = semanticButton(kind, { id: `config:${categoryName}:${settingName}:${btn.id}`, label: compactBtn, emoji: btn.emoji });
    if (row.components.length >=5) { rows.push(row); row = buildNavRow([]); }
    row.addComponents(b);
  }
  if (row.components.length) rows.push(row);
  return rows;
}

module.exports = {
  buildRootEmbed,
  buildCategorySelect,
  buildCategoryEmbed,
  buildSettingEmbed,
  buildSettingButtons,
  buildSettingSelect,
  buildSettingRow,
};

// Legacy-compatible helper used by interactionEvents to refresh a single setting view.
function renderSettingEmbed(categoryName, settingKey) {
  const cat = configCategories[categoryName];
  const setting = cat?.settings?.[settingKey];
  if (!cat || !setting) {
    const e = new EmbedBuilder()
      .setTitle("Not Found")
      .setColor(theme.colors.danger)
      .setDescription("Unknown setting.");
    return { embed: e, row: new ActionRowBuilder() };
  }

  // Title
  const keyLabel = setting.getLabel ? setting.getLabel() : settingKey;
  const titleEmoji =
    categoryName === "Leveling"
      ? settingKey.toLowerCase().includes("channel")
        ? theme.emojis.select
        : settingKey.toLowerCase().includes("multiplier")
        ? theme.emojis.counter
        : settingKey.toLowerCase().includes("reward")
        ? "🎁"
        : theme.emojis.rank
      : categoryName === "Sniping"
      ? settingKey.toLowerCase().includes("channel")
        ? "🔭"
        : theme.emojis.edit
      : categoryName === "Economy"
      ? theme.emojis.cash
      : theme.emojis.moderator;
  const prettyTitle = `${titleEmoji} ${categoryName} — ${keyLabel}`;
  const color =
    categoryName === "Leveling"
      ? theme.colors.primary
      : categoryName === "Sniping"
      ? theme.colors.neutral
      : theme.colors.primary;
  const itemEmbed = new EmbedBuilder()
    .setTitle(prettyTitle)
    .setColor(color)
    .setDescription(
      `**${
        typeof setting.description === "function"
          ? setting.description()
          : setting.description
      }**`
    )
    .addFields({ name: "Current", value: setting.getDisplay ? setting.getDisplay() : "—" });
  if ((categoryName === 'Testing' && settingKey === 'TestingMode') || (categoryName==='Sniping' && settingKey==='ChannelList') || (categoryName==='Leveling' && settingKey==='LevelingChannels')) {
    const toggleKey = categoryName === 'Testing' ? 'testingMode' : (categoryName==='Sniping' ? 'snipeMode' : 'levelingMode');
    const on = toggleKey === 'testingMode' ? !!config.testingMode : (toggleKey==='snipeMode' ? config.snipeMode==='whitelist' : config.levelingMode==='whitelist');
    applyToggleVisual(itemEmbed, { on });
  }

  // Single row with toggles/actions/back
  const row = buildSettingRow(categoryName, settingKey);
  return { embed: itemEmbed, row };
}

module.exports.renderSettingEmbed = renderSettingEmbed;

// Register core toggles (idempotent)
registerToggle({ key: 'testingMode', kind: 'boolean', getter: () => config.testingMode });
registerToggle({ key: 'snipeMode', kind: 'mode', getter: () => config.snipeMode, on: v => v === 'whitelist' });
registerToggle({ key: 'levelingMode', kind: 'mode', getter: () => config.levelingMode, on: v => v === 'whitelist' });

```

===== FILE: commands/diagnostics.js =====
```javascript
const { createEmbed } = require('../utils/embeds');
const { getToggleState } = require('../utils/ui');
const ActiveMenus = require('../utils/activeMenus');
const theme = require('../utils/theme');

function checkEmbedsCapitalization(msg) {
  const issues = [];
  for (const e of msg.embeds||[]) {
    const title = e.title || e.data?.title;
    if (title && title !== title.replace(/\b(\w)/g, (m) => m.toUpperCase())) {
      issues.push(`Title not properly capitalized: "${title}"`);
    }
  }
  return issues;
}

async function handleDiagnosticsCommand(client, message) {
  const sessions = ActiveMenus.snapshotSessions ? ActiveMenus.snapshotSessions() : [];
  let emptyRows = 0;
  for (const s of sessions) {
    for (const row of (s.components||[])) {
      if (row && Array.isArray(row.components) && row.components.length === 0) emptyRows++;
    }
  }
  const toggles = ['testingMode','snipeMode','levelingMode'];
  const toggleStates = toggles.map(k => ({ k, st: getToggleState(k) }));
  const lines = [];
  lines.push(`Active Sessions: ${sessions.length}`);
  lines.push(`Empty Component Rows: ${emptyRows}`);
  for (const t of toggleStates) {
    if (!t.st) continue;
    lines.push(`Toggle ${t.k}: ${t.st.on?'ON':'OFF'} (value=${t.st.value})`);
  }
  const embed = createEmbed({ title: `${theme.emojis.health||'🩺'} Diagnostics`, description: lines.join('\n'), color: emptyRows?theme.colors.danger:theme.colors.success });
  return await message.reply({ embeds:[embed], allowedMentions:{repliedUser:false} });
}

module.exports = { handleDiagnosticsCommand };

```

===== FILE: commands/help.js =====
```javascript
const { EmbedBuilder, ActionRowBuilder, ButtonBuilder, ButtonStyle } = require("discord.js");
const { isModerator } = require("./moderation/index");
const { OWNER_ID } = require("./moderation/permissions");
const ActiveMenus = require("../utils/activeMenus");
const theme = require("../utils/theme");
const { applyStandardFooter, semanticButton } = require("../utils/ui");

// Dynamic help command registry: each command exports a meta.description optionally
const COMMAND_META = [
  { cmd: '.help', cat: 'general', desc: 'Show this menu' },
  { cmd: '.profile', cat: 'general', desc: 'Show your profile' },
  { cmd: '.leaderboard', cat: 'general', desc: 'Show leaderboards' },
  { cmd: '.cash', cat: 'general', desc: 'Wallet balance' },
  { cmd: '.rank / .level', cat: 'level', desc: 'Show rank card' },
  { cmd: '.profile vc', cat: 'level', desc: 'Show VC stats' },
  { cmd: '.balance', cat: 'economy', desc: 'Bank & wallet UI' },
  { cmd: '.deposit <amount>', cat: 'economy', desc: 'Deposit into bank' },
  { cmd: '.withdraw <amount>', cat: 'economy', desc: 'Withdraw from bank' },
  { cmd: '.metrics', cat: 'config', desc: 'Metrics dashboard', ownerOnly: true },
  { cmd: '.config', cat: 'config', desc: 'Configuration menu', ownerOnly: true },
  { cmd: '.test', cat: 'config', desc: 'Owner test utilities', ownerOnly: true },
  { cmd: '.errors', cat: 'config', desc: 'List recent errors', ownerOnly: true },
  { cmd: '.errdetail <index>', cat: 'config', desc: 'Error detail', ownerOnly: true },
  { cmd: '.restart', cat: 'config', desc: 'Restart bot', ownerOnly: true },
  { cmd: '.mute <@user> [time] [reason]', cat: 'moderation', modOnly: true, desc: 'Mute user' },
  { cmd: '.unmute <@user>', cat: 'moderation', modOnly: true, desc: 'Remove mute' },
  { cmd: '.timeout <@user> <time> [reason]', cat: 'moderation', modOnly: true, desc: 'Timeout user' },
  { cmd: '.ban <@user> [reason]', cat: 'moderation', modOnly: true, desc: 'Ban user' },
  { cmd: '.kick <@user> [reason]', cat: 'moderation', modOnly: true, desc: 'Kick user' },
  { cmd: '.warn <@user> <reason>', cat: 'moderation', modOnly: true, desc: 'Warn user' },
  { cmd: '.warnings [@user]', cat: 'moderation', modOnly: true, desc: 'List warnings' },
  { cmd: '.removewarn <@user> <index>', cat: 'moderation', modOnly: true, desc: 'Remove warning' },
  { cmd: '.purge <count> [@user|filters]', cat: 'moderation', modOnly: true, desc: 'Bulk delete' }
];
function buildHelpCategories(member) {
  const cats = {
    general: { id: 'general', label: 'General', emoji: '�', commands: [] },
    level: { id: 'level', label: 'Leveling', emoji: '🧬', commands: [] },
    economy: { id: 'economy', label: 'Economy', emoji: '💰', commands: [] },
    moderation: { id: 'moderation', label: 'Moderation', emoji: '🛡️', modOnly: true, commands: [] },
    config: { id: 'config', label: 'Config', emoji: '🛠️', ownerOnly: true, commands: [] }
  };
  for (const meta of COMMAND_META) {
    if (meta.ownerOnly && String(member.id) !== String(OWNER_ID)) continue;
    if (meta.modOnly && !isModerator(member)) continue;
    if (!cats[meta.cat]) continue;
    cats[meta.cat].commands.push(`${meta.cmd} - ${meta.desc}`);
  }
  return Object.values(cats);
}

function filterCategories(member) { return buildHelpCategories(member); }

function buildCategoryEmbed(guild, member, categories, current) {
  const embed = new EmbedBuilder().setColor(theme.colors.primary || 0x5865F2);
  if (current === 'all') {
    embed.setTitle('Help — All Categories');
    embed.setDescription('Browse all commands. Use the buttons to filter categories.');
    for (const cat of categories) {
      embed.addFields({ name: `${cat.emoji||''} ${cat.label}`, value: cat.commands.map(c=>`• ${c}`).join('\n').slice(0,1024) });
    }
  } else {
    const cat = categories.find(c=>c.id===current) || categories[0];
    embed.setTitle(`Help — ${cat.label}`);
    embed.setDescription('Use buttons below to switch categories or view All.');
    const joined = cat.commands.map(c=>`• ${c}`).join('\n');
    embed.addFields({ name: `${cat.emoji||''} ${cat.label} Commands`, value: joined.slice(0,1024) || '*None*' });
  }
  applyStandardFooter(embed, guild, { testingMode: false });
  return embed;
}

function buildRows(categories, current) {
  // Custom layout for narrower look: first row includes 'All' + up to 2 categories, rest distributed 3 per row.
  const visible = [...categories];
  const rows = [];
  const firstCats = visible.slice(0,2);
  const firstRow = new ActionRowBuilder();
  // All button
  firstRow.addComponents(
    semanticButton('nav', { id: 'helpv2:all', label: 'All', active: current==='all' })
  );
  for (const cat of firstCats) {
    firstRow.addComponents(
      semanticButton('nav', { id: `helpv2:${cat.id}`, label: cat.label, emoji: cat.emoji, active: cat.id===current })
    );
  }
  rows.push(firstRow);
  const remaining = visible.slice(2);
  for (let i=0;i<remaining.length;i+=3) {
    const row = new ActionRowBuilder();
    for (const cat of remaining.slice(i,i+3)) {
      row.addComponents(
        semanticButton('nav', { id: `helpv2:${cat.id}`, label: cat.label, emoji: cat.emoji, active: cat.id===current })
      );
    }
    rows.push(row);
    if (rows.length >= 5) break; // Discord limit
  }
  return rows;
}

async function handleHelpCommand(client, message) {
  const member = message.member; if (!member) return;
  const cats = filterCategories(member);
  const current = cats[0]?.id || 'general';
  const embed = buildCategoryEmbed(message.guild, member, cats, current);
  const rows = buildRows(cats, current);
    return await message.reply({ embeds: [embed], components: rows, allowedMentions:{repliedUser:false} });
  if (!msg) return;
  ActiveMenus.registerMessage(msg, { type: 'helpv2', userId: message.author.id, data: { current } });
}

ActiveMenus.registerHandler('helpv2', async (interaction, session) => {
  if (!interaction.isButton()) return;
  if (interaction.user.id !== session.userId) {
  return interaction.reply({ content: 'Not your session.', flags: 1<<6 }).catch(()=>{});
  }
  const member = interaction.guild?.members?.cache?.get(interaction.user.id) || interaction.member;
  const cats = filterCategories(member);
  const id = interaction.customId;
  let current = session.data.current;
  if (id === 'helpv2:all') current = 'all';
  else if (id.startsWith('helpv2:')) current = id.split(':')[1];
  const embed = buildCategoryEmbed(interaction.guild, member, cats, current);
  const rows = buildRows(cats, current);
  session.data.current = current;
  try { await interaction.update({ embeds:[embed], components: rows }); } catch {}
});

module.exports = { handleHelpCommand };

```

===== FILE: commands/leaderboard.js =====
```javascript
const ActiveMenus = require("../utils/activeMenus");
// Use cached leaderboard service for efficiency
const { buildLeaderboardEmbed: cachedLBEmbed } = require('../services/leaderboardService');
// Reuse profile navigation system so .lb has Profile / Rank / Leaderboard buttons
const { buildRows } = require("./profile");

async function handleLeaderboardCommand(client, message) {
  const guild = message.guild;
  if (!guild) return;
  const member = message.member;
  if (!member) return;
  const mode = "text"; // initial mode
  const page = 1;
  const embed = cachedLBEmbed(guild, member.id, page, 10, mode);
  // total pages derived by service entries length (recompute locally via getEntries if needed)
  const { getEntries } = require('../services/leaderboardService');
  const totalPages = Math.max(1, Math.ceil(getEntries(mode).length / 10));
  // Use profile buildRows so nav includes Profile / Rank / Leaderboard
  const rows = buildRows("leaderboard", page, totalPages, mode);
  const sent = await message.reply({ embeds: [embed], components: rows, allowedMentions: { repliedUser: false } }).catch(() => null);
  if (sent) {
    // Register as a profile session so existing handler manages navigation & pagination
    ActiveMenus.registerMessage(sent, { type: "profile", userId: member.id, data: { view: "leaderboard", page, mode } });
  }
}
module.exports = { handleLeaderboardCommand };

```

===== FILE: commands/level.js =====
```javascript
const { getXP, getLevel } = require("../utils/levels");
const ActiveMenus = require("../utils/activeMenus");
const { buildRows, buildRankEmbed } = require("./profile");
const { EmbedBuilder } = require("discord.js");
const { buildLeaderboardEmbed } = require("./profile"); // type-only context
const { levels: levelsObj } = require("../utils/levels");
const { buildLeaderboardEmbed: _ignore, buildRows: _ignore2 } = require("./profile");
const { progressBar: sharedProgressBar } = require("../utils/ui");
const theme = require("../utils/theme");
const { config } = require("../utils/storage");

function getLevelXP(level) {
  const BASE_XP = 150; // keep in sync with utils/levels addXP
  return Math.floor(BASE_XP * Math.pow(level, 1 / 0.7));
}

function createProgressBar(current, max, size = 20) {
  return sharedProgressBar(current, max, size, { showNumbers: true, allowOverflow: false });
}

async function handleLevelCommand(client, message) {
  const userId = message.author.id;
  const xp = getXP(userId);
  const level = getLevel(userId);
  const nextLevel = level + 1;
  const xpForNextLevel = getLevelXP(nextLevel);
  const xpForCurrentLevel = getLevelXP(level);
  const xpIntoLevel = Math.max(0, xp - xpForCurrentLevel);
  const xpNeeded = Math.max(1, xpForNextLevel - xpForCurrentLevel);

  const progressBar = createProgressBar(xpIntoLevel, xpNeeded, 24);
  // Determine rank from levels
  const rank = (() => {
    const entries = Object.entries(levelsObj || {}).map(([uid, data]) => ({ uid, lvl: data?.level || 0, xp: data?.xp || 0 }));
    entries.sort((a,b) => (b.lvl - a.lvl) || (b.xp - a.xp));
    const i = entries.findIndex(e => e.uid === userId);
    return i === -1 ? null : i + 1;
  })();

  let embed;
  if (buildRankEmbed) {
    embed = buildRankEmbed(message.member, rank, level, progressBar, "text");
  } else {
    embed = new EmbedBuilder()
      .setTitle(`${theme.emojis.rank} Your Rank`)
      .setColor(theme.colors.primary)
      .addFields(
        { name: "Level", value: `Lv. ${level}` , inline: true },
        { name: "Rank", value: rank ? `#${rank}` : "—", inline: true },
        { name: "Progress", value: progressBar, inline: false }
      )
      .setTimestamp();
  }

  const rows = buildRows("rank", 1, 1, "text");
  const sent = await message.reply({ embeds: [embed], components: rows }).catch(() => null);
  if (sent) {
    ActiveMenus.registerMessage(sent, { type: "profile", userId: message.author.id, data: { view: "rank", mode: "text" } });
  }
}

module.exports = { handleLevelCommand };
```

===== FILE: commands/metrics.js =====
```javascript
const { createEmbed } = require('../utils/embeds');
const theme = require('../utils/theme');
const { getMetrics } = require('../services/metricsService');

async function handleMetricsCommand(client, message) {
  const m = getMetrics();
  const lines = [
    `Commands: **${m.commands}**`,
    `Interactions: **${m.interactions}**`,
    `Errors: **${m.errors}**`,
    `Last Command: ${m.lastCommandAt ? `<t:${Math.floor(m.lastCommandAt/1000)}:R>` : 'Never'}`
  ];
  const embed = createEmbed({
    title: `${theme.emojis.counter || '🧮'} Metrics`,
    description: lines.join('\n'),
    color: theme.colors.primary
  });
  try { return await message.reply({ embeds: [embed], allowedMentions: { repliedUser: false } }); } catch {}
}
module.exports = { handleMetricsCommand };
```

===== FILE: commands/moderation/dm.js =====
```javascript
const { EmbedBuilder } = require("discord.js");
const theme = require("../../utils/theme");
const { applyStandardFooter } = require("../../utils/ui");

async function sendUserDM(target, action, duration = null, reason = null, extra = null) {
  let description;
  let color;
  const a = String(action || "");
  const al = a.toLowerCase();
  switch (al) {
    case "warned":
      description = `${theme.emojis.warn} You have been warned in **Late Night Hours**.`;
      color = theme.colors.warning;
      break;
    default:
      if (al.startsWith("warning removed")) {
        // Parse optional count from patterns like "warning removed x3"
        const m = al.match(/x(\d+)/);
        const count = Math.max(1, m ? parseInt(m[1], 10) || 1 : 1);
        const plural = count === 1 ? "warning has" : "warnings have";
  description = `${theme.emojis.success} ${count} ${plural} been removed from your account in **Late Night Hours**.`;
  color = theme.colors.success;
      } else if (al === "kicked") {
  description = "👢 You have been **kicked** from **Late Night Hours**.";
  color = theme.colors.danger;
      } else if (al === "banned") {
  description = "🔨 You have been **banned** from **Late Night Hours**.";
  color = theme.colors.danger;
      } else if (al === "muted") {
  description = "🔇 You have been **muted** in **Late Night Hours**.";
  color = theme.colors.danger;
      } else if (al === "unmuted") {
        description = `${theme.emojis.unmute || "🔊"} You have been **unmuted** in **Late Night Hours**.`;
        color = theme.colors.success;
      } else {
        description = `${theme.emojis.info} You have been **${a}** in **Late Night Hours**.`;
        color = theme.colors.primary;
      }
      break;
  }

  const user = target?.user || target; // support GuildMember or User
  const avatar = user?.displayAvatarURL ? user.displayAvatarURL({ dynamic: true }) : undefined;
  const embed = new EmbedBuilder()
    .setAuthor({ name: user?.tag || user?.username || "User", iconURL: avatar })
    .setColor(color)
    .setDescription(description);

  // For removal DMs, omit the Reason field entirely to reduce noise
  if (!al.startsWith("warning removed") && reason) embed.addFields({ name: "📝 Reason", value: reason, inline: true });
  if (duration) embed.addFields({ name: `${theme.emojis.duration} Duration`, value: duration, inline: true });
  if (extra) embed.addFields({ name: "ℹ️ Info", value: extra, inline: false });
  embed.setTimestamp();

  try {
    if (typeof target.send === "function") {
      await target.send({ embeds: [embed] });
    } else if (typeof user?.send === "function") {
      await user.send({ embeds: [embed] });
    }
  } catch (err) {
    const tag = user?.tag || user?.username || user?.id || "unknown";
    console.error(`[DM Error] Could not DM ${tag}:`, err);
  }
}

module.exports = {
  sendUserDM
};
```

===== FILE: commands/moderation/index.js =====
```javascript
const { isModerator, OWNER_ID } = require("./permissions");
const { replySuccess, replyError } = require("./replies");
const { sendUserDM } = require("./dm");
const { showWarnings, handleWarningButtons, cleanWarnings } = require("./warnings");
const { handleModerationCommands } = require("./moderationCommands");

module.exports = {
  isModerator,
  OWNER_ID,
  replySuccess,
  replyError,
  sendUserDM,
  showWarnings,
  handleWarningButtons,
  cleanWarnings,
  handleModerationCommands
};
```

===== FILE: commands/moderation/moderationCommands.js =====
```javascript
const { sendModLog } = require("../../utils/modLogs");
const { replySuccess, replyError } = require("./replies");
const { sendUserDM } = require("./dm");
const { isModerator, OWNER_ID } = require("./permissions");
const { config, saveConfig } = require("../../utils/storage");
const ms = require("ms");
const { parseDurationAndReason } = require("../../utils/time");

const MUTE_ROLE_ID = "1391535514901020744";
const DEFAULT_MUTE = config.defaultMuteDuration || 60 * 60 * 1000;

function formatDuration(duration) {
  return ms(duration, { long: true });
}

// --- Warnings store helpers (testing-mode aware) ---
function ensureStores() {
  if (typeof config.warnings !== "object" || !config.warnings) config.warnings = {};
  if (typeof config.testingWarnings !== "object" || !config.testingWarnings) config.testingWarnings = {};
}
function getStore() {
  return config.testingMode ? config.testingWarnings : config.warnings;
}
function getUserWarnings(userId) {
  ensureStores();
  const store = getStore();
  return Array.isArray(store[userId]) ? store[userId] : [];
}
function setUserWarnings(userId, arr) {
  ensureStores();
  const store = getStore();
  store[userId] = Array.isArray(arr) ? arr : [];
  saveConfig();
}
function getThresholds() {
  const esc = config.escalation || {};
  const muteT = Math.max(1, Number(esc.muteThreshold || 3));
  const kickT = Math.max(muteT + 1, Number(esc.kickThreshold || 5));
  return { muteT, kickT, muteDurationMs: Number.isFinite(esc.muteDuration) ? esc.muteDuration : 2 * 60 * 60 * 1000 };
}

async function findTarget(message, args) {
  let target = null;
  let reasonArgs = args;

  if (message.mentions.members.size > 0) {
    target = message.mentions.members.first();
    reasonArgs = args.slice(1);
  } else if (args[0]) {
    target = await message.guild.members.fetch(args[0]).catch(() => null);
    if (target) reasonArgs = args.slice(1);
  }
  if (!target && args[0]) {
    const search = args[0].toLowerCase();
    target = message.guild.members.cache.find(
      m =>
        m.user.username.toLowerCase() === search ||
        (m.nickname && m.nickname.toLowerCase() === search)
    );
    if (target) reasonArgs = args.slice(1);
  }

  let user = null;
  if (!target && args[0]) {
    user = await message.client.users.fetch(args[0]).catch(() => null);
    if (user) reasonArgs = args.slice(1);
  }

  return { target, user, reasonArgs };
}

async function tryTimeoutOrRoleMute(member, durationMs, reason) {
  // Prefer Discord timeout
  if (member && typeof member.timeout === "function") {
    try {
      await member.timeout(Math.min(durationMs, 14 * 24 * 60 * 60 * 1000), reason || "Muted");
      return true;
    } catch {}
  }
  // Fallback to mute role if present
  try {
    if (MUTE_ROLE_ID && member.guild.roles.cache.has(MUTE_ROLE_ID)) {
      if (!member.roles.cache.has(MUTE_ROLE_ID)) {
        await member.roles.add(MUTE_ROLE_ID, reason || "Muted");
      }
      return true;
    }
  } catch {}
  return false;
}

async function clearTimeoutAndRole(member, reason) {
  try { if (typeof member.timeout === "function") await member.timeout(null, reason || "Unmuted"); } catch {}
  try { if (MUTE_ROLE_ID && member.roles.cache.has(MUTE_ROLE_ID)) await member.roles.remove(MUTE_ROLE_ID, reason || "Unmuted"); } catch {}
}

async function handleModerationCommands(client, message, command, args) {
  if (!isModerator(message.member)) return replyError(message, "You are not allowed to use this command.");

  const { target, user, reasonArgs } = await findTarget(message, args);
  if (!target && !user) return replyError(message, "You must mention a user, provide a valid user ID, or type their username/nickname.");

  const member = target;
  const userObj = member ? member.user : user;

  const isTesting = !!config.testingMode;
  const escalation = config.escalation || {};
  // Enforce requested thresholds (mute=3, kick=5) with config override if provided
  const muteThreshold = Math.max(3, Number.isFinite(escalation.muteThreshold) ? escalation.muteThreshold : 3);
  const kickThreshold = Math.max(5, Number.isFinite(escalation.kickThreshold) ? escalation.kickThreshold : 5);
  const muteDurationMs = Number.isFinite(escalation.muteDuration) ? escalation.muteDuration : 2 * 60 * 60 * 1000;

  // Restriction checks (skip in testing to avoid noise)
  if (!isTesting) {
    if (member) {
      if (member.id === message.author.id) return replyError(message, "You cannot moderate yourself.");
      if (member.id === OWNER_ID) return replyError(message, "You cannot moderate the owner.");
      if (member.roles.highest.comparePositionTo(message.member.roles.highest) >= 0 && message.author.id !== OWNER_ID)
        return replyError(message, "You cannot moderate this user due to role hierarchy.");
      if ((config.moderatorRoles || []).some(r => member.roles.cache.has(r))) {
        return replyError(message, "Cannot moderate this user (they are a configured moderator).");
      }
    } else {
      if (userObj.id === message.author.id) return replyError(message, "You cannot moderate yourself.");
      if (userObj.id === OWNER_ID) return replyError(message, "You cannot moderate the owner.");
    }
  }

  // Parse duration and reason after target
  const argOffset = message.mentions.members.size > 0 ? 1 : (args[0] && /^\d{5,}$/.test(args[0]) ? 1 : 0);
  const { duration, reason } = parseDurationAndReason(args.slice(argOffset));
  const finalDuration = duration || DEFAULT_MUTE;
  const finalReason = reason || "No reason provided";

  try {
    switch (command) {
      case "mute": {
        if (!member) return replyError(message, "User is not in this server.");
        if (!isTesting) {
          const ok = await tryTimeoutOrRoleMute(member, finalDuration, `${finalReason} • by ${message.author.tag}`);
          if (!ok) return replyError(message, "Failed to mute this user. Do I have permissions?");
        }
        await sendUserDM(member, "muted", formatDuration(finalDuration), finalReason);
        await sendModLog(client, member, message.author, "muted", finalReason, true, formatDuration(finalDuration), null);
        await replySuccess(message, `Muted ${member} for ${formatDuration(finalDuration)}${isTesting ? " (testing mode, not applied)" : ""}`);
        return;
      }

      case "unmute": {
        if (!member) return replyError(message, "User is not in this server.");
        if (!isTesting) await clearTimeoutAndRole(member, `Unmuted by ${message.author.tag}`);
        await sendUserDM(member, "unmuted");
        await sendModLog(client, member, message.author, "unmuted", null, false, null, null);
        await replySuccess(message, `Unmuted ${member}`);
        return;
      }

      case "warn": {
        const warnId = userObj.id;
        const warnings = getUserWarnings(warnId);
        const entry = { moderator: message.author.id, reason: finalReason, date: Date.now(), logMsgId: null };
        warnings.push(entry);
        setUserWarnings(warnId, warnings);

        const newCount = warnings.length;

        // Determine escalation (single combined flow; no public escalation message)
        let escalationNote = null;
        let escalationDurationText = null;

        const { muteT, kickT, muteDurationMs: mMs } = getThresholds();
        if (newCount >= kickT) {
          escalationNote = `Due to reaching ${newCount} warnings, you have been kicked.`;
          if (!isTesting && member && member.kickable) {
            try { await member.kick(finalReason); } catch {}
          }
          // Single DM covering warn + punishment
          await sendUserDM(member || userObj, "warned", null, finalReason, `Due to reaching ${newCount} warnings, you have been kicked.`);
        } else if (newCount >= muteT) {
          escalationNote = `Due to reaching ${newCount} warnings, you have been muted.`;
          escalationDurationText = formatDuration(mMs);
          if (!isTesting && member) {
            await tryTimeoutOrRoleMute(member, mMs, `${finalReason} • Auto-mute`);
          }
          await sendUserDM(member || userObj, "warned", escalationDurationText, finalReason, `Due to reaching ${newCount} warnings, you have been muted.`);
        }

        const remainingToMute = Math.max(0, muteT - newCount);
        const remainingToKick = Math.max(0, kickT - newCount);
  // Dynamic next punishment
  let remainingLine = null;
  if (newCount < muteT) remainingLine = `${muteT - newCount} warning${muteT - newCount === 1 ? "" : "s"} remaining until mute`;
  else if (newCount < kickT) remainingLine = `${kickT - newCount} warning${kickT - newCount === 1 ? "" : "s"} remaining until kick`;

        await sendUserDM(
          member || userObj,
          "warned",
          escalationDurationText,
          finalReason,
          `${remainingLine ? remainingLine + "\n" : ""}${escalationNote ? escalationNote : ""}`.trim()
        );

  // Build log reason without an explicit "warnings remaining" line; modLogs will place remaining in footer when applicable
  const combinedReason = `${finalReason}${escalationNote ? `\n\n${escalationNote}` : ""}`;
  const nxtRemain = remainingLine ? parseInt((remainingLine.match(/^(\d+)/) || [0,0])[1], 10) || 0 : 0;
        const logMsg = await sendModLog(
          client,
          member || userObj,
          message.author,
          "warned",
          combinedReason,
          true,
          escalationDurationText,
          nxtRemain
        );
        if (logMsg) {
          entry.logMsgId = logMsg.id;
          saveConfig();
        }

  await replySuccess(message, `Warned <@${warnId}> for: **${finalReason}**${remainingLine ? `\n${remainingLine}` : ""}`);
        return;
      }

      case "removewarn": {
        const warnId = userObj.id;
        const warnings = getUserWarnings(warnId);
        if (!Array.isArray(warnings) || warnings.length === 0) {
          return replyError(message, "This user has no warnings.");
        }
        let index = parseInt(reasonArgs[0], 10);
        if (isNaN(index) || index < 1 || index > warnings.length) {
          index = warnings.length; // default last
        }
        const removed = warnings.splice(index - 1, 1)[0];
        setUserWarnings(warnId, warnings);

    const count = warnings.length;
    const { muteT, kickT } = getThresholds();
    let remainingLine2 = null;
    if (count < muteT) remainingLine2 = `${muteT - count} warning${muteT - count === 1 ? "" : "s"} remaining until mute`;
    else if (count < kickT) remainingLine2 = `${kickT - count} warning${kickT - count === 1 ? "" : "s"} remaining until kick`;

    const nxtRemain2 = remainingLine2 ? parseInt((remainingLine2.match(/^(\d+)/) || [0,0])[1], 10) || 0 : 0;
  await sendUserDM(member || userObj, "warning removed", null, null, null);
  // Include remaining line in reason so the logger can move it to the footer
  const reasonForLog = remainingLine2 ? `${removed?.reason || "No reason"}\n\n${remainingLine2}` : `${removed?.reason || "No reason"}`;
  await sendModLog(client, member || userObj, message.author, "warning removed", reasonForLog, true, null, nxtRemain2);
        await replySuccess(message, `Removed warning #${index} from <@${warnId}>${removed?.reason ? `: **${removed.reason}**` : ""}`);
        return;
      }

      case "kick": {
        if (!member) return replyError(message, "User is not in this server.");
        if (!isTesting && !member.kickable) return replyError(message, "I cannot kick this user.");
        if (!isTesting) {
          try { await member.kick(finalReason); } catch { return replyError(message, "Failed to kick this user."); }
        }
        await sendUserDM(member, "kicked", null, finalReason);
        await sendModLog(client, member, message.author, "kicked", finalReason, true, null, null);
        await replySuccess(message, `Kicked ${member}${isTesting ? " (testing mode, not actually kicked)" : ""}`);
        return;
      }

      case "ban": {
        if (!member) return replyError(message, "User is not in this server.");
        if (!isTesting && !member.bannable) return replyError(message, "I cannot ban this user.");
        if (!isTesting) {
          try { await member.ban({ reason: finalReason }); } catch { return replyError(message, "Failed to ban this user."); }
        }
        await sendUserDM(member, "banned", null, finalReason);
        await sendModLog(client, member, message.author, "banned", finalReason, true, null, null);
        await replySuccess(message, `Banned ${member}${isTesting ? " (testing mode, not actually banned)" : ""}`);
        return;
      }

      default:
        return replyError(message, "Unknown moderation command.");
    }
  } catch (err) {
    console.error(`[Moderation Command Error] ${command}:`, err);
    await replyError(message, `An error occurred while executing \`${command}\`.\nDetails: \`${err.message || err}\``);
  }
}

module.exports = {
  handleModerationCommands
};
```

===== FILE: commands/moderation/permissions.js =====
```javascript
const { config } = require("../../utils/storage");
const { getCached, setCached } = require('../../utils/permissionsCache');
const { PermissionFlagsBits } = require("discord.js");

const OWNER_ID = process.env.OWNER_ID || "349282473085239298";

// Staff roles
const STAFF_MANAGER_ROLE = "1380277718091829368";
const STAFF_SECURITY_ROLE = "1380323145621180466";
const STAFF_MODERATOR_ROLE = "1375958589658632313";
const STAFF_STAFF_ROLE = "1375958480380493844";
const STAFF_ADMIN_ROLE = "1381077407074750594";

const ALLOWED_ROLES = [
  STAFF_MANAGER_ROLE,
  STAFF_SECURITY_ROLE,
  STAFF_MODERATOR_ROLE,
  STAFF_STAFF_ROLE,
  STAFF_ADMIN_ROLE
];

const CHATBOX_BUTTON_ID = "staffteam_chatbox";

function isModerator(member) {
  if (!member) return false;
  const cached = getCached(member.guild?.id || 'global', member.id);
  if (cached !== null) return cached;
  if (String(member.id) === String(OWNER_ID)) { setCached(member.guild?.id || 'global', member.id, true); return true; }

  const roleCache = member.roles?.cache || new Map();
  const hasRole = (rid) => roleCache.has(rid);
  const configured = Array.isArray(config.moderatorRoles) ? config.moderatorRoles : [];
  if (configured.some(hasRole)) { setCached(member.guild?.id || 'global', member.id, true); return true; }
  if (ALLOWED_ROLES.some(hasRole)) { setCached(member.guild?.id || 'global', member.id, true); return true; }

  if (member.permissions && typeof member.permissions.has === "function") {
    if (member.permissions.has(PermissionFlagsBits.Administrator) || member.permissions.has(PermissionFlagsBits.ModerateMembers)) {
      setCached(member.guild?.id || 'global', member.id, true);
      return true;
    }
  }
  setCached(member.guild?.id || 'global', member.id, false);
  return false;
}

module.exports = {
  OWNER_ID,
  STAFF_MANAGER_ROLE,
  STAFF_SECURITY_ROLE,
  STAFF_MODERATOR_ROLE,
  STAFF_STAFF_ROLE,
  STAFF_ADMIN_ROLE,
  ALLOWED_ROLES,
  CHATBOX_BUTTON_ID,
  isModerator
};
```

===== FILE: commands/moderation/purge.js =====
```javascript
const { isModerator } = require('./permissions');
const { config } = require('../../utils/storage');
const { createEmbed, safeAddField } = require('../../utils/embeds');
const { sendModLog } = require('../../utils/modLogs');

// Defaults
const DEFAULT_MAX = 200; // hard ceiling even if config sets higher

function getLimits() {
  const max = Math.min(DEFAULT_MAX, Math.max(1, Number(config.maxPurgeLimit || 100)));
  return { max };
}

function isBlacklisted(channelId) {
  const list = Array.isArray(config.blacklistedChannels) ? config.blacklistedChannels : [];
  return list.includes(channelId);
}

function parseArgs(message, args) {
  // Syntax examples:
  // .purge 25
  // .purge 50 @User
  // .purge @User 30
  // .purge 30 user:123456789012345678
  let count = null;
  let userFilter = null;
  for (const a of args) {
    if (/^<@!?\d+>$/.test(a) && !userFilter) {
      userFilter = a.replace(/\D/g, '');
      continue;
    }
    if (/^user:\d+$/.test(a) && !userFilter) {
      userFilter = a.split(':')[1];
      continue;
    }
    if (/^\d+$/.test(a) && !count) {
      count = parseInt(a, 10);
      continue;
    }
  }
  // Extra filters: bots, images, contains:<text>
  let contains = null; let bots = false; let images = false;
  for (const a of args) {
    if (/^bots$/i.test(a)) bots = true;
    else if (/^images?$/i.test(a)) images = true;
    else if (/^contains:/i.test(a)) contains = a.slice(9).replace(/^"|"$/g,'');
  }
  return { count, userFilter, contains, bots, images };
}

async function handlePurgeCommand(client, message, args) {
  if (!isModerator(message.member)) {
    return message.reply({ content: '❌ You lack permission to use this command.', allowedMentions: { repliedUser: false } });
  }
  if (isBlacklisted(message.channelId)) {
    return message.reply({ content: '❌ This channel is blacklisted for purge operations.', allowedMentions: { repliedUser: false } });
  }

  const { count, userFilter, contains, bots, images } = parseArgs(message, args);
  if (!count || count <= 0) {
    return message.reply({ content: 'Usage: `.purge <amount 1-100> [@user]`', allowedMentions: { repliedUser: false } });
  }
  const { max } = getLimits();
  if (count > max) {
    return message.reply({ content: `❌ Amount too large. Max allowed: ${max}.`, allowedMentions: { repliedUser: false } });
  }

  // For large purges (>= 50) require confirmation via button
  const needsConfirm = count >= Math.min(max, 50);
  if (needsConfirm) {
    const { ActionRowBuilder, ButtonBuilder, ButtonStyle } = require('discord.js');
    const row = new ActionRowBuilder().addComponents(
      new ButtonBuilder().setCustomId('purge_confirm').setLabel(`Confirm ${count}`).setStyle(ButtonStyle.Danger),
      new ButtonBuilder().setCustomId('purge_cancel').setLabel('Cancel').setStyle(ButtonStyle.Secondary)
    );
    const embed = createEmbed({
      title: '⚠️ Confirm Purge',
      description: `This will delete up to **${count}** recent message(s)${userFilter ? ` from <@${userFilter}>` : ''}${contains?` containing "${contains}"`:''}${bots?` (bots only)`:''}${images?` (with images)`:''}. This action cannot be undone.`,
      color: 'warning'
    });
    const sent = await message.reply({ embeds: [embed], components: [row], allowedMentions: { repliedUser: false } });
    const ActiveMenus = require('../../utils/activeMenus');
    ActiveMenus.registerMessage(sent, { type: 'purgeConfirm', userId: message.author.id, data: { count, userFilter, contains, bots, images } });
    return;
  }

  return executePurge(client, message, count, userFilter, { contains, bots, images });
}

async function executePurge(client, message, count, userFilter, filters={}) {
  try {
    // Fetch up to count * 2 to allow filtering by user without extra roundtrips
    const fetchLimit = Math.min(100, Math.max(count, Math.min(count * 2, 100)));
    const messages = await message.channel.messages.fetch({ limit: fetchLimit });
    let filtered = messages;
    if (userFilter) filtered = filtered.filter(m => m.author && m.author.id === userFilter);
    if (filters.bots) filtered = filtered.filter(m => m.author?.bot);
    if (filters.images) filtered = filtered.filter(m => m.attachments?.size > 0);
    if (filters.contains) {
      const needle = filters.contains.toLowerCase();
      filtered = filtered.filter(m => (m.content||'').toLowerCase().includes(needle));
    }
    const toDelete = filtered.filter(m => (Date.now() - m.createdTimestamp) < 14 * 24 * 60 * 60 * 1000).first(count);
    if (!toDelete || toDelete.length === 0) {
      return message.reply({ content: 'Nothing to delete (messages may be too old or no matches).', allowedMentions: { repliedUser: false } });
    }
    let deletedCount = 0;
    if (toDelete.length === 1) {
      try { await toDelete[0].delete().catch(()=>{}); deletedCount = 1; } catch {}
    } else {
      // Bulk delete requires collection of message IDs
      const collection = toDelete;
      try {
        const res = await message.channel.bulkDelete(collection, true).catch(()=>null);
        deletedCount = res ? res.size : toDelete.length; // fallback
      } catch (e) {
        // Fallback to sequential if bulk fails
        for (const m of collection) {
          try { await m.delete().catch(()=>{}); deletedCount++; } catch {}
        }
      }
    }
    // Log action
    try {
  const filterParts = [];
  if (userFilter) filterParts.push(`user=<@${userFilter}>`);
  if (filters.contains) filterParts.push(`contains="${filters.contains}"`);
  if (filters.bots) filterParts.push('bots');
  if (filters.images) filterParts.push('images');
  const filterStr = filterParts.length ? ` filters: ${filterParts.join(', ')}` : '';
  await sendModLog(client, message.member || message.author, message.author, 'purged', `${deletedCount} message(s)${filterStr}`, true, null, null);
    } catch {}

    const resultEmbed = createEmbed({
      title: '🧹 Purge Complete',
      description: `Deleted **${deletedCount}** message(s)${userFilter ? ` from <@${userFilter}>` : ''}${filters.contains?` containing "${filters.contains}"`:''}${filters.bots?` (bots only)`:''}${filters.images?` (with images)`:''}.`,
      color: 'success'
    });
    try { await message.reply({ embeds: [resultEmbed], allowedMentions: { repliedUser: false } }); } catch {}
  } catch (err) {
    console.error('[purge] error', err);
    try { await message.reply({ content: `Error during purge: ${err.message || err}`, allowedMentions: { repliedUser: false } }); } catch {}
  }
}

module.exports = { handlePurgeCommand, executePurge };
```

===== FILE: commands/moderation/replies.js =====
```javascript
const { Message, BaseInteraction } = require("discord.js");
const theme = require("../../utils/theme");

// Centralize via theme; retain exported constants for downstream compatibility
const EMOJI_SUCCESS = theme.emojis.success;
const EMOJI_ERROR = theme.emojis.error || "❌";

function replySuccess(target, text) {
  if (target instanceof Message || target instanceof BaseInteraction) {
    return target.reply(`${EMOJI_SUCCESS} ${text}`);
  }
  return `${EMOJI_SUCCESS} ${text}`;
}

function replyError(target, text) {
  if (target instanceof Message || target instanceof BaseInteraction) {
    return target.reply(`${EMOJI_ERROR} ${text}`);
  }
  return `${EMOJI_ERROR} ${text}`;
}

module.exports = { replySuccess, replyError, EMOJI_SUCCESS, EMOJI_ERROR };
```

===== FILE: commands/moderation/warnings.js =====
```javascript
const { EmbedBuilder, ActionRowBuilder, ButtonBuilder, ButtonStyle, ModalBuilder, TextInputBuilder, TextInputStyle, StringSelectMenuBuilder } = require("discord.js");
const { replyError, EMOJI_SUCCESS } = require("./replies");
const { sendUserDM } = require("./dm");
const { sendModLog } = require("../../utils/modLogs");
const { isModerator } = require("./permissions");
const { config, saveConfig } = require("../../utils/storage");
const theme = require("../../utils/theme");
const { applyFooterWithPagination, paginationRow } = require("../../utils/ui");

const PAGE_SIZE = 10; // users per page in dashboard
const MAX_WARNING_LIST = 6; // entries shown inline in user view

function ensureWarningsMap() {
  if (typeof config.warnings !== "object" || !config.warnings) config.warnings = {};
  if (typeof config.testingWarnings !== "object" || !config.testingWarnings) config.testingWarnings = {};
  if (typeof config.testingSeed !== "object" || !config.testingSeed) config.testingSeed = {};
}

function getStoreKey() {
  return config.testingMode ? "testingWarnings" : "warnings";
}

function getUserWarnings(userId) {
  ensureWarningsMap();
  const key = getStoreKey();
  const store = config[key];
  return Array.isArray(store[userId]) ? store[userId] : [];
}

function setUserWarnings(userId, arr) {
  ensureWarningsMap();
  const key = getStoreKey();
  const store = config[key];
  store[userId] = Array.isArray(arr) ? arr : [];
  saveConfig();
}

function getThresholds() {
  const esc = config.escalation || {};
  const muteT = Math.max(3, Number(esc.muteThreshold || 3));
  const kickT = Math.max(5, Number(esc.kickThreshold || 5));
  return { muteT, kickT };
}

// Determine next punishment label and how many warnings remain to reach it
function getNextPunishmentInfo(total) {
  const { muteT, kickT } = getThresholds();
  if (total < muteT) return { label: "mute", remaining: Math.max(0, muteT - total) };
  if (total < kickT) return { label: "kick", remaining: Math.max(0, kickT - total) };
  return null;
}

// Seed random warnings for testing mode display; persists until explicit edits occur
function maybeSeedTestingData(guild) {
  if (!config.testingMode) return;
  ensureWarningsMap();
  const seed = config.testingSeed || {};
  const hasAny = Object.values(seed).some(arr => Array.isArray(arr) && arr.length);
  if (hasAny) return;

  const members = [...guild.members.cache.values()].filter(m => !m.user.bot);
  const totalPick = Math.min(50, members.length);
  // Sample unique members up to totalPick
  const pool = members.map(m => m.id);
  const chosen = new Set();
  while (chosen.size < totalPick && chosen.size < pool.length) {
    const id = pool[Math.floor(Math.random() * pool.length)];
    chosen.add(id);
  }
  for (const id of chosen) {
    const warns = [];
    const n = 1 + Math.floor(Math.random() * 4);
    for (let j = 0; j < n; j++) {
      warns.push({
        moderator: id,
        reason: ["Spam", "Off-topic", "Rude language", "NSFW", "Disrespect"][Math.floor(Math.random() * 5)],
        date: Date.now() - Math.floor(Math.random() * 7 * 24 * 60 * 60 * 1000)
      });
    }
    seed[id] = warns;
  }
  config.testingSeed = seed;
  saveConfig();
}

// Visible warnings in UI: in testing mode prefer explicit testingWarnings, else seeded; otherwise real store
function getVisibleWarnings(userId) {
  ensureWarningsMap();
  if (config.testingMode) {
    const real = config.testingWarnings[userId];
    if (Array.isArray(real) && real.length) return real;
    const seeded = config.testingSeed[userId];
    if (Array.isArray(seeded) && seeded.length) return seeded;
    return [];
  }
  return getUserWarnings(userId);
}

function memberLabel(guild, userId) {
  const member = guild.members.cache.get(userId);
  if (member) return member.displayName || member.user.username || userId;
  const user = guild.client.users.cache.get(userId);
  return user?.username || userId;
}

function formatWarnLine(guild, entry, idx) {
  const ordinal = (n) => {
    const s = ["th", "st", "nd", "rd"], v = n % 100; return n + (s[(v - 20) % 10] || s[v] || s[0]);
  };
  const by = entry.moderator ? `<@${entry.moderator}>` : "Unknown";
  const when = entry.date ? `<t:${Math.floor(entry.date / 1000)}:R>` : "Unknown";
  const reason = (entry.reason || "No reason").slice(0, 140);
  const label = `${ordinal(idx)} Warning`;
  const gId = guild?.id;
  const chId = entry.logChannelId || null;
  const msgId = entry.logMsgId || null;
  const link = (gId && chId && msgId) ? `https://discord.com/channels/${gId}/${chId}/${msgId}` : null;
  const title = link ? `[${label}](${link})` : label;
  return `${title} • by ${by} • ${when}\n${reason}`;
}

function buildDashboardEmbed(guild, page) {
  ensureWarningsMap();
  maybeSeedTestingData(guild);
  const usersSet = new Set();
  if (config.testingMode) {
    Object.keys(config.testingSeed || {}).forEach(k => usersSet.add(k));
    Object.keys(config.testingWarnings || {}).forEach(k => usersSet.add(k));
  } else {
    Object.keys(config.warnings || {}).forEach(k => usersSet.add(k));
  }
  const all = [...usersSet].map(userId => ({ userId, count: getVisibleWarnings(userId).length }))
    .filter(x => x.count > 0)
    .sort((a, b) => b.count - a.count || a.userId.localeCompare(b.userId));

  const totalPages = Math.max(1, Math.ceil(all.length / PAGE_SIZE));
  const curPage = Math.min(Math.max(1, page || 1), totalPages);
  const slice = all.slice((curPage - 1) * PAGE_SIZE, curPage * PAGE_SIZE);

  const lines = slice.length
    ? slice.map((x, i) => {
        const idx = (i + 1) + (curPage - 1) * PAGE_SIZE;
        // Use mentions for uniformity with the rest; allowedMentions are disabled when replying
        return `${idx}. <@${x.userId}> • ${x.count} warning${x.count === 1 ? "" : "s"}`;
      }).join("\n")
    : "No users currently have warnings.";

  const { muteT, kickT } = getThresholds();
  const embed = new EmbedBuilder()
    .setTitle(`${theme.emojis.warn} Warning Dashboard`)
    .setColor(theme.colors.primary)
    .setDescription(lines);
  applyFooterWithPagination(embed, guild, { testingMode: config.testingMode, page: curPage, totalPages, extra: `Mute at ${muteT} • Kick at ${kickT}` });

  // Per-user select for simpler navigation
  const userOptions = slice.map(x => ({
    label: memberLabel(guild, x.userId).slice(0, 100),
    description: `${x.count} warning${x.count === 1 ? "" : "s"}`,
    value: x.userId
  }));

  const rows = [];
  // User selector row
  rows.push(new ActionRowBuilder().addComponents(
    new StringSelectMenuBuilder()
      .setCustomId(`warns_select_user_${curPage}`)
      .setPlaceholder(userOptions.length ? "Select a user to view" : "No users to select")
      .setMinValues(1)
      .setMaxValues(1)
      .addOptions(userOptions.length ? userOptions : [{ label: "No users", value: "noop", default: true }])
      .setDisabled(!userOptions.length)
  ));
  // Shared pagination row (always present for consistency; disabled internally if not needed)
  rows.push(paginationRow(`warns_dash_${curPage}`, curPage, totalPages));
  return { embed, rows, page: curPage, totalPages };
}

function buildUserView(guild, userId, page = 1, opts = {}) {
  const includeBack = opts.includeBack !== undefined ? opts.includeBack : true;
  ensureWarningsMap();
  maybeSeedTestingData(guild);
  const arr = getVisibleWarnings(userId);
  const memberName = memberLabel(guild, userId);
  const total = arr.length;

  const start = (page - 1) * MAX_WARNING_LIST;
  const chunk = arr.slice(start, start + MAX_WARNING_LIST);
  const totalPages = Math.max(1, Math.ceil(total / MAX_WARNING_LIST));

  const baseDesc = total ? chunk.map((e, i) => formatWarnLine(guild, e, start + i + 1)).join("\n\n") : "This user has no warnings.";
  const nxt = getNextPunishmentInfo(total);
  const disclaimer = nxt ? `${nxt.remaining} warning${nxt.remaining === 1 ? "" : "s"} remaining until ${nxt.label}` : null;
  const { muteT, kickT } = getThresholds();
  const embed = new EmbedBuilder()
    .setTitle(`${theme.emojis.warn} Warnings — ${memberName}`)
    .setColor(theme.colors.primary)
    .setDescription([baseDesc, disclaimer].filter(Boolean).join("\n\n"));
  applyFooterWithPagination(embed, guild, { testingMode: config.testingMode, page: Math.min(page, totalPages), totalPages, extra: `Total: ${total} • Mute at ${muteT} • Kick at ${kickT}` });

  const rows = [];
  // Pagination row first
  rows.push(paginationRow(`warns_user_${userId}_${page}`, page, totalPages));
  // Actions row
  const actions = new ActionRowBuilder().addComponents(
    new ButtonBuilder().setCustomId(`warns_add_${userId}`).setLabel("Add Warning").setStyle(ButtonStyle.Secondary),
    new ButtonBuilder().setCustomId(`warns_remove_${userId}`).setLabel("Remove Warning").setStyle(ButtonStyle.Secondary).setDisabled(!total)
  );
  if (includeBack) actions.addComponents(new ButtonBuilder().setCustomId("warns_user_back").setLabel("Back to list").setStyle(ButtonStyle.Secondary));
  rows.push(actions);
  return { embed, rows, total, totalPages, page };
}

async function showWarnings(client, message, targetUserId = null) {
  const guild = message.guild;
  if (!guild) return;
  maybeSeedTestingData(guild);
  if (targetUserId) {
    const view = buildUserView(guild, targetUserId, 1, { includeBack: false });
    await message.reply({ embeds: [view.embed], components: view.rows, allowedMentions: { parse: [] } });
    return;
  }
  const dash = buildDashboardEmbed(guild, 1);
  await message.reply({ embeds: [dash.embed], components: dash.rows, allowedMentions: { parse: [] } });
}

async function handleWarningsCommand(client, message) {
  if (!isModerator(message.member)) return replyError(message, "You are not allowed to use this command.");
  ensureWarningsMap();
  const mentioned = message.mentions.members.first();
  const argId = message.content.split(/\s+/)[1]?.replace(/[^0-9]/g, "");
  const targetId = mentioned?.id || argId || null;
  await showWarnings(client, message, targetId);
}

function buildRemoveSelect(guild, userId) {
  const arr = getVisibleWarnings(userId);
  const opts = arr.slice(0, 25).map((e, idx) => ({
    label: `#${idx + 1} — ${(e.reason || "No reason").slice(0, 90)}`,
    description: `${memberLabel(guild, e.moderator || "?")} • ${e.date ? new Date(e.date).toLocaleDateString() : "Unknown"}`,
    value: String(idx)
  }));
  const row = new ActionRowBuilder().addComponents(
    new StringSelectMenuBuilder()
      .setCustomId(`warns_remove_pick_${userId}`)
      .setPlaceholder("Select warning(s) to remove")
      .setMinValues(1)
      .setMaxValues(Math.max(1, Math.min(25, opts.length)))
      .addOptions(opts.length ? opts : [{ label: "No warnings", value: "noop", default: true }])
      .setDisabled(!opts.length)
  );
  return row;
}

async function handleWarningButtons(client, interaction) {
  // Route both buttons and selects and modal submits starting with warns:
  try {
    if (interaction.isButton()) {
      const id = interaction.customId;
      const isRelevant = id.startsWith("warns_dash_") || id.startsWith("warns_user_") || id.startsWith("warns_add_") || id.startsWith("warns_remove_") || id === "warns_user_back";
      if (!isRelevant) return;

      // Dashboard pagination
      if (id.startsWith("warns_dash_")) {
        const m = id.match(/^warns_dash_(\d+)_(prev|next|page)$/);
        if (m) {
          const cur = Number(m[1]) || 1;
          const action = m[2];
          if (action === 'prev' || action === 'next') {
            const page = action === 'prev' ? Math.max(1, cur - 1) : cur + 1;
            const dash = buildDashboardEmbed(interaction.guild, page);
            await interaction.update({ embeds: [dash.embed], components: dash.rows }).catch(() => {});
          } else {
            await interaction.deferUpdate().catch(() => {});
          }
          return;
        }
      }
  // User view pagination
      if (id.startsWith("warns_user_")) {
        const m = id.match(/^warns_user_(\d+)_(\d+)_(prev|next|page)$/);
        if (m) {
          const userId = m[1];
          const cur = Number(m[2]) || 1;
          const action = m[3];
          if (action === 'prev' || action === 'next') {
            const page = action === 'prev' ? Math.max(1, cur - 1) : cur + 1;
            const view = buildUserView(interaction.guild, userId, page);
            await interaction.update({ embeds: [view.embed], components: view.rows }).catch(() => {});
          } else {
            await interaction.deferUpdate().catch(() => {});
          }
          return;
        }
      }

      if (id === "warns_user_back") {
        const dash = buildDashboardEmbed(interaction.guild, 1);
        await interaction.update({ embeds: [dash.embed], components: dash.rows }).catch(() => {});
        return;
      }
      if (id.startsWith("warns_add_")) {
        const userId = id.substring("warns_add_".length);
        const modal = new ModalBuilder()
          .setCustomId(`warns_add_${userId}`)
          .setTitle("Add warning");
        modal.addComponents(
          new ActionRowBuilder().addComponents(
            new TextInputBuilder().setCustomId("reason").setLabel("Reason").setStyle(TextInputStyle.Paragraph).setRequired(true).setMaxLength(400)
          )
        );
        await interaction.showModal(modal);
        return;
      }
      if (id.startsWith("warns_remove_")) {
        const userId = id.substring("warns_remove_".length);
        const view = buildUserView(interaction.guild, userId, 1);
        const selectRow = buildRemoveSelect(interaction.guild, userId);
        const rows = [selectRow, ...view.rows];
        await interaction.update({ embeds: [view.embed], components: rows }).catch(() => {});
        return;
      }
      return;
    }

    if (interaction.isStringSelectMenu() && interaction.customId.startsWith("warns_")) {
      const id = interaction.customId;
      if (id.startsWith("warns_select_user_")) {
        const uid = interaction.values?.[0] || "";
        if (!uid || uid === "noop") { await interaction.deferUpdate().catch(() => {}); return; }
        const view = buildUserView(interaction.guild, uid, 1);
        await interaction.update({ embeds: [view.embed], components: view.rows }).catch(() => {});
        return;
      }
      if (id.startsWith("warns_remove_pick_")) {
        const userId = id.substring("warns_remove_pick_".length);
        const idxs = (interaction.values || []).map(v => Number(v)).filter(n => Number.isInteger(n));
        ensureWarningsMap();
        // If only seeded exists in testing, copy it to explicit store before modifying
        let arr = getUserWarnings(userId);
        if (config.testingMode && (!Array.isArray(arr) || arr.length === 0)) {
          const vis = getVisibleWarnings(userId);
          arr = Array.isArray(vis) ? vis.map(x => ({ moderator: x.moderator, reason: x.reason, date: x.date })) : [];
        }
        const removed = [];
        // Remove from highest index to lowest
        idxs.sort((a, b) => b - a);
        for (const i of idxs) if (i >= 0 && i < arr.length) removed.push(arr.splice(i, 1)[0]);
        setUserWarnings(userId, arr);
  // Aggregate DM and log for removals
  const count = removed.length;
  const actionText = count > 1 ? `Warning removed x${count}` : `Warning removed`;
  const lastReason = removed[0]?.reason || "No reason";
  const nxt = getNextPunishmentInfo(arr.length);
  const remainingNum = nxt ? nxt.remaining : 0;
  const remLine = nxt ? `${nxt.remaining} warning${nxt.remaining === 1 ? "" : "s"} remaining until ${nxt.label}` : null;
  // Resolve target for DM/log
  let target = interaction.guild.members.cache.get(userId) || interaction.client.users.cache.get(userId);
  if (!target) target = await interaction.client.users.fetch(userId).catch(() => null);
  try { if (target) await sendUserDM(target, actionText, null, null, null); } catch {}
  try { if (target) await sendModLog(interaction.client, target, interaction.user, actionText, remLine ? `${lastReason}\n\n${remLine}` : `${lastReason}`, true, null, remainingNum); } catch {}
        const view = buildUserView(interaction.guild, userId, 1);
        // Update the message and send a hidden confirmation
        await interaction.update({ embeds: [view.embed], components: view.rows }).catch(() => {});
  try { await interaction.followUp({ content: `${EMOJI_SUCCESS} Removed ${count} warning${count === 1 ? "" : "s"}.`, flags: 1<<6 }); } catch {}
        return;
      }
      return;
    }

    if (interaction.isUserSelectMenu && interaction.isUserSelectMenu() && interaction.customId.startsWith("warns:")) {
      const parts = interaction.customId.split(":");
      if (parts[1] === "uselect") {
        const userId = interaction.values?.[0];
        if (!userId) { await interaction.deferUpdate().catch(() => {}); return; }
        const view = buildUserView(interaction.guild, userId, 1);
        await interaction.update({ embeds: [view.embed], components: view.rows }).catch(() => {});
        return;
      }
    }

    if (interaction.isModalSubmit() && interaction.customId.startsWith("warns_add_")) {
      const userId = interaction.customId.substring("warns_add_".length);
      const reason = interaction.fields.getTextInputValue("reason").trim() || "No reason provided";
  ensureWarningsMap();
  // In testing mode, avoid carrying over seeded items; start explicit list
  let arr = getUserWarnings(userId);
  if (config.testingMode && (!Array.isArray(arr) || arr.length === 0)) arr = [];
  const entry = { moderator: interaction.user.id, reason, date: Date.now(), logMsgId: null, logChannelId: null };
  arr.push(entry);
  setUserWarnings(userId, arr);

      const member = interaction.guild.members.cache.get(userId) || null;
      const target = member || (await interaction.client.users.fetch(userId).catch(() => null));
      // DM user and log (escalation handled elsewhere if configured)
      const nxt = getNextPunishmentInfo(arr.length);
      const adExtra = nxt ? `${nxt.remaining} warning${nxt.remaining === 1 ? "" : "s"} remaining until ${nxt.label}` : null;
      try { await sendUserDM(target, "warned", null, reason, adExtra); } catch {}
      try {
        const nxtRemain = nxt ? nxt.remaining : 0;
        // Do not include remaining line in warn logs; pass remaining separately for context
        const msg = await sendModLog(interaction.client, target, interaction.user, "warned", `${reason}`, true, null, nxtRemain);
        if (msg) { entry.logMsgId = msg.id; entry.logChannelId = msg.channelId; saveConfig(); }
      } catch {}

      // Update the original message if possible
      try {
        const view = buildUserView(interaction.guild, userId, 1);
        if (interaction.message && interaction.message.edit) {
          await interaction.message.edit({ embeds: [view.embed], components: view.rows }).catch(() => {});
          await interaction.reply({ content: `${EMOJI_SUCCESS} Warning added.`, flags: 1<<6 });
        } else {
          await interaction.reply({ embeds: [view.embed], components: view.rows, flags: 1<<6 });
        }
      } catch {
  await interaction.reply({ content: `${EMOJI_SUCCESS} Warning added.`, flags: 1<<6 }).catch(() => {});
      }
      return;
    }
  } catch (err) {
    console.error("[Warnings Interaction Error]", err);
    try {
      if (interaction.isRepliable() && !interaction.replied && !interaction.deferred) {
  await interaction.reply({ content: `An error occurred. ${err.message || err}`, flags: 1<<6 });
      }
    } catch {}
  }
}

function cleanWarnings(userId = null) {
  ensureWarningsMap();
  if (userId) {
    const arr = config.warnings[userId];
    if (!Array.isArray(arr) || arr.length === 0) delete config.warnings[userId];
  } else {
    for (const [uid, arr] of Object.entries(config.warnings)) {
      if (!Array.isArray(arr) || arr.length === 0) delete config.warnings[uid];
    }
  }
  saveConfig();
}

module.exports = {
  showWarnings,
  cleanWarnings,
  handleWarningsCommand,
  handleWarningButtons
};
```

===== FILE: commands/profile.js =====
```javascript
const { EmbedBuilder, ActionRowBuilder, ButtonBuilder, ButtonStyle } = require("discord.js");
const { createEmbed, safeAddField } = require('../utils/embeds');
// Service layer imports (replace direct utils access)
const { 
  getUserLevelData, 
  getUserModifier, 
  levels: textLevelsData, 
  vcLevels: vcLevelsData,
  getXP, getLevel, getVCXP, getVCLevel
} = require("../services/levelingService");
const { bank: bankService, cash: cashService } = require('../services/economyService');
const { config } = require("../utils/storage");
const ActiveMenus = require("../utils/activeMenus");
const theme = require("../utils/theme");
const { progressBar: sharedProgressBar, applyStandardFooter, applyFooterWithPagination, paginationRow } = require("../utils/ui");
const { formatCash } = require("../utils/cash");
// Use cached leaderboard service instead of raw util leaderboard builder
const { buildLeaderboardEmbed: sharedLeaderboardEmbed } = require("../services/leaderboardService");
const { getBaseLimit } = require("../utils/bank"); // getBank now via bankService

// Map configured level reward roles to human-friendly labels
const PERMISSION_ROLE_LABELS = {
  "1232701768354369551": "Links",
  "1403501108151975966": "DJ",
  "1232701768354369552": "Images",
};
// Phrases to display in the Profile for owned permissions (not role mentions)
const PERMISSION_ROLE_PHRASES = {
  "1232701768354369551": "Link permissions",
  "1403501108151975966": "DJ permissions",
  "1232701768354369552": "Image permissions",
};

function getLevelXP(level) {
  const BASE_XP = 150; // keep in sync with utils/levels
  return Math.floor(BASE_XP * Math.pow(level, 1 / 0.7));
}

// Deprecated local progress bar; use shared UI helper for consistency
function createProgressBar(current, max, size = 18) {
  return sharedProgressBar(current, max, size, { showNumbers: true, allowOverflow: false });
}

function getRankFromLeaderboard(levelsObj, userId) {
  const entries = Object.entries(levelsObj || {}).map(([uid, data]) => ({
    userId: uid,
    xp: data?.xp || 0,
    level: data?.level || 0,
  }));
  entries.sort((a, b) => (b.level - a.level) || (b.xp - a.xp));
  const idx = entries.findIndex(e => e.userId === userId);
  return idx === -1 ? null : idx + 1;
}

function collectUserPermissions(member, mode = "text") {
  // Aggregate configured rewards and match against member roles
  const rewards = mode === "vc" ? (config.vcLevelRewards || {}) : (config.levelRewards || {});
  const perms = [];
  for (const [level, roleIdsOrArray] of Object.entries(rewards)) {
    const roleIds = Array.isArray(roleIdsOrArray) ? roleIdsOrArray : (roleIdsOrArray ? [roleIdsOrArray] : []);
    for (const roleId of roleIds) {
      if (member.roles.cache.has(roleId)) {
        const label = PERMISSION_ROLE_LABELS[roleId] || (member.guild.roles.cache.get(roleId)?.name ?? roleId);
        perms.push({ roleId, label, level: Number(level) || 0 });
      }
    }
  }
  perms.sort((a,b) => a.level - b.level || a.label.localeCompare(b.label));
  return perms;
}

function formatPermissionPhrases(perms) {
  // Convert owned permission roles to short phrases and render as achievement-style lines
  const phrasesSet = new Set();
  for (const p of perms) {
    const phrase = PERMISSION_ROLE_PHRASES[p.roleId];
    if (phrase) phrasesSet.add(phrase);
  }
  const phrases = Array.from(phrasesSet);
  const order = ["Image permissions", "Link permissions", "DJ permissions"]; // stable nice order
  phrases.sort((a, b) => order.indexOf(a) - order.indexOf(b));
  if (phrases.length === 0) return "*None unlocked yet*";
  const emojiMap = { "Image permissions": "🖼️", "Link permissions": "🔗", "DJ permissions": "🎧" };
  return phrases.map(ph => `${emojiMap[ph] || "🏅"} ${ph}`).join("\n");
}

function buildRows(view = "main", page = 1, totalPages = 1, mode = "text") {
  const isProfile = view === "main" || view === "profile";
  const isRank = view === "rank";
  const isLB = view === "leaderboard";
  const navRow = new ActionRowBuilder().addComponents(
    new ButtonBuilder().setCustomId("prof_home").setLabel("👤 Profile").setStyle(isProfile ? ButtonStyle.Primary : ButtonStyle.Secondary),
    new ButtonBuilder().setCustomId("prof_rank").setLabel("📊 Rank").setStyle(isRank ? ButtonStyle.Primary : ButtonStyle.Secondary),
    new ButtonBuilder().setCustomId("prof_lb").setLabel("🏆 Leaderboard").setStyle(isLB ? ButtonStyle.Primary : ButtonStyle.Secondary),
  );
  const toggleRow = new ActionRowBuilder().addComponents(
    new ButtonBuilder()
      .setCustomId("prof_toggle_mode")
      .setLabel(mode === "text" ? "🎙️ VC Mode" : "💬 Text Mode")
      .setStyle(mode === "text" ? ButtonStyle.Secondary : ButtonStyle.Success)
  );
  if (!isLB) return [toggleRow, navRow];
  const pageRow = paginationRow("lb", page, totalPages);
  return [toggleRow, navRow, pageRow];
}

function buildRankEmbed(member, rank, level, progressBar, mode = "text") {
  const embed = createEmbed({
    title: mode === 'text' ? `${theme.emojis.rank} Your Rank` : `${theme.emojis.vc} Your VC Rank`,
    color: mode === 'text' ? theme.colors.primary : theme.colors.danger
  }).setAuthor({ name: member.user.tag, iconURL: member.user.displayAvatarURL({ dynamic: true }) })
    .setThumbnail(member.user.displayAvatarURL({ dynamic: true, size: 256 }));
  safeAddField(embed, 'Level', `\`Lv. ${level}\``, true);
  safeAddField(embed, 'Rank', rank ? `#${rank}` : '—', true);
  safeAddField(embed, 'Progress', `${progressBar}`, false);
  applyStandardFooter(embed, member.guild, { testingMode: config.testingMode });
  return embed;
}

function buildLeaderboardEmbed(guild, levelsObj, viewerId, page = 1, pageSize = 10, mode = "text") {
  return sharedLeaderboardEmbed(guild, levelsObj, viewerId, page, pageSize, mode);
}

async function handleProfileCommand(client, message) {
  const member = message.member;
  if (!member) return; // Ensure member is defined

  const userId = member.id;
  const mode = "text"; // initial
  const { xp, level } = getUserLevelData(userId, 'text');
  const nextLevel = level + 1;
  const xpForNextLevel = getLevelXP(nextLevel);
  const xpForCurrentLevel = getLevelXP(level);
  const xpIntoLevel = Math.max(0, xp - xpForCurrentLevel);
  const xpNeeded = Math.max(1, xpForNextLevel - xpForCurrentLevel);
  const progressBar = createProgressBar(xpIntoLevel, xpNeeded, 20);

  const modifier = getUserModifier(userId) * (Number.isFinite(config.globalXPMultiplier) ? config.globalXPMultiplier : 1);
  const effective = Math.max(0, modifier);

  // Determine rank position from levels.json data
  const rank = getRankFromLeaderboard(textLevelsData, userId);

  const userPerms = collectUserPermissions(member, mode);
  const permsDisplay = formatPermissionPhrases(userPerms);

  const bank = bankService.getBank(userId) || 0;
  const base = getBaseLimit();
  const embed = createEmbed({
    title: `${theme.emojis.profile} Your Profile`,
    color: theme.colors.primary
  }).setAuthor({ name: member.user.tag, iconURL: member.user.displayAvatarURL({ dynamic: true }) })
    .setThumbnail(member.user.displayAvatarURL({ dynamic: true, size: 256 }));
  safeAddField(embed, 'Level', `\`Lv. ${level}\``, true);
  safeAddField(embed, 'Rank', rank ? `#${rank}` : '—', true);
  safeAddField(embed, 'XP Modifier', `x${effective.toFixed(2)}`, true);
  safeAddField(embed, 'Money', `$${(cashService.getCash(userId)||0).toLocaleString()}`, true);
  safeAddField(embed, 'Bank', `$${bank.toLocaleString()}/$${base.toLocaleString()}`, true);
  safeAddField(embed, 'Progress', `${progressBar}`);
  safeAddField(embed, 'Unlocked Perks', permsDisplay);
  applyStandardFooter(embed, member.guild, { testingMode: config.testingMode });

  // Optional: show next unlock preview
  const rewardsMap = mode === "vc" ? (config.vcLevelRewards || {}) : (config.levelRewards || {});
  const upcoming = Object.keys(rewardsMap || {})
    .map(n => Number(n)).filter(n => Number.isFinite(n) && n > level)
    .sort((a,b) => a-b)[0];
  if (upcoming) {
    const roles = rewardsMap[String(upcoming)];
    const roleIds = Array.isArray(roles) ? roles : (roles ? [roles] : []);
    if (roleIds.length) {
      const mentions = roleIds.map(id => `<@&${id}>`).join(", ");
  embed.addFields({ name: `${theme.emojis.action} Next Unlock`, value: `Level ${upcoming}: ${mentions}`, inline: false });
    }
  }

  // Send and register a persistent session. Handling is done in ActiveMenus.registerHandler below.
  const sent = await message.reply({ embeds: [embed], components: buildRows("main", 1, 1, mode) });
  ActiveMenus.registerMessage(sent, { type: "profile", userId: message.author.id, data: { view: "main", mode } });
}

// Global handler for profile sessions
const { levels: levelsObj } = require("../utils/levels");
ActiveMenus.registerHandler("profile", async (interaction, session) => {
  const member = interaction.member;
  if (!member || (session.userId && member.id !== session.userId)) {
  try { await interaction.reply({ content: "Only the original user can use this menu.", flags: 1<<6 }); } catch {}
    return;
  }
  const uid = member.id;
  const mode = session?.data?.mode === "vc" ? "vc" : "text";
  const xp = mode === "vc" ? getVCXP(uid) : getXP(uid);
  const lvl = mode === "vc" ? getVCLevel(uid) : getLevel(uid);
  const next = lvl + 1;
  const xpNext = getLevelXP(next);
  const xpCurr = getLevelXP(lvl);
  const into = Math.max(0, xp - xpCurr);
  const need = Math.max(1, xpNext - xpCurr);
  const bar = createProgressBar(into, need, 20);
  const levelsSource = session?.data?.levelsOverride || (mode === "vc" ? vcLevels : levelsObj);
  const rank = getRankFromLeaderboard(levelsSource, uid);

  if (interaction.customId === "prof_toggle_mode") {
    session.data.mode = mode === "vc" ? "text" : "vc";
    // Re-render current view in new mode
    const m = session.data.mode;
    const source = m === "vc" ? vcLevels : levelsObj;
    const userXP = m === "vc" ? getVCXP(uid) : getXP(uid);
    const userLvl = m === "vc" ? getVCLevel(uid) : getLevel(uid);
    const next = userLvl + 1;
    const xpNext = getLevelXP(next);
    const xpCurr = getLevelXP(userLvl);
    const into = Math.max(0, userXP - xpCurr);
    const need = Math.max(1, xpNext - xpCurr);
    const bar = createProgressBar(into, need, 20);
    const r = getRankFromLeaderboard(source, uid);
    let embed;
  if (session.data.view === "leaderboard") {
      const page = Number(session.data.page) || 1;
      const totalPages = Math.max(1, Math.ceil(Object.keys(source || {}).length / 10));
      embed = buildLeaderboardEmbed(interaction.guild, source, uid, Math.min(page, totalPages), 10, m);
      await interaction.update({ embeds: [embed], components: buildRows("leaderboard", Math.min(page, totalPages), totalPages, m) });
      return;
  } else if (session.data.view === "rank") {
      embed = buildRankEmbed(member, r, userLvl, bar, m);
      await interaction.update({ embeds: [embed], components: buildRows("rank", 1, 1, m) });
      return;
    } else {
      // profile
      const userMod = getUserModifier(uid) || 1.0;
      const globalMod = typeof config.globalXPMultiplier === "number" ? config.globalXPMultiplier : 1.0;
      const eff = Math.max(0, +(userMod * globalMod).toFixed(2));
  const bankNow = getBank(uid) || 0;
  const baseNow = getBaseLimit();
  const pEmbed = createEmbed({
    title: m === 'text' ? `${theme.emojis.profile} Your Profile` : `${theme.emojis.vc} Your VC Profile`,
    color: m === 'text' ? theme.colors.primary : theme.colors.danger
  }).setAuthor({ name: member.user.tag, iconURL: member.user.displayAvatarURL({ dynamic: true }) })
    .setThumbnail(member.user.displayAvatarURL({ dynamic: true, size: 256 }));
  safeAddField(pEmbed, 'Level', `\`Lv. ${userLvl}\``, true);
  safeAddField(pEmbed, 'Rank', r ? `#${r}` : '—', true);
  safeAddField(pEmbed, m === 'text' ? 'XP Modifier' : 'VC XP Modifier', `x${eff.toFixed(2)}`, true);
  safeAddField(pEmbed, 'Money', `$${(getCash(uid)||0).toLocaleString()}`, true);
  safeAddField(pEmbed, 'Bank', `$${bankNow.toLocaleString()}/$${baseNow.toLocaleString()}`, true);
  safeAddField(pEmbed, 'Progress', `${bar}`);
  safeAddField(pEmbed, 'Unlocked Perks', formatPermissionPhrases(collectUserPermissions(member, m)));
      applyStandardFooter(pEmbed, member.guild, { testingMode: config.testingMode });
      // Next Unlock for the current mode after toggle
      const rewardsMapToggle = m === "vc" ? (config.vcLevelRewards || {}) : (config.levelRewards || {});
      const nextTier = Object.keys(rewardsMapToggle)
        .map(n => Number(n)).filter(n => Number.isFinite(n) && n > userLvl)
        .sort((a,b) => a-b)[0];
      if (nextTier) {
        const rids = rewardsMapToggle[String(nextTier)];
        const ids = Array.isArray(rids) ? rids : (rids ? [rids] : []);
        if (ids.length) {
          const mentions = ids.map(id => `<@&${id}>`).join(", ");
          pEmbed.addFields({ name: `${theme.emojis.action} Next Unlock`, value: `Level ${nextTier}: ${mentions}`, inline: false });
        }
      }
      await interaction.update({ embeds: [pEmbed], components: buildRows("main", 1, 1, m) });
      return;
    }
  }
  if (interaction.customId === "prof_lb") {
    const page = 1;
    const src = session?.data?.levelsOverride || (mode === "vc" ? vcLevels : levelsObj);
    const lbEmbed = buildLeaderboardEmbed(interaction.guild, src, uid, page, 10, mode);
    session.data.view = "leaderboard";
    session.data.page = page;
    const totalPages = Math.max(1, Math.ceil(Object.keys(src || {}).length / 10));
    await interaction.update({ embeds: [lbEmbed], components: buildRows("leaderboard", page, totalPages, mode) });
    return;
  }
  if (interaction.customId === "lb_prev" || interaction.customId === "lb_next") {
    const src = session?.data?.levelsOverride || (mode === "vc" ? vcLevels : levelsObj);
    const totalPages = Math.max(1, Math.ceil(Object.keys(src || {}).length / 10));
    let page = Number(session.data.page) || 1;
    page += interaction.customId === "lb_next" ? 1 : -1;
    if (page < 1) page = 1;
    if (page > totalPages) page = totalPages;
    session.data.page = page;
    const lbEmbed = buildLeaderboardEmbed(interaction.guild, src, uid, page, 10, mode);
    await interaction.update({ embeds: [lbEmbed], components: buildRows("leaderboard", page, totalPages, mode) });
    return;
  }
  if (interaction.customId === "prof_rank") {
    const rEmbed = buildRankEmbed(member, rank, lvl, bar, mode);
    session.data.view = "rank";
    await interaction.update({ embeds: [rEmbed], components: buildRows("rank", 1, 1, mode) });
    return;
  }
  // prof_home
  const userMod = getUserModifier(uid) || 1.0;
  const globalMod = typeof config.globalXPMultiplier === "number" ? config.globalXPMultiplier : 1.0;
  const eff = Math.max(0, +(userMod * globalMod).toFixed(2));
  const rewardsForMode = mode === "vc" ? (config.vcLevelRewards || {}) : (config.levelRewards || {})
  const upcoming = Object.keys(rewardsForMode || {})
    .map(n => Number(n)).filter(n => Number.isFinite(n) && n > lvl)
    .sort((a,b) => a-b)[0];
  const bank0 = bankService.getBank(uid) || 0;
  const base0 = getBaseLimit();
  const pEmbed = createEmbed({
    title: mode === 'text' ? `${theme.emojis.profile} Your Profile` : `${theme.emojis.vc} Your VC Profile`,
    color: mode === 'text' ? theme.colors.primary : theme.colors.danger
  }).setAuthor({ name: member.user.tag, iconURL: member.user.displayAvatarURL({ dynamic: true }) })
    .setThumbnail(member.user.displayAvatarURL({ dynamic: true, size: 256 }));
  safeAddField(pEmbed, 'Level', `\`Lv. ${lvl}\``, true);
  safeAddField(pEmbed, 'Rank', rank ? `#${rank}` : '—', true);
  safeAddField(pEmbed, 'XP Modifier', `x${eff.toFixed(2)}`, true);
  safeAddField(pEmbed, 'Money', `$${(cashService.getCash(uid)||0).toLocaleString()}`, true);
  safeAddField(pEmbed, 'Bank', `$${bank0.toLocaleString()}/$${base0.toLocaleString()}`, true);
  safeAddField(pEmbed, 'Progress', `${bar}`);
  safeAddField(pEmbed, 'Unlocked Perks', formatPermissionPhrases(collectUserPermissions(member)));
  applyStandardFooter(pEmbed, member.guild, { testingMode: config.testingMode });
  if (upcoming) {
    const roles = rewardsForMode[String(upcoming)];
    const roleIds = Array.isArray(roles) ? roles : (roles ? [roles] : []);
    if (roleIds.length) {
      const mentions = roleIds.map(id => `<@&${id}>`).join(", ");
  pEmbed.addFields({ name: `${theme.emojis.action} Next Unlock`, value: `Level ${upcoming}: ${mentions}`, inline: false });
    }
  }
  session.data.view = "main";
  await interaction.update({ embeds: [pEmbed], components: buildRows("main", 1, 1, mode) });
});

module.exports = { handleProfileCommand, buildLeaderboardEmbed, buildRows, buildRankEmbed };
// Alias: provide a dedicated rank command (legacy `.level`) without duplicating legacy level.js logic
async function handleRankCommand(client, message) {
  const member = message.member;
  if (!member) return;
  const uid = member.id;
  const mode = 'text';
  const xp = getXP(uid);
  const lvl = getLevel(uid);
  const next = lvl + 1;
  const xpNext = getLevelXP(next);
  const xpCurr = getLevelXP(lvl);
  const into = Math.max(0, xp - xpCurr);
  const need = Math.max(1, xpNext - xpCurr);
  const bar = createProgressBar(into, need, 20);
  const rank = getRankFromLeaderboard(levels, uid);
  const embed = buildRankEmbed(member, rank, lvl, bar, mode);
  const sent = await message.reply({ embeds: [embed], components: buildRows('rank', 1, 1, mode) }).catch(() => null);
  if (sent) {
    ActiveMenus.registerMessage(sent, { type: 'profile', userId: uid, data: { view: 'rank', mode } });
  }
}

module.exports.handleRankCommand = handleRankCommand;

```

===== FILE: commands/schedule.js =====
```javascript
const { EmbedBuilder, ActionRowBuilder, ButtonBuilder, ButtonStyle, ModalBuilder, TextInputBuilder, TextInputStyle, StringSelectMenuBuilder } = require("discord.js");
// Migrated to scheduleService abstraction (removes direct coupling to storage utils)
const { getEvents, getEvent, addEvent, updateEvent, removeEvent } = require("../services/scheduleService");
const { OWNER_ID } = require("./moderation/permissions");
const theme = require("../utils/theme");
const ActiveMenus = require("../utils/activeMenus");
const { applyFooterWithPagination, semanticButton, buildNavRow } = require("../utils/ui");
const { config } = require('../utils/storage');
const { ms } = require('../utils/time');
const { createEmbed, safeAddField } = require('../utils/embeds');
// Helper to inject event name placeholder
function applyEventName(str, ev) {
  if (!str || typeof str !== 'string') return str;
  return str.replace(/{{EVENT_NAME}}/g, ev.name || 'Event');
}

// --- Duration Parsing Helpers ---
// Accept forms:
//  - HH:MM (24h) => concrete time of day
// Utility: standardize anchor content for bar/opening style events (Midnight Bar pattern reuse)
function formatBarStyleAnchor(ev, nextEpoch) {
  return [
    `# The ${ev.name} is opening: <t:${nextEpoch}:R>`,
    '',
    ev.description ? ev.description : 'Stay tuned for special drops and bonuses.'
  ].join('\n');
}
//  - HH:MM-HH:MM => range with start/end
//  - natural duration strings for offsets before event (e.g. 15m, 1h, 2h30m, 90m)
//  - For times field we still keep HH:MM or HH:MM-HH:MM; we extend offsets & editing convenience

function parseOffsetInput(raw) {
  if (!raw) return 0;
  const trimmed = raw.trim().toLowerCase();
  if (trimmed === 'start' || trimmed === '0') return 0;
  // If pure number treat as minutes
  if (/^-?\d+$/.test(trimmed)) return Math.max(0, parseInt(trimmed,10));
  // Replace common words
  let norm = trimmed.replace(/minutes?/g,'m').replace(/hours?/g,'h').replace(/mins?/g,'m').replace(/hrs?/g,'h').replace(/seconds?/g,'s').replace(/secs?/g,'s').replace(/ /g,'');
  // If ends with h and has digits then convert manually if ms() fails
  let durMs = null;
  try { durMs = ms(norm); } catch { durMs = null; }
  if (typeof durMs === 'number' && isFinite(durMs) && durMs >= 0) {
    return Math.round(durMs / 60000); // minutes
  }
  // Support composite like 1h30m by manual parse if ms didn't catch
  const regex = /(\d+)(h|m|s)/g; let match; let totalMs = 0; let any=false;
  while ((match = regex.exec(norm))) {
    any=true; const val = parseInt(match[1],10); const unit = match[2];
    if (unit==='h') totalMs += val*3600000; else if (unit==='m') totalMs += val*60000; else if (unit==='s') totalMs += val*1000;
  }
  if (any) return Math.max(0, Math.round(totalMs/60000));
  return 0; // fallback
}

function humanizeMinutes(mins) {
  if (mins === 0) return 'at start';
  const h = Math.floor(mins/60); const m = mins % 60;
  if (h && m) return `${h}h ${m}m before`;
  if (h) return `${h} hour${h===1?'':'s'} before`;
  return `${m} minute${m===1?'':'s'} before`;
}

// Parse delete-after input to milliseconds. Accepts:
//  - '0', 'off', 'disable', 'none' => 0
//  - plain number => minutes
//  - composite durations like 1h30m, 45m, 20s
function parseDeleteAfterMs(input) {
  if (!input) return 0;
  const raw = String(input).trim().toLowerCase();
  if (["0","off","disable","disabled","none"].includes(raw)) return 0;
  if (/^-?\d+$/.test(raw)) { const mins = Math.max(0, parseInt(raw,10)); return mins * 60000; }
  const norm = raw.replace(/minutes?/g,'m').replace(/hours?/g,'h').replace(/hrs?/g,'h').replace(/mins?/g,'m').replace(/seconds?/g,'s').replace(/secs?/g,'s').replace(/ /g,'');
  let durMs = null;
  try { durMs = ms(norm); } catch { durMs = null; }
  if (typeof durMs === 'number' && isFinite(durMs) && durMs >= 0) return Math.floor(durMs);
  // manual composite fallback
  const regex = /(\d+)(h|m|s)/g; let match; let total = 0; let any=false;
  while ((match = regex.exec(norm))) { any=true; const v=parseInt(match[1],10); const u=match[2]; if (u==='h') total+=v*3600000; else if (u==='m') total+=v*60000; else total+=v*1000; }
  if (any) return total;
  return 0;
}

function humanizeMs(msVal) {
  const n = Number(msVal)||0; if (n<=0) return 'Disabled';
  const sec = Math.round(n/1000);
  const h = Math.floor(sec/3600); const m = Math.floor((sec%3600)/60); const s = sec%60;
  const parts = [];
  if (h) parts.push(`${h}h`);
  if (m) parts.push(`${m}m`);
  if (!h && !m && s) parts.push(`${s}s`);
  return parts.join(' ');
}

// --- Event Manager (ActiveMenus) ---

const DAY_NAMES = ["Sun","Mon","Tue","Wed","Thu","Fri","Sat"];

function summarizeEvent(ev) {
  const times = (ev.times || []).join(", ") || "–";
  const days = (ev.days || []).map(d => DAY_NAMES[d] || d).join(" ") || "All";
  const clock = (theme.emojis && (theme.emojis.times || theme.emojis.time)) || '🕒';
  const repeat = (theme.emojis && (theme.emojis.repeat || theme.emojis.days)) || '🔁';
  // Layout: status + bold name on first line; second line shows time(s) and repeats (days)
  return `${ev.enabled ? (theme.emojis.enable || '✅') : (theme.emojis.disable || '❌')} **${ev.name}**\n${clock} ${times} • ${repeat} ${days}`;
}

function buildMainEmbed(guild) {
  const evs = getEvents();
  const embed = createEmbed({
    title: `${theme.emojis.toggle || '🗓️'} Events Manager`,
    description: evs.length ? evs.map(summarizeEvent).join("\n\n") : "*No events defined yet.*",
    color: theme.colors.primary
  });
  applyFooterWithPagination(embed, guild, { page: 1, totalPages: 1, extra: `${evs.length} event${evs.length === 1 ? '' : 's'}` });
  return embed;
}

function buildDetailEmbed(guild, ev) {
  const times = (ev.times || []).length ? ev.times.join(", ") : "(none)";
  const days = (ev.days || []).length ? ev.days.map(d => DAY_NAMES[d] || d).join(", ") : "(none)";
  // Derive a short message preview. Prefer JSON payload summary if present.
  let msgPreview = ev.message ? (ev.message.length > 300 ? ev.message.slice(0,297)+"..." : ev.message) : "(none)";
  if (ev.messageJSON && typeof ev.messageJSON === 'object') {
    const json = ev.messageJSON;
    if (json.content) {
      msgPreview = `JSON: ${json.content.substring(0,120)}${json.content.length>120?"...":""}`;
    } else if (Array.isArray(json.embeds) && json.embeds.length) {
      const first = json.embeds[0];
      const t = first.title || first.description || '(embed)';
      msgPreview = `JSON Embed: ${String(t).substring(0,120)}${String(t).length>120?"...":""}`;
    } else {
      msgPreview = 'JSON payload';
    }
  }
  const embed = createEmbed({
    title: `${ev.enabled ? theme.emojis.enable : theme.emojis.disable} ${ev.name}`,
    description: ev.description || 'No description provided.',
    color: ev.enabled ? theme.colors.success : theme.colors.danger
  });
  safeAddField(embed, 'Status', ev.enabled ? 'Enabled' : 'Disabled', true);
  safeAddField(embed, 'Type', ev.type || 'multi-daily', true);
  safeAddField(embed, 'Channel', ev.channelId ? `<#${ev.channelId}>` : '(none)', true);
  safeAddField(embed, 'Times', times);
  safeAddField(embed, 'Days', days);
  safeAddField(embed, 'Message', msgPreview);
  applyFooterWithPagination(embed, guild, { page: 1, totalPages: 1, extra: 'Events Manager' });
  return embed;
}

function mainRows() {
  const evs = getEvents();
  // Order: Create, Delete, Select (no Close button per request)
  return [ buildNavRow([
    semanticButton('success', { id: 'events_create', label: 'Create', emoji: theme.emojis.create }),
    semanticButton('danger', { id: 'events_delete_mode', label: 'Delete', emoji: theme.emojis.delete }),
    semanticButton('primary', { id: 'events_select_mode', label: 'Select', emoji: theme.emojis.events, enabled: !!evs.length })
  ]) ];
}

function buildSelectRows(kind) {
  const evs = getEvents();
  const options = evs.slice(0,25).map(e => ({ label: e.name.slice(0,100), value: e.id, description: (e.times||[]).join(' ').slice(0,100), emoji: kind === 'delete' ? theme.emojis.delete : (e.enabled?theme.emojis.enable:theme.emojis.disable) }));
  const rows = [
    new ActionRowBuilder().addComponents(new StringSelectMenuBuilder().setCustomId(`events_${kind === 'delete' ? 'delete' : 'select'}`).setPlaceholder(kind==='delete'? 'Select event to delete' : 'Select event...').addOptions(options))
  ];
  return rows;
}

function detailRows(ev) {
  // Simplified: Toggle / Edit / Auto Msgs / Delete / Back
  const row = buildNavRow([
    semanticButton(ev.enabled ? 'danger' : 'success', { id: `events_toggle_${ev.id}`, label: ev.enabled ? 'Disable' : 'Enable', emoji: ev.enabled ? theme.emojis.disable : theme.emojis.enable }),
    semanticButton('primary', { id: `events_edit_${ev.id}`, label: 'Edit', emoji: theme.emojis.edit || theme.emojis.message || '✏️' }),
    semanticButton('nav', { id: `events_notifs_${ev.id}`, label: 'Auto Msgs', emoji: theme.emojis.bell || '🔔' }),
    semanticButton('danger', { id: `events_delete_${ev.id}`, label: 'Delete', emoji: theme.emojis.delete })
  ]);
  return [row];
}

// ---- Automated Messages (per-event) ----

function buildNotifsEmbed(guild, ev) {
  const embed = createEmbed({
    title: `${theme.emojis.bell || '🔔'} Auto Messages — ${ev.name}`,
    description: 'Configure automatic messages sent relative to each event time.',
    color: theme.colors.primary
  });
  safeAddField(embed, 'Event Times', (ev.times||[]).join(', ') || '(none)', true);
  safeAddField(embed, 'Days', (ev.days||[]).map(d=>DAY_NAMES[d]||d).join(', ') || 'All', true);
  safeAddField(embed, 'Total', String((ev.autoMessages||[]).length), true);
  const list = (ev.autoMessages||[]);
  if (list.length) {
    const lines = list.slice(0,15).map(m => {
      const status = m.enabled ? (theme.emojis.enable||'✅') : (theme.emojis.disable||'❌');
      const off = humanizeMinutes(m.offsetMinutes);
      let preview = '';
      if (m.messageJSON) {
        if (m.messageJSON.content) preview = m.messageJSON.content.slice(0,60);
        else if (Array.isArray(m.messageJSON.embeds) && m.messageJSON.embeds.length) preview = (m.messageJSON.embeds[0].title || m.messageJSON.embeds[0].description || '(embed)').toString().slice(0,60);
        else preview = 'JSON';
      } else {
        preview = (m.message||'').replace(/\n/g,' ').slice(0,60) || '(empty)';
      }
      const chanNote = m.channelId && m.channelId !== ev.channelId ? ` <#${m.channelId}>` : '';
      const clock = m.isClockIn ? ' ⏱️' : '';
      // TTL label: per-notif deleteAfterMs, else global default, clock-in always off
      const hasOwn = Number.isFinite(m.deleteAfterMs);
      let ttlDisp = 'off';
      if (!m.isClockIn) {
        if (hasOwn) ttlDisp = m.deleteAfterMs > 0 ? humanizeMs(m.deleteAfterMs) : 'off';
        else if (config.autoMessages?.defaultDeleteMs > 0) ttlDisp = humanizeMs(config.autoMessages.defaultDeleteMs) + '*';
      }
      const ttlLabel = ` [TTL ${ttlDisp}]`;
      return `${status} [${off}]${clock}${chanNote} ${preview}${ttlLabel}`;
    }).join('\n');
    safeAddField(embed, 'Messages', lines);
  } else {
    safeAddField(embed, 'Messages', '*None defined yet.*');
  }
  applyFooterWithPagination(embed, guild, { page:1, totalPages:1, extra: 'Auto Messages' });
  return embed;
}

function notifManagerRows(ev) {
  const row = buildNavRow([
    semanticButton('success', { id: `event_notif_add_${ev.id}`, label: 'Add', emoji: theme.emojis.create||'➕' }),
    semanticButton('primary', { id: `event_notif_selectmode_${ev.id}`, label: 'Select', emoji: theme.emojis.events||'📋', enabled: !!(ev.autoMessages||[]).length })
  ]);
  return [row];
}

function notifSelectRows(ev) {
  const opts = (ev.autoMessages||[]).slice(0,25).map(n => ({ label: `${humanizeMinutes(n.offsetMinutes)} ${n.enabled?'(on)':'(off)'} #${n.id}`.slice(0,100), value: n.id, description: (n.messageJSON?.content || n.message || '').replace(/\n/g,' ').slice(0,90) }));
  const row1 = new ActionRowBuilder().addComponents(new StringSelectMenuBuilder().setCustomId(`event_notif_select_${ev.id}`).setPlaceholder('Select auto message').addOptions(opts));
  return [row1];
}

// Newly added: detailed auto message control rows
function notifDetailRows(ev, notif) {
  // Row 1: Toggle / Edit (consolidated)
  const row1 = buildNavRow([
    semanticButton(notif.enabled ? 'danger' : 'success', { id: `event_notif_toggle_${ev.id}_${notif.id}`, label: notif.enabled ? 'Disable' : 'Enable', emoji: notif.enabled ? theme.emojis.disable : theme.emojis.enable }),
    semanticButton('primary', { id: `event_notif_edit_${ev.id}_${notif.id}`, label: 'Edit', emoji: theme.emojis.edit || theme.emojis.message || '✏️' })
  ]);
  // Row 2: Trigger / Delete
  const row2 = buildNavRow([
    semanticButton('success', { id: `event_notif_trigger_${ev.id}_${notif.id}`, label: 'Trigger', emoji: theme.emojis.enable || '✅' }),
    semanticButton('danger', { id: `event_notif_delete_${ev.id}_${notif.id}`, label: 'Delete', emoji: theme.emojis.delete || '🗑️' })
  ]);
  return [row1, row2];
}

function buildNotifDetailEmbed(guild, ev, notif) {
  const embed = createEmbed({
    title: `${notif.enabled ? theme.emojis.enable : theme.emojis.disable} Auto Message #${notif.id}`,
    description: `Relative send: **${humanizeMinutes(notif.offsetMinutes)}**\nEvent: **${ev.name}**`,
    color: notif.enabled ? theme.colors.success : theme.colors.danger
  });
  safeAddField(embed, 'Offset', notif.offsetMinutes===0?'0 (start)':`${humanizeMinutes(notif.offsetMinutes)}`, true);
  safeAddField(embed, 'Enabled', notif.enabled? 'Yes':'No', true);
  safeAddField(embed, 'Channel', notif.channelId ? `<#${notif.channelId}>` + (notif.channelId===ev.channelId ? ' (event)' : '') : `<#${ev.channelId}> (event)`, true);
  safeAddField(embed, 'Clock-In', notif.isClockIn ? 'Yes' : 'No', true);
  const ttlInfo = Number.isFinite(notif.deleteAfterMs) ? humanizeMs(notif.deleteAfterMs) : (config.autoMessages?.defaultDeleteMs ? `${humanizeMs(config.autoMessages.defaultDeleteMs)} (default)` : 'Disabled');
  safeAddField(embed, 'Delete after', ttlInfo, true);
  const previewVal = (()=>{ if (notif.messageJSON){ if (notif.messageJSON.content) return notif.messageJSON.content.slice(0,200)||'(empty)'; if (Array.isArray(notif.messageJSON.embeds)&&notif.messageJSON.embeds.length) return (notif.messageJSON.embeds[0].title||notif.messageJSON.embeds[0].description||'(embed)').toString().slice(0,200); return 'JSON'; } return (notif.message||'').slice(0,200)||'(empty)';})();
  safeAddField(embed, 'Preview', previewVal);
  applyFooterWithPagination(embed, guild, { page:1, totalPages:1, extra:'Auto Msg Detail' });
  return embed;
}

// Helper: create or update anchor message automatically
async function ensureAnchor(interactionOrClient, ev, basePayloadOverride) {
  const client = interactionOrClient.client || interactionOrClient; // support Interaction or Client
  const channel = await client.channels.fetch(ev.channelId).catch(()=>null);
  if (!channel || !channel.send) return null;
  const { applyTimestampPlaceholders } = require('../utils/timestampPlaceholders');
  let baseContent = ev.dynamicBaseContent || (ev.messageJSON?.content) || ev.message || ev.name;
  baseContent = applyEventName(baseContent, ev);
  // Auto-build Midnight Bar template if missing signature header
  if (/Midnight Bar/i.test(ev.name || '') && (!baseContent || !/Midnight Bar/i.test(baseContent))) {
    const barDivider = '─'.repeat(36);
    baseContent = [
      '## ✩ Midnight Bar ✩',
      '',
      'Check our ongoing instances [here](https://vrchat.com/home/group/grp_d05ea22e-5c38-476e-9884-1cbea50643eb/instances).',
      'We open daily; see the schedule channel for full details.',
      '',
      '### 🕒 Today\'s Opening Times',
      barDivider,
      '**First Opening:** timestamp_opening1 — timestamp_closing1',
      '~~Second Opening: timestamp_opening2 — timestamp_closing2~~',
      barDivider,
      '',
      '### 🔔 Notifications',
      'Use the subscribe button below to get notified when we open.',
      '',
      '### ❤️ Support',
      '[Support us on Patreon](https://www.patreon.com/c/lnhvrc)'
    ].join('\n');
  }
  baseContent = applyTimestampPlaceholders(baseContent, ev);
  baseContent = applyEventName(baseContent, ev);
  if (basePayloadOverride && basePayloadOverride.content) baseContent = basePayloadOverride.content;
  baseContent = applyTimestampPlaceholders(baseContent, ev);
  // Inject initial relative countdown line for Midnight Bar
  try {
  if (/Midnight Bar/i.test(ev.name || '') && /# The Midnight bar is opening:?$/im.test(baseContent)) {
      const { computeNextRange } = require('../utils/timestampPlaceholders');
      const range = computeNextRange(ev);
      if (range) {
        baseContent = baseContent.replace(/# The Midnight bar is opening:?$/im, `# The Midnight bar is opening in <t:${range.startSec}:R>`);
      }
    }
  } catch {}
  const payload = ev.messageJSON ? { ...ev.messageJSON, content: baseContent } : { content: baseContent };
  if (payload.embeds && !Array.isArray(payload.embeds)) payload.embeds = [payload.embeds];
  // Inject / enforce notification signup button for Midnight Bar
  let expectedButtonId = null;
  try {
    if (/Midnight Bar/i.test(ev.name || '')) {
      const { ActionRowBuilder, ButtonBuilder, ButtonStyle } = require('discord.js');
      expectedButtonId = `event_notify_${ev.id}`;
      const row = new ActionRowBuilder().addComponents(
        new ButtonBuilder()
          .setCustomId(expectedButtonId)
          .setLabel('Notify Me')
          .setStyle(ButtonStyle.Primary)
          .setEmoji('🔔')
      );
      payload.components = [row];
      // Ensure image embed attached (only once)
      const imageUrl = 'https://media.discordapp.net/attachments/1385673109486571772/1402700465417883648/The_Midnight_Bar_Event_v1.png?ex=68c1085b&is=68bfb6db&hm=47ea205d83ebe96fee67b47e877093580bde85f5f906d10764cd05b3ab0e15af&=&format=webp&quality=lossless&width=1718&height=350';
      const { EmbedBuilder } = require('discord.js');
      if (!payload.embeds) payload.embeds = [];
      const hasImage = payload.embeds.some(e => (e.data?.image?.url || e.image?.url) === imageUrl);
      if (!hasImage && payload.embeds.length < 10) {
  const { createEmbed } = require('../utils/embeds');
  const imgEmbed = createEmbed({ color: theme.colors.primary }).setImage(imageUrl);
        payload.embeds.push(imgEmbed);
      }
    }
  } catch {}
  let msg = null;
  if (ev.anchorMessageId) {
    msg = await channel.messages.fetch(ev.anchorMessageId).catch(()=>null);
  }
  if (!msg) {
    msg = await channel.send(payload).catch(()=>null);
    if (msg) {
      updateEvent(ev.id, { anchorChannelId: channel.id, anchorMessageId: msg.id, dynamicBaseContent: baseContent });
    }
  } else {
    // Decide if we must edit: content changed, override provided, or required button missing
    let needsEdit = false;
  if (basePayloadOverride || (payload.content && payload.content !== msg.content)) needsEdit = true;
    if (expectedButtonId) {
      const hasButton = Array.isArray(msg.components) && msg.components.some(r => r.components?.some?.(c => c.customId === expectedButtonId));
      if (!hasButton) needsEdit = true;
    }
    if (needsEdit) {
      await msg.edit(payload).catch(()=>{});
    }
    if (!ev.dynamicBaseContent) updateEvent(ev.id, { dynamicBaseContent: baseContent });
  }
  return msg;
}

async function handleScheduleCommand(client, message) {
  // Owner-only: send Events Manager main UI and register ActiveMenus session
  if (message.author.id !== OWNER_ID) return;
  const embed = buildMainEmbed(message.guild);
  const sent = await message.reply({ embeds: [embed], components: mainRows(), allowedMentions: { repliedUser: false } }).catch(()=>null);
  if (sent) ActiveMenus.registerMessage(sent, { type: 'events', userId: message.author.id, data: { mode: 'main' } });
  return sent;
}

// Handle creation modal: id pattern event_create_modal_<managerMessageId>
async function handleEventCreateModal(interaction) {
  if (!interaction.isModalSubmit() || !interaction.customId.startsWith('event_create_modal_')) return;
  const parts = interaction.customId.split('_');
  const managerMessageId = parts.slice(3).join('_') || null; // manager message id may contain underscores if ever changed
  const name = interaction.fields.getTextInputValue('name').trim();
  let channelId = interaction.fields.getTextInputValue('channel').trim().replace(/[<#>]/g,'');
  const timesRaw = interaction.fields.getTextInputValue('times').trim();
  const daysRaw = interaction.fields.getTextInputValue('days').trim();
  const messageContent = interaction.fields.getTextInputValue('message');
  const dayMap = { sun:0, sunday:0, mon:1, monday:1, tue:2, tuesday:2, wed:3, wednesday:3, thu:4, thursday:4, fri:5, friday:5, sat:6, saturday:6 };
  const healJSON = (txt) => {
    let c = txt.replace(/^```(json)?/i,'').replace(/```$/,'').trim();
    c = c.replace(/,\s*([}\]])/g,'$1');
    return c;
  };
  const clamp = (s,max=1900)=> (s && s.length>max? s.slice(0,max-3)+'...':s);
  if (!name) return interaction.reply({ content: '❌ Name required.', flags:1<<6 }).catch(()=>{});
  if (!/^\d{1,32}$/.test(channelId)) return interaction.reply({ content: '❌ Invalid channel id.', flags:1<<6 }).catch(()=>{});
  const times = timesRaw.split(/[\,\s]+/).map(t=>t.trim()).filter(Boolean);
  if (!times.length) return interaction.reply({ content: '❌ Provide times.', flags:1<<6 }).catch(()=>{});
  const ranges = times.map(t => t.includes('-') ? (()=>{ const [s,e]=t.split('-').map(x=>x.trim()); return { start:s, end:e };})() : null).filter(Boolean);
  const days = daysRaw.split(/[\,\s]+/).map(d=>d.trim().toLowerCase()).filter(Boolean).map(d=>dayMap[d]).filter(d=>d!==undefined);
  if (!days.length) return interaction.reply({ content: '❌ Invalid days.', flags:1<<6 }).catch(()=>{});
  let messageJSON = null;
  const healed = healJSON(messageContent);
  if (healed.startsWith('{') && healed.endsWith('}')) { try { const parsed = JSON.parse(healed); if (parsed && typeof parsed==='object') messageJSON = parsed; } catch {} }
  if (messageJSON?.content) messageJSON.content = clamp(messageJSON.content, 2000);
  const base = messageJSON?.content || clamp(messageContent,2000);
  const ev = addEvent({
    name,
    description: name,
    channelId,
    message: messageContent,
    messageJSON,
    ranges,
    enabled: true,
    times,
    days,
    dynamicBaseContent: base,
    type: 'multi-daily',
    color: 0x00aa00
  });
  try { await ensureAnchor(interaction, ev, { content: base }); } catch (e) { console.error('[anchor create]', e); }
  const jsonNote = messageJSON ? ' (JSON payload detected)' : '';
  await interaction.reply({ content: `✅ Event ${ev.name} created with ${ev.times.length} time(s).${jsonNote}`, flags:1<<6 }).catch(()=>{});
  if (managerMessageId) {
    try {
      const mgrMsg = await interaction.channel.messages.fetch(managerMessageId).catch(()=>null);
      if (mgrMsg) await mgrMsg.edit({ embeds: [buildMainEmbed(interaction.guild)], components: mainRows() }).catch(()=>{});
    } catch {}
  }
}

// Legacy schedule modal (deprecated)
async function handleScheduleModal(interaction) {
  if (!interaction.isModalSubmit() || !interaction.customId.startsWith('schedule_create_modal')) return;
  await interaction.reply({ content: 'Scheduling system deprecated. Use Events Manager.', flags:1<<6 }).catch(()=>{});
}

// ActiveMenus handler
// Sanitize mentions for testing mode
function sanitizeMentionsForTesting(content) {
  if (!content || typeof content !== 'string') return content;
  return content.replace(/<@&?\d+>/g, m=>`\`${m}\``);
}

// Apply timestamp placeholders to JSON payload fields similarly to scheduler
function applyPlaceholdersToJsonPayload(payload, ev) {
  if (!payload || typeof payload !== 'object') return payload;
  const { applyTimestampPlaceholders } = require('../utils/timestampPlaceholders');
  const repl = (s) => applyTimestampPlaceholders(String(s), ev);
  const sanitize = (s) => (config.testingMode ? String(s).replace(/<@&?\d+>/g, m=>`\`${m}\``) : s);
  const fixStr = (s) => sanitize(repl(s));
  const copy = { ...payload };
  if (typeof copy.content === 'string') copy.content = fixStr(copy.content).slice(0, 2000);
  if (Array.isArray(copy.embeds)) {
    copy.embeds = copy.embeds.map(e => {
      if (!e || typeof e !== 'object') return e;
      const ee = { ...e };
      if (typeof ee.title === 'string') ee.title = fixStr(ee.title);
      if (typeof ee.description === 'string') ee.description = fixStr(ee.description);
      if (ee.footer && typeof ee.footer.text === 'string') ee.footer = { ...ee.footer, text: fixStr(ee.footer.text) };
      if (ee.author && typeof ee.author.name === 'string') ee.author = { ...ee.author, name: fixStr(ee.author.name) };
      if (Array.isArray(ee.fields)) ee.fields = ee.fields.map(f => {
        if (!f || typeof f !== 'object') return f;
        const ff = { ...f };
        if (typeof ff.name === 'string') ff.name = fixStr(ff.name).slice(0, 256);
        if (typeof ff.value === 'string') ff.value = fixStr(ff.value).slice(0, 1024);
        return ff;
      });
      return ee;
    });
  }
  return copy;
}

async function manualTriggerAutoMessage(interaction, ev, notif) {
  const { CONFIG_LOG_CHANNEL } = require('../utils/logChannels');
  const targetChannelId = config.testingMode ? CONFIG_LOG_CHANNEL : (notif.channelId || ev.channelId);
  if (!targetChannelId) throw new Error('No channel');
  const channel = await interaction.client.channels.fetch(targetChannelId).catch(()=>null);
  if (!channel) throw new Error('Channel not found');
  const { applyTimestampPlaceholders } = require('../utils/timestampPlaceholders');
  // TTL guard for rapid double-trigger from UI
  try {
    const { seenRecently } = require('../utils/sendOnce');
    const key = `manual:${ev.id}:${notif.id}:${targetChannelId}`;
    if (seenRecently(key, 7000)) return true; // treat as success, skip duplicate
  } catch {}
  if (notif.isClockIn) {
    // Build staff clock-in message to match the expected template
  const { ActionRowBuilder, StringSelectMenuBuilder } = require('discord.js');
    // Capacities per template and standardized labels
    const POSITIONS = [
      { key:'instance_manager', emoji:'🗝️', label:'Instance Manager', cap:1, short:'IM' },
      { key:'manager',          emoji:'🛠️', label:'Manager',          cap:5, short:'M' },
      { key:'bouncer',          emoji:'🛡️', label:'Bouncer',          cap:10, short:'B' },
      { key:'bartender',        emoji:'🍸', label:'Bartender',        cap:15, short:'BT' },
      { key:'backup',           emoji:'🎯', label:'Backup',           cap:20, short:'BK' },
      { key:'maybe',            emoji:'⏳', label:'Maybe/Late',        cap:50, short:'?' }
    ];
    ev.__clockIn = ev.__clockIn || { positions:{}, messageIds:[] };
    for (const p of POSITIONS) { if (!Array.isArray(ev.__clockIn.positions[p.key])) ev.__clockIn.positions[p.key] = []; }
    // Deduplication: if a clock-in message was sent in last 5 minutes, skip creating a new one
    try {
      const DEDUP_MS = 5 * 60 * 1000;
      if (ev.__clockIn.lastSentTs && (Date.now() - ev.__clockIn.lastSentTs) < DEDUP_MS) {
        // Still update skip window markers if manually triggered for clarity
        notif.__skipUntil = Date.now() + 60*60*1000;
        notif.lastManualTrigger = Date.now();
        updateEvent(ev.id, { autoMessages: ev.autoMessages, __clockIn: ev.__clockIn });
        return true; // treat as success without duplication
      }
    } catch {}
    // Helper: mention list (sanitized in testing)
    const fmtMentions = (arr=[]) => {
      if (!Array.isArray(arr) || arr.length === 0) return '*None*';
      const s = arr.map(id=>`<@${id}>`).join(', ');
      return config.testingMode ? s.replace(/<@&?\d+>/g, m=>`\`${m}\``) : s;
    };
    const nameSafe = ev.name || 'Event';
    // Build embed JSON per template
    const embedJson = {
      title: `🕒 Staff Clock In — ${nameSafe}`,
      description: "Please select your role below to clock in.\n\n**Instance Manager** is responsible for opening, managing and closing an instance.",
      color: 3447003,
      fields: [
        {
          name: '📝 Instance Manager (1 slot)',
          value: `${(ev.__clockIn.positions.instance_manager||[]).length} / 1\n${fmtMentions(ev.__clockIn.positions.instance_manager)}`,
          inline: false
        },
        { name: '🛠️ Manager',   value: fmtMentions(ev.__clockIn.positions.manager),   inline: true },
        { name: '🛡️ Bouncer',   value: fmtMentions(ev.__clockIn.positions.bouncer),   inline: true },
        { name: '🍸 Bartender', value: fmtMentions(ev.__clockIn.positions.bartender), inline: true },
        { name: '🎯 Backup',    value: fmtMentions(ev.__clockIn.positions.backup),    inline: true },
        { name: '⏳ Maybe / Late', value: fmtMentions(ev.__clockIn.positions.maybe), inline: false },
        {
          name: 'Eligible roles',
          value: '<@&1375995842858582096>, <@&1380277718091829368>, <@&1380323145621180466>, <@&1375958480380493844>'
        }
      ],
      footer: { text: `Late Night Hours | Staff clock in for ${nameSafe}` }
    };
    // Build select menu with option descriptions like "IM slots 1"
    const menu = new StringSelectMenuBuilder()
      .setCustomId(`clockin:${ev.id}:${notif.id}`)
      .setPlaceholder('📋 Select your position')
      .addOptions([
        { label: 'Instance Manager', value: 'instance_manager', description: '1 slot available', emoji: { name: '📝' } },
        { label: 'Manager',          value: 'manager',                              emoji: { name: '🛠️' } },
        { label: 'Bouncer',          value: 'bouncer',                              emoji: { name: '🛡️' } },
        { label: 'Bartender',        value: 'bartender',                            emoji: { name: '🍸' } },
        { label: 'Backup',           value: 'backup',                               emoji: { name: '🎯' } },
        { label: 'Maybe / Late',     value: 'maybe',                                emoji: { name: '⏳' } }
      ]);
  const row = new ActionRowBuilder().addComponents(menu);
  // Content intentionally empty; embed contains header/description
  const sent = await channel.send({ content: '', embeds:[embedJson], components:[row] }).catch(()=>null);
    if (sent && !config.testingMode) {
      notif.__skipUntil = Date.now() + 60*60*1000; // skip for an hour
      notif.lastManualTrigger = Date.now();
      ev.__clockIn.lastSentTs = Date.now();
      ev.__clockIn.channelId = channel.id;
      updateEvent(ev.id, { autoMessages: ev.autoMessages, __clockIn: ev.__clockIn });
    }
    return !!sent;
  }
  // If a JSON payload exists, prefer its content exclusively (even if empty),
  // and do NOT fall back to the raw JSON string saved in notif.message — otherwise
  // the JSON body gets echoed as plain text alongside the embed/components.
  let payload;
  if (notif.messageJSON && typeof notif.messageJSON === 'object') {
    const base = { ...notif.messageJSON };
    if (base.embeds && !Array.isArray(base.embeds)) base.embeds = [base.embeds];
    // Ensure there's some content fallback for empty JSON
    if (!base.content && !base.embeds) base.content = notif.message || `Auto message (${ev.name})`;
    payload = applyPlaceholdersToJsonPayload(base, ev);
  } else {
    let content = notif.message || '';
    content = applyTimestampPlaceholders(content, ev);
    if (config.testingMode) content = sanitizeMentionsForTesting(content);
    if (!content) content = `Auto message (${ev.name})`;
    payload = { content };
  }
  if (payload.embeds && !Array.isArray(payload.embeds)) payload.embeds = [payload.embeds];
  const sent = await channel.send(payload).catch(()=>null);
  // Optional auto-delete (non-testing, non-clock-in)
  try {
    const delMs = Number(notif.deleteAfterMs ?? (config.autoMessages?.defaultDeleteMs || 0));
    if (!config.testingMode && sent && delMs > 0) {
      setTimeout(() => { try { sent.delete().catch(()=>{}); } catch {} }, delMs);
    }
  } catch {}
  // Track for later refresh
  try {
    if (sent && sent.id) {
      const map = ev.__notifMsgs && typeof ev.__notifMsgs==='object' ? { ...ev.__notifMsgs } : {};
      const rec = map[notif.id] && typeof map[notif.id]==='object' ? { ...map[notif.id] } : { channelId: channel.id, ids: [] };
      rec.channelId = channel.id;
      rec.ids = Array.isArray(rec.ids) ? rec.ids : [];
      rec.ids.push(sent.id);
      if (rec.ids.length > 20) rec.ids = rec.ids.slice(-20);
      map[notif.id] = rec;
      updateEvent(ev.id, { __notifMsgs: map });
    }
  } catch {}
  if (sent && !config.testingMode) {
    notif.__skipUntil = Date.now() + 60*60*1000;
    notif.lastManualTrigger = Date.now();
    updateEvent(ev.id, { autoMessages: ev.autoMessages });
  }
  return !!sent;
}

ActiveMenus.registerHandler('events', async (interaction, session) => {
  if (interaction.user.id !== OWNER_ID) return interaction.reply({ content: 'Not for you.', flags: 1<<6 });
  const data = session.data || {}; // { mode, currentId }
  const customId = interaction.customId;

  // Close button removed per request

  // Main actions
  if (customId === 'events_create') {
    const modal = new ModalBuilder().setCustomId(`event_create_modal_${interaction.message.id}`).setTitle('Create Event')
      .addComponents(
        new ActionRowBuilder().addComponents(new TextInputBuilder().setCustomId('name').setLabel('Name').setStyle(TextInputStyle.Short).setRequired(true)),
        new ActionRowBuilder().addComponents(new TextInputBuilder().setCustomId('channel').setLabel('Channel ID or #channel').setStyle(TextInputStyle.Short).setRequired(true)),
        new ActionRowBuilder().addComponents(new TextInputBuilder().setCustomId('times').setLabel('Times (HH:MM,comma)').setStyle(TextInputStyle.Short).setRequired(true)),
        new ActionRowBuilder().addComponents(new TextInputBuilder().setCustomId('days').setLabel('Days (Sun,Mon,...)').setStyle(TextInputStyle.Short).setRequired(true)),
        new ActionRowBuilder().addComponents(new TextInputBuilder().setCustomId('message').setLabel('Message').setStyle(TextInputStyle.Paragraph).setRequired(true))
      );
    await interaction.showModal(modal); return;
  }
  if (customId === 'events_select_mode') {
    data.mode = 'select';
    await interaction.update({ embeds: [buildMainEmbed(interaction.guild)], components: buildSelectRows('select') });
    session.data = data; return;
  }
  if (customId === 'events_delete_mode') {
    data.mode = 'delete';
    await interaction.update({ embeds: [buildMainEmbed(interaction.guild)], components: buildSelectRows('delete') });
    session.data = data; return;
  }
  if (customId === 'events_back') {
    data.mode = 'main'; data.currentId = null;
    await interaction.update({ embeds: [buildMainEmbed(interaction.guild)], components: mainRows() });
    session.data = data; return;
  }

  // Detail actions
  if (customId.startsWith('events_toggle_')) {
    const id = customId.split('_').pop();
  const ev = getEvent(id); if (!ev) return interaction.reply({ content: 'Missing event.', flags: 1<<6 });
    const updated = updateEvent(id, { enabled: !ev.enabled });
    await interaction.update({ embeds: [buildDetailEmbed(interaction.guild, updated)], components: detailRows(updated) });
    return;
  }
  if (customId.startsWith('events_edit_times_')) {
    const id = customId.split('_').pop();
  const ev = getEvent(id); if (!ev) return interaction.reply({ content: 'Missing event.', flags: 1<<6 });
    const modal = new ModalBuilder().setCustomId(`event_times_modal_${id}_${interaction.message.id}`).setTitle('Edit Times')
  .addComponents(new ActionRowBuilder().addComponents(new TextInputBuilder().setCustomId('times').setLabel('Times (HH:MM or HH:MM-HH:MM, comma)').setStyle(TextInputStyle.Paragraph).setRequired(true).setValue((ev.times||[]).join(','))));
    await interaction.showModal(modal); return;
  }
  if (customId.startsWith('events_edit_days_')) {
    const id = customId.split('_').pop();
  const ev = getEvent(id); if (!ev) return interaction.reply({ content: 'Missing event.', flags: 1<<6 });
    const modal = new ModalBuilder().setCustomId(`event_days_modal_${id}_${interaction.message.id}`).setTitle('Edit Days')
      .addComponents(new ActionRowBuilder().addComponents(new TextInputBuilder().setCustomId('days').setLabel('Days (Sun,Mon,...)').setStyle(TextInputStyle.Short).setRequired(true).setValue((ev.days||[]).map(d=>DAY_NAMES[d]||d).join(','))));
    await interaction.showModal(modal); return;
  }
  if (customId.startsWith('events_edit_msg_')) {
    const id = customId.split('_').pop();
  const ev = getEvent(id); if (!ev) return interaction.reply({ content: 'Missing event.', flags: 1<<6 });
    const modal = new ModalBuilder().setCustomId(`event_msg_modal_${id}_${interaction.message.id}`).setTitle('Edit Message')
      .addComponents(new ActionRowBuilder().addComponents(new TextInputBuilder().setCustomId('message').setLabel('Message Content').setStyle(TextInputStyle.Paragraph).setRequired(true).setValue(ev.message || '')));
    await interaction.showModal(modal); return;
  }
  if (customId.startsWith('events_notifs_')) {
    const id = customId.split('_').pop();
  const ev = getEvent(id); if (!ev) return interaction.reply({ content: 'Missing event.', flags:1<<6 });
    if (!Array.isArray(ev.autoMessages)) updateEvent(ev.id, { autoMessages: [] });
    await interaction.update({ embeds: [buildNotifsEmbed(interaction.guild, getEvent(id))], components: notifManagerRows(ev) });
    return;
  }
  if (customId.startsWith('event_notif_back_')) {
    const id = customId.split('_').pop();
  const ev = getEvent(id); if (!ev) return interaction.reply({ content:'Missing event.', flags:1<<6 });
    await interaction.update({ embeds: [buildDetailEmbed(interaction.guild, ev)], components: detailRows(ev) });
    return;
  }
  if (customId.startsWith('event_notif_add_')) {
    const id = customId.split('_').pop();
  const ev = getEvent(id); if (!ev) return interaction.reply({ content:'Missing event.', flags:1<<6 });
    const modal = new ModalBuilder().setCustomId(`notif_add_modal_${id}_${interaction.message.id}`).setTitle('Add Auto Message')
      .addComponents(
        new ActionRowBuilder().addComponents(new TextInputBuilder().setCustomId('channel').setLabel('Channel ID (blank=event)').setStyle(TextInputStyle.Short).setRequired(false).setPlaceholder(ev.channelId||'')),
  new ActionRowBuilder().addComponents(new TextInputBuilder().setCustomId('offset').setLabel('When before start? (e.g. 15m, 1h, 2h30m)').setStyle(TextInputStyle.Short).setRequired(true).setValue('5m')),
        new ActionRowBuilder().addComponents(new TextInputBuilder().setCustomId('message').setLabel('Message / JSON').setStyle(TextInputStyle.Paragraph).setRequired(true))
      );
    await interaction.showModal(modal); return;
  }
  if (customId.startsWith('event_notif_edit_')) {
    const parts = customId.split('_');
    const evId = parts[3]; const notifId = parts[4];
  const ev = getEvent(evId); if (!ev) return interaction.reply({ content:'Missing event.', flags:1<<6 });
    const notif = (ev.autoMessages||[]).find(n=>String(n.id)===String(notifId));
  if (!notif) return interaction.reply({ content:'Not found.', flags:1<<6 });
  // Compute a suggested TTL string based on current value (per-notif or default)
  const currentTTL = Number.isFinite(notif.deleteAfterMs) ? notif.deleteAfterMs : (config.autoMessages?.defaultDeleteMs || 0);
  const suggestTTL = currentTTL<=0 ? '0' : (currentTTL%3600000===0 ? `${Math.floor(currentTTL/3600000)}h` : (currentTTL%60000===0 ? `${Math.floor(currentTTL/60000)}m` : `${Math.max(1,Math.floor(currentTTL/1000))}s`));
    const modal = new ModalBuilder().setCustomId(`notif_edit_modal_${evId}_${notifId}_${interaction.message.id}`).setTitle('Edit Auto Message')
      .addComponents(
        new ActionRowBuilder().addComponents(new TextInputBuilder().setCustomId('channel').setLabel('Channel ID (blank=event)').setStyle(TextInputStyle.Short).setRequired(false).setValue(notif.channelId||'')),
        new ActionRowBuilder().addComponents(new TextInputBuilder().setCustomId('offset').setLabel('When before start? (e.g. 10m, 2h)').setStyle(TextInputStyle.Short).setRequired(true).setValue(notif.offsetMinutes? `${notif.offsetMinutes}m` : 'start')),
        new ActionRowBuilder().addComponents(new TextInputBuilder().setCustomId('deleteafter').setLabel('Delete after (e.g. 10m, 2h, 0=disable)').setStyle(TextInputStyle.Short).setRequired(true).setValue(suggestTTL)),
        new ActionRowBuilder().addComponents(new TextInputBuilder().setCustomId('message').setLabel('Message / JSON').setStyle(TextInputStyle.Paragraph).setRequired(true).setValue(notif.message || (notif.messageJSON? JSON.stringify(notif.messageJSON,null,2):'')))
      );
    await interaction.showModal(modal); return;
  }
  if (customId.startsWith('event_notif_edit_channel_')) {
    const parts = customId.split('_');
    const evId = parts[4]; const notifId = parts[5];
  const ev = getEvent(evId); if (!ev) return interaction.reply({ content:'Missing event.', flags:1<<6 });
    const notif = (ev.autoMessages||[]).find(n=>String(n.id)===String(notifId));
  if (!notif) return interaction.reply({ content:'Not found.', flags:1<<6 });
    const modal = new ModalBuilder().setCustomId(`notif_channel_modal_${evId}_${notifId}_${interaction.message.id}`).setTitle('Edit Channel')
      .addComponents(new ActionRowBuilder().addComponents(new TextInputBuilder().setCustomId('channel').setLabel('Channel ID (blank=event)').setStyle(TextInputStyle.Short).setRequired(false).setValue(notif.channelId||'')));
    await interaction.showModal(modal); return;
  }
  if (customId.startsWith('event_notif_selectmode_')) {
    const id = customId.split('_').pop();
  const ev = getEvent(id); if (!ev) return interaction.reply({ content:'Missing event.', flags:1<<6 });
    await interaction.update({ embeds: [buildNotifsEmbed(interaction.guild, ev)], components: notifSelectRows(ev) });
    return;
  }
  if (customId.startsWith('event_notif_cancel_')) {
    const id = customId.split('_').pop();
  const ev = getEvent(id); if (!ev) return interaction.reply({ content:'Missing event.', flags:1<<6 });
    await interaction.update({ embeds: [buildNotifsEmbed(interaction.guild, ev)], components: notifManagerRows(ev) });
    return;
  }
  if (customId.startsWith('event_notif_toggle_')) {
    const parts = customId.split('_');
    const evId = parts[3]; const notifId = parts[4];
  const ev = getEvent(evId); if (!ev) return interaction.reply({ content:'Missing event.', flags:1<<6 });
    const list = Array.isArray(ev.autoMessages)? [...ev.autoMessages]:[];
    const idx = list.findIndex(n=>String(n.id)===String(notifId));
  if (idx===-1) return interaction.reply({ content:'Not found.', flags:1<<6 });
    list[idx].enabled = !list[idx].enabled;
    updateEvent(ev.id, { autoMessages: list });
    await interaction.update({ embeds:[buildNotifDetailEmbed(interaction.guild, getEvent(evId), list[idx])], components: notifDetailRows(ev, list[idx]) });
    return;
  }
  if (customId.startsWith('event_notif_clockin_')) {
  // Removed: legacy clock-in toggle disabled
  return interaction.reply({ content:'Clock-In toggle removed. To designate a clock-in message, set isClockIn in data manually if still needed.', flags:1<<6 }).catch(()=>{});
  }
  if (customId.startsWith('event_notif_trigger_')) {
    const parts = customId.split('_');
    const evId = parts[3]; const notifId = parts[4];
  const ev = getEvent(evId); if (!ev) return interaction.reply({ content:'Missing event.', flags:1<<6 });
    const notif = (ev.autoMessages||[]).find(n=>String(n.id)===String(notifId));
  if (!notif) return interaction.reply({ content:'Not found.', flags:1<<6 });
    try {
      const sentOk = await manualTriggerAutoMessage(interaction, ev, notif);
      if (sentOk) {
  await interaction.reply({ content: `✅ Triggered auto message #${notif.id}${config.testingMode?' (testing mode output only)':''}.`, flags:1<<6 }).catch(()=>{});
      } else {
  await interaction.reply({ content: '❌ Failed to send message.', flags:1<<6 }).catch(()=>{});
      }
    } catch (e) {
  await interaction.reply({ content: '❌ Error: '+(e.message||e), flags:1<<6 }).catch(()=>{});
    }
    return;
  }
  if (customId.startsWith('event_notif_edit_offset_')) {
    const parts = customId.split('_');
    const evId = parts[4]; const notifId = parts[5];
  const ev = getEvent(evId); if (!ev) return interaction.reply({ content:'Missing event.', flags:1<<6 });
    const notif = (ev.autoMessages||[]).find(n=>String(n.id)===String(notifId));
  if (!notif) return interaction.reply({ content:'Not found.', flags:1<<6 });
    const modal = new ModalBuilder().setCustomId(`notif_offset_modal_${evId}_${notifId}_${interaction.message.id}`).setTitle('Edit Offset')
      .addComponents(new ActionRowBuilder().addComponents(new TextInputBuilder().setCustomId('offset').setLabel('Minutes BEFORE (0=start)').setStyle(TextInputStyle.Short).setRequired(true).setValue(String(notif.offsetMinutes||0))));
    await interaction.showModal(modal); return;
  }
  if (customId.startsWith('event_notif_edit_msg_')) {
    const parts = customId.split('_');
    const evId = parts[4]; const notifId = parts[5];
  const ev = getEvent(evId); if (!ev) return interaction.reply({ content:'Missing event.', flags:1<<6 });
    const notif = (ev.autoMessages||[]).find(n=>String(n.id)===String(notifId));
  if (!notif) return interaction.reply({ content:'Not found.', flags:1<<6 });
    const modal = new ModalBuilder().setCustomId(`notif_msg_modal_${evId}_${notifId}_${interaction.message.id}`).setTitle('Edit Auto Message')
      .addComponents(new ActionRowBuilder().addComponents(new TextInputBuilder().setCustomId('message').setLabel('Message / JSON').setStyle(TextInputStyle.Paragraph).setRequired(true).setValue(notif.message || (notif.messageJSON? JSON.stringify(notif.messageJSON,null,2):''))));
    await interaction.showModal(modal); return;
  }
  if (customId.startsWith('event_notif_edit_ttl_')) {
    const parts = customId.split('_');
    const evId = parts[4]; const notifId = parts[5];
    const ev = getEvent(evId); if (!ev) return interaction.reply({ content:'Missing event.', flags:1<<6 });
    const notif = (ev.autoMessages||[]).find(n=>String(n.id)===String(notifId));
    if (!notif) return interaction.reply({ content:'Not found.', flags:1<<6 });
    const current = Number.isFinite(notif.deleteAfterMs) ? notif.deleteAfterMs : (config.autoMessages?.defaultDeleteMs || 0);
    const suggest = current<=0 ? '0' : (current%3600000===0 ? `${Math.floor(current/3600000)}h` : (current%60000===0 ? `${Math.floor(current/60000)}m` : `${Math.max(1,Math.floor(current/1000))}s`));
    const modal = new ModalBuilder().setCustomId(`notif_deleteafter_modal_${evId}_${notifId}_${interaction.message.id}`).setTitle('Delete After')
      .addComponents(new ActionRowBuilder().addComponents(new TextInputBuilder().setCustomId('deleteafter').setLabel('Delete after (e.g. 10m, 2h, 0=disable)').setStyle(TextInputStyle.Short).setRequired(true).setValue(suggest)));
    await interaction.showModal(modal); return;
  }
  if (customId.startsWith('event_notif_delete_')) {
    const parts = customId.split('_');
    const evId = parts[4]; const notifId = parts[5];
  const ev = getEvent(evId); if (!ev) return interaction.reply({ content:'Missing event.', flags:1<<6 });
    const list = (ev.autoMessages||[]).filter(n=>String(n.id)!==String(notifId));
    updateEvent(ev.id, { autoMessages: list });
    await interaction.update({ embeds:[buildNotifsEmbed(interaction.guild, getEvent(evId))], components: notifManagerRows(getEvent(evId)) });
    return;
  }
  if (customId.startsWith('events_delete_')) {
    const id = customId.split('_').pop();
  const ev = getEvent(id); if (!ev) return interaction.reply({ content: 'Missing event.', flags: 1<<6 });
    removeEvent(id);
    data.mode = 'main'; data.currentId = null;
    await interaction.update({ embeds: [buildMainEmbed(interaction.guild)], components: mainRows() });
    return;
  }
  if (customId.startsWith('events_edit_')) {
    const id = customId.split('_').pop();
  const ev = getEvent(id); if (!ev) return interaction.reply({ content: 'Missing event.', flags: 1<<6 });
    const modal = new ModalBuilder().setCustomId(`event_edit_modal_${id}_${interaction.message.id}`).setTitle('Edit Event')
      .addComponents(
        new ActionRowBuilder().addComponents(new TextInputBuilder().setCustomId('name').setLabel('Name').setStyle(TextInputStyle.Short).setRequired(true).setValue(ev.name || '')),
        new ActionRowBuilder().addComponents(new TextInputBuilder().setCustomId('channel').setLabel('Channel ID').setStyle(TextInputStyle.Short).setRequired(true).setValue(ev.channelId || '')),
        new ActionRowBuilder().addComponents(new TextInputBuilder().setCustomId('times').setLabel('Times (HH:MM or HH:MM-HH:MM, comma)').setStyle(TextInputStyle.Paragraph).setRequired(true).setValue((ev.times||[]).join(','))),
        new ActionRowBuilder().addComponents(new TextInputBuilder().setCustomId('days').setLabel('Days (Sun,Mon,...)').setStyle(TextInputStyle.Short).setRequired(true).setValue((ev.days||[]).map(d=>DAY_NAMES[d]||d).join(','))),
        new ActionRowBuilder().addComponents(new TextInputBuilder().setCustomId('message').setLabel('Message / JSON').setStyle(TextInputStyle.Paragraph).setRequired(true).setValue(ev.message || (ev.messageJSON? JSON.stringify(ev.messageJSON,null,2):'')))
      );
    await interaction.showModal(modal); return;
  }

  // Select menus
  if (interaction.isStringSelectMenu()) {
    if (customId === 'events_select') {
      const id = interaction.values[0];
  const ev = getEvent(id); if (!ev) return interaction.reply({ content: 'Not found.', flags: 1<<6 });
      data.mode = 'detail'; data.currentId = id;
      await interaction.update({ embeds: [buildDetailEmbed(interaction.guild, ev)], components: detailRows(ev) });
      return;
    }
    if (customId === 'events_delete') {
      const id = interaction.values[0];
  const ev = getEvent(id); if (!ev) return interaction.reply({ content: 'Not found.', flags: 1<<6 });
      removeEvent(id);
      // Stay in delete mode or back to main if empty
      const evs = getEvents();
      if (!evs.length) {
        data.mode = 'main';
        await interaction.update({ embeds: [buildMainEmbed(interaction.guild)], components: mainRows() });
      } else {
        await interaction.update({ embeds: [buildMainEmbed(interaction.guild)], components: buildSelectRows('delete') });
      }
      return;
    }
    if (customId.startsWith('event_notif_select_')) {
      const evId = customId.split('_').pop();
  const ev = getEvent(evId); if (!ev) return interaction.reply({ content:'Missing event.', flags:1<<6 });
      const notifId = interaction.values[0];
      const notif = (ev.autoMessages||[]).find(n=>String(n.id)===String(notifId));
  if (!notif) return interaction.reply({ content:'Not found.', flags:1<<6 });
      await interaction.update({ embeds:[buildNotifDetailEmbed(interaction.guild, ev, notif)], components: notifDetailRows(ev, notif) });
      return;
    }
  }
});

async function handleEventEditModal(interaction) {
  if (!interaction.isModalSubmit()) return;
  if (!/^event_(times|days|msg|edit)_modal_/.test(interaction.customId)) return;
  // Notification modals handled separately below
  // pattern: event_<kind>_modal_<eventId>[_<managerMessageId>]
  const parts = interaction.customId.split("_");
  const eventId = parts[3];
  const managerMessageId = parts[4] || null;
  if (!/^\d+$/.test(eventId)) { await interaction.reply({ content: '❌ Bad event id.', flags: 1<<6 }).catch(()=>{}); return; }
  const ev = getEvent(eventId);
  if (!ev) { await interaction.reply({ content: "Event not found.", flags:1<<6 }); return; }
  let updatedEv = null;
  if (interaction.customId.startsWith("event_times_modal_")) {
    const raw = interaction.fields.getTextInputValue("times");
    const times = raw.split(/[\,\s]+/).map(t=>t.trim()).filter(Boolean);
  const ranges = times.map(t => t.includes('-') ? (()=>{ const [s,e]=t.split('-').map(x=>x.trim()); return { start:s, end:e };})() : null).filter(Boolean);
  if (!times.length) { await interaction.reply({ content: "❌ Provide times.", flags:1<<6 }); return; }
  updatedEv = updateEvent(ev.id, { times, ranges });
  await interaction.reply({ content: "✅ Times updated.", flags:1<<6 });
  } else if (interaction.customId.startsWith("event_days_modal_")) {
    const raw = interaction.fields.getTextInputValue("days");
    const dayMap = { sun:0, sunday:0, mon:1, monday:1, tue:2, tuesday:2, wed:3, wednesday:3, thu:4, thursday:4, fri:5, friday:5, sat:6, saturday:6 };
    const days = raw.split(/[\,\s]+/).map(d=>d.trim().toLowerCase()).filter(Boolean).map(d=>dayMap[d]).filter(d=>d!==undefined);
  if (!days.length) { await interaction.reply({ content: "❌ Invalid days.", flags:1<<6 }); return; }
    updatedEv = updateEvent(ev.id, { days });
  await interaction.reply({ content: "✅ Days updated.", flags:1<<6 });
  } else if (interaction.customId.startsWith("event_msg_modal_")) {
    const messageContent = interaction.fields.getTextInputValue("message");
    let messageJSON = null;
    const cleaned = messageContent.replace(/^```(json)?/i, '').replace(/```$/,'').trim();
    if (cleaned.startsWith('{') && cleaned.endsWith('}')) {
      try {
        const parsed = JSON.parse(cleaned);
        if (parsed && typeof parsed === 'object') messageJSON = parsed;
      } catch { /* ignore */ }
    }
    updatedEv = updateEvent(ev.id, { message: messageContent, messageJSON });
  await interaction.reply({ content: `✅ Message updated${messageJSON ? ' (JSON payload detected)' : ''}.`, flags:1<<6 });
  } else if (interaction.customId.startsWith("event_edit_modal_")) {
    const name = interaction.fields.getTextInputValue('name').trim();
    let channelId = interaction.fields.getTextInputValue('channel').trim().replace(/[<#>]/g,'');
    const timesRaw = interaction.fields.getTextInputValue('times').trim();
    const daysRaw = interaction.fields.getTextInputValue('days').trim();
    const messageContent = interaction.fields.getTextInputValue('message');
    const times = timesRaw.split(/[\,\s]+/).map(t=>t.trim()).filter(Boolean);
    const ranges = times.map(t => t.includes('-') ? (()=>{ const [s,e]=t.split('-').map(x=>x.trim()); return { start:s, end:e };})() : null).filter(Boolean);
    const dayMap = { sun:0, sunday:0, mon:1, monday:1, tue:2, tuesday:2, wed:3, wednesday:3, thu:4, thursday:4, fri:5, friday:5, sat:6, saturday:6 };
    const days = daysRaw.split(/[\,\s]+/).map(d=>d.trim().toLowerCase()).filter(Boolean).map(d=>dayMap[d]).filter(d=>d!==undefined);
  if (!name) return interaction.reply({ content: '❌ Name required.', flags:1<<6 });
  if (!/^\d{1,32}$/.test(channelId)) return interaction.reply({ content: '❌ Invalid channel id.', flags:1<<6 });
  if (!times.length) return interaction.reply({ content: '❌ Provide times.', flags:1<<6 });
  if (!days.length) return interaction.reply({ content: '❌ Invalid days.', flags:1<<6 });
    let messageJSON = null;
    const cleaned = messageContent.replace(/^```(json)?/i, '').replace(/```$/,'').trim();
    if (cleaned.startsWith('{') && cleaned.endsWith('}')) {
      try {
        const parsed = JSON.parse(cleaned);
        if (parsed && typeof parsed === 'object') messageJSON = parsed;
      } catch {}
    }
    updatedEv = updateEvent(ev.id, { name, channelId, times, ranges, days, message: messageContent, messageJSON, dynamicBaseContent: messageJSON?.content || messageContent });
    // Auto anchor create/update
    try { await ensureAnchor(interaction, updatedEv, { content: messageJSON?.content || messageContent }); } catch {}
  await interaction.reply({ content: `✅ Event updated${messageJSON? ' (JSON payload detected)':''}.`, flags:1<<6 });
  }
  if (managerMessageId && updatedEv) {
    try {
      const mgrMsg = await interaction.channel.messages.fetch(managerMessageId).catch(() => null);
      if (mgrMsg) {
        const isDetail = mgrMsg.components.some(r => r.components.some(c => c.customId === `events_toggle_${updatedEv.id}`));
        if (isDetail) {
          await mgrMsg.edit({ embeds: [buildDetailEmbed(interaction.guild, updatedEv)], components: detailRows(updatedEv) }).catch(() => {});
        } else {
          await mgrMsg.edit({ embeds: [buildMainEmbed(interaction.guild)], components: mainRows() }).catch(() => {});
        }
      }
    } catch {}
  }
}

async function handleEventNotificationModal(interaction) {
  if (!interaction.isModalSubmit()) return;
  if (!/^(notif_(add|offset|msg|channel|edit)_modal_)/.test(interaction.customId)) return;
  if (!/^(notif_(add|offset|msg|channel|edit|deleteafter)_modal_)/.test(interaction.customId)) return;
  const parts = interaction.customId.split('_');
  // Patterns:
  // notif_add_modal_<eventId>_<managerMessageId>
  // notif_offset_modal_<eventId>_<notifId>_<managerMessageId>
  // notif_msg_modal_<eventId>_<notifId>_<managerMessageId>
  // notif_channel_modal_<eventId>_<notifId>_<managerMessageId>
  // notif_edit_modal_<eventId>_<notifId>_<managerMessageId>
  const kind = parts[1];
  const evId = parts[3];
  const notifId = (kind==='add') ? null : parts[4];
  const managerMessageId = (kind==='add') ? parts[4] : parts[5];
  const ev = getEvent(evId);
  if (!ev) { await interaction.reply({ content:'Event missing.', flags:1<<6 }).catch(()=>{}); return; }
  const healJSON = (txt) => txt.replace(/^```(json)?/i,'').replace(/```$/,'').trim().replace(/,\s*([}\]])/g,'$1');
  let updatedEv = null;
  if (kind==='add') {
    const offsetRaw = interaction.fields.getTextInputValue('offset');
    let offset = parseOffsetInput(offsetRaw);
    const msgRaw = interaction.fields.getTextInputValue('message');
    const chanRaw = (interaction.fields.getTextInputValue('channel')||'').trim();
    let msgChannelId = chanRaw.replace(/[<#>]/g,'');
  if (msgChannelId && !/^\d{1,32}$/.test(msgChannelId)) { return interaction.reply({ content:'❌ Invalid channel id.', flags:1<<6 }).catch(()=>{}); }
    let messageJSON = null;
    const healed = healJSON(msgRaw);
    if (healed.startsWith('{') && healed.endsWith('}')) { try { const parsed = JSON.parse(healed); if (parsed && typeof parsed==='object') messageJSON = parsed; } catch {} }
    const list = Array.isArray(ev.autoMessages)? [...ev.autoMessages]:[];
    const nextId = String(ev.nextAutoId || 1);
    const entry = { id: nextId, offsetMinutes: offset, enabled: true, message: msgRaw, messageJSON };
    if (msgChannelId) entry.channelId = msgChannelId;
    list.push(entry);
    updatedEv = updateEvent(ev.id, { autoMessages: list, nextAutoId: Number(nextId)+1 });
  await interaction.reply({ content:`✅ Auto message #${nextId} created${messageJSON?' (JSON)':''}.`, flags:1<<6 }).catch(()=>{});
  } else if (kind==='offset') {
    const offsetRaw = interaction.fields.getTextInputValue('offset');
    let offset = parseOffsetInput(offsetRaw);
    const list = Array.isArray(ev.autoMessages)? [...ev.autoMessages]:[];
    const idx = list.findIndex(n=>String(n.id)===String(notifId));
  if (idx===-1) return interaction.reply({ content:'Not found.', flags:1<<6 });
    list[idx].offsetMinutes = offset;
    updatedEv = updateEvent(ev.id, { autoMessages: list });
  await interaction.reply({ content:`✅ Offset updated.`, flags:1<<6 }).catch(()=>{});
  } else if (kind==='msg') {
    const msgRaw = interaction.fields.getTextInputValue('message');
    const list = Array.isArray(ev.autoMessages)? [...ev.autoMessages]:[];
    const idx = list.findIndex(n=>String(n.id)===String(notifId));
  if (idx===-1) return interaction.reply({ content:'Not found.', flags:1<<6 });
    let messageJSON = null; const healed = healJSON(msgRaw); if (healed.startsWith('{') && healed.endsWith('}')) { try { const parsed = JSON.parse(healed); if (parsed && typeof parsed==='object') messageJSON = parsed; } catch {} }
    list[idx].message = msgRaw; list[idx].messageJSON = messageJSON;
    updatedEv = updateEvent(ev.id, { autoMessages: list });
  await interaction.reply({ content:`✅ Message updated${messageJSON?' (JSON)':''}.`, flags:1<<6 }).catch(()=>{});
  } else if (kind==='channel') {
    const chanRaw = (interaction.fields.getTextInputValue('channel')||'').trim();
    const list = Array.isArray(ev.autoMessages)? [...ev.autoMessages]:[];
    const idx = list.findIndex(n=>String(n.id)===String(notifId));
  if (idx===-1) return interaction.reply({ content:'Not found.', flags:1<<6 });
    const cleaned = chanRaw.replace(/[<#>]/g,'');
  if (cleaned && !/^\d{1,32}$/.test(cleaned)) return interaction.reply({ content:'❌ Invalid channel id.', flags:1<<6 });
    if (cleaned) list[idx].channelId = cleaned; else delete list[idx].channelId;
    updatedEv = updateEvent(ev.id, { autoMessages: list });
  await interaction.reply({ content:`✅ Channel ${cleaned? 'updated':'reset to event channel'}.`, flags:1<<6 }).catch(()=>{});
  } else if (kind==='edit') {
    const list = Array.isArray(ev.autoMessages)? [...ev.autoMessages]:[];
    const idx = list.findIndex(n=>String(n.id)===String(notifId));
  if (idx===-1) return interaction.reply({ content:'Not found.', flags:1<<6 });
    const chanRaw = (interaction.fields.getTextInputValue('channel')||'').trim();
    const cleanedChan = chanRaw.replace(/[<#>]/g,'');
  if (cleanedChan && !/^\d{1,32}$/.test(cleanedChan)) return interaction.reply({ content:'❌ Invalid channel id.', flags:1<<6 });
    const offsetRaw = interaction.fields.getTextInputValue('offset');
    let offset = parseOffsetInput(offsetRaw);
  const deleteAfterRaw = interaction.fields.getTextInputValue('deleteafter');
  const deleteAfterMs = parseDeleteAfterMs(deleteAfterRaw);
    const msgRaw = interaction.fields.getTextInputValue('message');
    let messageJSON = null; const healed = healJSON(msgRaw); if (healed.startsWith('{') && healed.endsWith('}')) { try { const parsed = JSON.parse(healed); if (parsed && typeof parsed==='object') messageJSON = parsed; } catch {} }
    const entry = list[idx];
    const newList = list.map(entry => {
      const e = { ...entry };
      e.offsetMinutes = offset;
      e.message = msgRaw;
      e.messageJSON = messageJSON;
      e.deleteAfterMs = deleteAfterMs;
      if (cleanedChan) e.channelId = cleanedChan; else delete e.channelId;
      return e;
    });
    updatedEv = updateEvent(ev.id, { autoMessages: newList });
    console.log(`[Events] Updated all auto messages for event ${ev.id} (${ev.name}).`);
    await interaction.reply({ content:`✅ Auto messages updated for this event.`, flags:1<<6 }).catch(()=>{});
  // Refresh previously tracked auto messages for the event (and clock-in embeds)
  try { await refreshTrackedAutoMessages(interaction.client, updatedEv); } catch {}
  } else if (kind==='deleteafter') {
    // Modal id pattern: notif_deleteafter_modal_<eventId>_<notifId>_<managerMessageId>
    const list = Array.isArray(ev.autoMessages)? [...ev.autoMessages]:[];
    const idx = list.findIndex(n=>String(n.id)===String(notifId));
    if (idx===-1) return interaction.reply({ content:'Not found.', flags:1<<6 });
    const raw = interaction.fields.getTextInputValue('deleteafter');
    const msVal = parseDeleteAfterMs(raw);
    list[idx].deleteAfterMs = msVal;
    const updated = updateEvent(ev.id, { autoMessages: list });
    await interaction.reply({ content:`✅ Delete-after ${msVal>0? 'set to '+humanizeMs(msVal):'disabled'}.`, flags:1<<6 }).catch(()=>{});
    // Try to refresh the manager message if present
    if (managerMessageId) {
      try {
        const mgrMsg = await interaction.channel.messages.fetch(managerMessageId).catch(()=>null);
        if (mgrMsg) await mgrMsg.edit({ embeds:[buildNotifDetailEmbed(interaction.guild, updated, list[idx])], components: notifDetailRows(updated, list[idx]) }).catch(()=>{});
      } catch {}
    }
  }
  if (managerMessageId && updatedEv) {
    try {
      const channel = interaction.channel;
      const mgrMsg = await channel.messages.fetch(managerMessageId).catch(()=>null);
      if (mgrMsg) {
        // Determine whether we are in notifs manager or detail or event detail
        if (mgrMsg.components.some(r=>r.components.some(c=>c.customId?.startsWith('event_notif_')))) {
          // refresh auto msgs manager
          await mgrMsg.edit({ embeds:[buildNotifsEmbed(interaction.guild, updatedEv)], components: notifManagerRows(updatedEv) }).catch(()=>{});
        } else if (mgrMsg.components.some(r=>r.components.some(c=>c.customId===`events_toggle_${updatedEv.id}`))) {
          await mgrMsg.edit({ embeds:[buildDetailEmbed(interaction.guild, updatedEv)], components: detailRows(updatedEv) }).catch(() => {});
        }
      }
    } catch {}
  }
}

// Refresh helper: edits recently-tracked messages to match the latest event/notif definitions
async function refreshTrackedAutoMessages(client, ev) {
  try {
    // Regular auto messages
    const map = ev.__notifMsgs && typeof ev.__notifMsgs==='object' ? ev.__notifMsgs : null;
    if (map && Array.isArray(ev.autoMessages)) {
      for (const notif of ev.autoMessages) {
        const rec = map[notif.id];
        if (!rec || !rec.channelId || !Array.isArray(rec.ids) || rec.ids.length===0) continue;
        const channel = await client.channels.fetch(rec.channelId).catch(()=>null);
        if (!channel || !channel.messages) continue;
        // Build fresh payload
        let payload;
        if (notif.messageJSON && typeof notif.messageJSON==='object') {
          const base = { ...notif.messageJSON };
          if (base.embeds && !Array.isArray(base.embeds)) base.embeds = [base.embeds];
          if (!base.content && !base.embeds) base.content = notif.message || `Auto message (${ev.name})`;
          payload = applyPlaceholdersToJsonPayload(base, ev);
        } else {
          const { applyTimestampPlaceholders } = require('../utils/timestampPlaceholders');
          let content = notif.message || `Auto message (${ev.name})`;
          content = applyTimestampPlaceholders(content, ev);
          if (config.testingMode) content = sanitizeMentionsForTesting(content);
          payload = { content };
        }
        // Edit last few tracked messages
        for (const mid of rec.ids.slice(-3)) {
          try { const msg = await channel.messages.fetch(mid).catch(()=>null); if (msg) await msg.edit(payload).catch(()=>{}); } catch {}
        }
      }
    }
    // Staff clock-in messages
    if (ev.__clockIn && Array.isArray(ev.__clockIn.messageIds) && ev.__clockIn.messageIds.length) {
      const chId = ev.__clockIn.channelId || ev.channelId;
      const channel = chId ? await client.channels.fetch(chId).catch(()=>null) : null;
      if (channel && channel.messages) {
        const fmtMentions = (arr=[]) => {
          if (!Array.isArray(arr) || arr.length === 0) return '*None*';
          const s = arr.map(id=>`<@${id}>`).join(', ');
          return config.testingMode ? s.replace(/<@&?\d+>/g, m=>`\`${m}\``) : s;
        };
        const nameSafe = ev.name || 'Event';
        const embed = {
          title: `🕒 Staff Clock In — ${nameSafe}`,
          description: 'Please select your role below to clock in.\n\n**Instance Manager** is responsible for opening, managing and closing an instance.',
          color: 3447003,
          fields: [
            { name: '📝 Instance Manager (1 slot)', value: `${(ev.__clockIn.positions?.instance_manager||[]).length} / 1\n${fmtMentions(ev.__clockIn.positions?.instance_manager)}`, inline: false },
            { name: '🛠️ Manager',   value: fmtMentions(ev.__clockIn.positions?.manager),   inline: true },
            { name: '🛡️ Bouncer',   value: fmtMentions(ev.__clockIn.positions?.bouncer),   inline: true },
            { name: '🍸 Bartender', value: fmtMentions(ev.__clockIn.positions?.bartender), inline: true },
            { name: '🎯 Backup',    value: fmtMentions(ev.__clockIn.positions?.backup),    inline: true },
            { name: '⏳ Maybe / Late', value: fmtMentions(ev.__clockIn.positions?.maybe), inline: false },
            { name: 'Eligible roles', value: '<@&1375995842858582096>, <@&1380277718091829368>, <@&1380323145621180466>, <@&1375958480380493844>' }
          ],
          footer: { text: `Late Night Hours | Staff clock in for ${nameSafe}` }
        };
        for (const mid of ev.__clockIn.messageIds.slice(-3)) {
          try { const msg = await channel.messages.fetch(mid).catch(()=>null); if (msg) await msg.edit({ content:'', embeds:[embed] }).catch(()=>{}); } catch {}
        }
      }
    }
  } catch {}
}

module.exports = { handleScheduleCommand, handleScheduleModal, handleEventCreateModal, handleEventEditModal, handleEventNotificationModal, ensureAnchor, manualTriggerAutoMessage, refreshTrackedAutoMessages };

```

===== FILE: commands/scripts.js =====
```javascript
const fs = require("fs");
const path = require("path");
const { EmbedBuilder, ActionRowBuilder, ButtonBuilder, ButtonStyle } = require("discord.js");
const { createEmbed } = require('../utils/embeds');
const theme = require("../utils/theme");
const { applyFooterWithPagination, paginationRow } = require("../utils/ui");
const ActiveMenus = require("../utils/activeMenus");

// Recursively collect .js files excluding common non-source folders
function walkForJS(dir, baseDir, out = []) {
  const entries = fs.readdirSync(dir, { withFileTypes: true });
  for (const e of entries) {
    if (e.name.startsWith(".")) continue; // skip hidden
    if (e.isDirectory()) {
      const skip = [
        "node_modules",
        ".git",
        ".vscode",
        "dist"
      ].includes(e.name);
      if (skip) continue;
      walkForJS(path.join(dir, e.name), baseDir, out);
    } else if (e.isFile() && e.name.toLowerCase().endsWith(".js")) {
      const abs = path.join(dir, e.name);
      const rel = path.relative(baseDir, abs).replace(/\\/g, "/");
      try {
        const content = fs.readFileSync(abs, "utf8");
        const lines = content.split(/\r?\n/).length;
        out.push({ file: rel, lines });
      } catch {}
    }
  }
  return out;
}

function chunk(arr, size) {
  const out = [];
  for (let i = 0; i < arr.length; i += size) out.push(arr.slice(i, i + size));
  return out;
}

function buildEmbed(guild, pageItems, page, totalPages, totalFiles, totalLines) {
  const desc = pageItems
    .map((it, idx) => `**${(page * 10) + idx + 1}.** ${it.file} — ${it.lines.toLocaleString()} line${it.lines === 1 ? "" : "s"}`)
    .join("\n");
  const embed = createEmbed({
    title: '📜 Scripts Leaderboard',
    description: desc || '*No .js files found*',
    color: theme.colors.primary
  });
  applyFooterWithPagination(embed, guild, { page: page + 1, totalPages, extra: `${totalFiles} files • ${totalLines.toLocaleString()} lines` });
  return embed;
}

async function handleScriptsCommand(client, message) {
  const baseDir = path.resolve(__dirname, "..");
  const files = walkForJS(baseDir, baseDir).sort((a, b) => b.lines - a.lines || a.file.localeCompare(b.file));
  const totalFiles = files.length;
  const totalLines = files.reduce((s, f) => s + f.lines, 0);
  const pages = chunk(files, 10);
  const totalPages = Math.max(1, pages.length);
  const page = 1;
  const embed = buildEmbed(message.guild, pages[page - 1] || [], page - 1, totalPages, totalFiles, totalLines);
  const row = paginationRow("scripts", page, totalPages);
  const close = new ActionRowBuilder().addComponents(
    new ButtonBuilder().setCustomId("scripts_close").setLabel("Close").setStyle(ButtonStyle.Danger)
  );
  const sent = await message.reply({ embeds: [embed], components: [row, close], allowedMentions: { repliedUser: false } }).catch(() => null);
  if (!sent) return;
  ActiveMenus.registerMessage(sent, { type: "scripts", userId: message.author.id, data: { files, totalFiles, totalLines, page, totalPages } });
}

ActiveMenus.registerHandler("scripts", async (interaction, session) => {
  if (!interaction.isButton()) return;
  if (interaction.user.id !== session.userId) { try { await interaction.reply({ content: "Not your session.", flags: 1<<6 }); } catch {} return; }
  if (interaction.customId === "scripts_close") {
    try { await interaction.update({ components: [] }); } catch {}
    return;
  }
  let { page, totalPages, files, totalFiles, totalLines } = session.data;
  if (interaction.customId === "scripts_prev") page = Math.max(1, page - 1);
  else if (interaction.customId === "scripts_next") page = Math.min(totalPages, page + 1);
  session.data.page = page;
  const pages = chunk(files, 10);
  const embed = buildEmbed(interaction.guild, pages[page - 1] || [], page - 1, totalPages, totalFiles, totalLines);
  const row = paginationRow("scripts", page, totalPages);
  const close = new ActionRowBuilder().addComponents(
    new ButtonBuilder().setCustomId("scripts_close").setLabel("Close").setStyle(ButtonStyle.Danger)
  );
  await interaction.update({ embeds: [embed], components: [row, close] }).catch(() => {});
});

module.exports = { handleScriptsCommand };

```

===== FILE: commands/snipes.js =====
```javascript
const { config } = require("../utils/storage");
const { EmbedBuilder } = require("discord.js");
const { createEmbed } = require('../utils/embeds');
const { EMOJI_SUCCESS, EMOJI_ERROR } = require("./moderation/replies");
const fs = require("fs/promises");
const SNIPES_FILE = "./config/snipes.json";

const snipes = new Map();
const lastSnipeMessage = new Map();
const lastSnipeEmbedData = new Map();
const deletedSnipes = new Set();

async function loadSnipes() {
  try {
    const raw = JSON.parse(await fs.readFile(SNIPES_FILE, "utf8"));
    for (const [channelId, snipe] of Object.entries(raw)) {
      snipe.expiresAt = snipe.timestamp + 2 * 60 * 60 * 1000;
      if (snipe.deleted) {
        deletedSnipes.add(channelId);
        if (snipe.embedData) lastSnipeEmbedData.set(channelId, snipe.embedData);
      } else if (snipe.expiresAt > Date.now()) {
        snipes.set(channelId, snipe);
        if (snipe.embedData) lastSnipeEmbedData.set(channelId, snipe.embedData);
      }
    }
  } catch (err) {
    // If file doesn't exist or is invalid, ignore
  }
}
loadSnipes();

async function saveSnipes() {
  const obj = {};
  for (const [channelId, snipe] of snipes.entries()) {
    obj[channelId] = { ...snipe, deleted: false, embedData: lastSnipeEmbedData.get(channelId) || null };
  }
  for (const channelId of deletedSnipes) {
    if (!obj[channelId]) {
      obj[channelId] = {
        deleted: true,
        embedData: lastSnipeEmbedData.get(channelId) || null
      };
    }
  }
  try {
    await fs.writeFile(SNIPES_FILE, JSON.stringify(obj, null, 2));
  } catch (err) {
    console.error(`[Snipes Error] Failed to save snipes:`, err);
  }
}

function formatTodayTime(date) {
  const d = new Date(date);
  const hours = d.getHours().toString().padStart(2, "0");
  const minutes = d.getMinutes().toString().padStart(2, "0");
  return `Today at ${hours}:${minutes}`;
}

function cleanupSnipes() {
  const now = Date.now();
  for (const [channelId, snipe] of snipes.entries()) {
    if (snipe.expiresAt < now) snipes.delete(channelId);
  }
  for (const [channelId, msg] of lastSnipeMessage.entries()) {
    if (!msg || (msg.createdTimestamp && now - msg.createdTimestamp > 2 * 60 * 60 * 1000)) {
      lastSnipeMessage.delete(channelId);
    }
  }
  for (const [channelId, embedData] of lastSnipeEmbedData.entries()) {
    if (embedData && embedData.timestamp && now - embedData.timestamp > 2 * 60 * 60 * 1000) {
      lastSnipeEmbedData.delete(channelId);
    }
  }
}
// Run periodic cleanup, but don't keep the process alive solely for this timer
const _snipeCleanupInterval = setInterval(cleanupSnipes, 60 * 1000);
if (typeof _snipeCleanupInterval.unref === "function") {
  _snipeCleanupInterval.unref();
}

async function handleSnipeCommands(client, message, command, args) {
  const content = message.content.toLowerCase();

  if (content === ".ds") {
    let replyMsg;
    if (snipes.has(message.channel.id) || deletedSnipes.has(message.channel.id)) {
      snipes.delete(message.channel.id);
      deletedSnipes.add(message.channel.id);
      await saveSnipes();
      replyMsg = await message.reply(`${EMOJI_SUCCESS} Snipe deleted!`);
      const snipeMsg = lastSnipeMessage.get(message.channel.id);
      if (snipeMsg && snipeMsg.editable) {
        try {
          const oldEmbed = snipeMsg.embeds?.[0];
          if (oldEmbed) {
            const newEmbed = EmbedBuilder.from(oldEmbed)
              .setDescription(`${EMOJI_ERROR} This snipe has been deleted.`)
              .setColor(0xff0000);
            await snipeMsg.edit({
              content: null,
              embeds: [newEmbed]
            });
          } else {
            await snipeMsg.edit({
              content: `${EMOJI_ERROR} This snipe has been deleted.`,
              embeds: []
            });
          }
        } catch (err) {
          console.error(`[Snipes Error] Failed to edit snipe message:`, err);
        }
      }
    } else {
      replyMsg = await message.reply(`${EMOJI_ERROR} No snipe to delete.`);
    }
    setTimeout(() => {
      replyMsg.delete().catch(() => {});
      message.delete().catch(() => {});
    }, 3000);
    return;
  }

  if (content === ".snipe" || content === ".s") {
    // Respect mode: whitelist uses snipingWhitelist, blacklist uses snipingChannelList
    if (config.snipeMode === "blacklist") {
      allowed = !config.snipingChannelList.includes(message.channel.id);
    } else {
      const list = Array.isArray(config.snipingWhitelist) ? config.snipingWhitelist : [];
      if (!list.includes(message.channel.id)) {
        return message.reply(`${EMOJI_ERROR} Cannot snipe in this channel!`);
      }
    }

    if (deletedSnipes.has(message.channel.id)) {
      const snipeMsg = lastSnipeMessage.get(message.channel.id);
      if (snipeMsg && snipeMsg.embeds?.[0]) {
        const deletedEmbed = EmbedBuilder.from(snipeMsg.embeds[0])
          .setDescription(`${EMOJI_ERROR} This snipe has been deleted.`)
          .setColor(0xff0000);
        return message.reply({ embeds: [deletedEmbed] });
      }
      const embedData = lastSnipeEmbedData.get(message.channel.id);
      if (embedData) {
        const deletedEmbed = new EmbedBuilder(embedData)
          .setDescription(`${EMOJI_ERROR} This snipe has been deleted.`)
          .setColor(0xff0000);
        return message.reply({ embeds: [deletedEmbed] });
      }
      return message.reply(`${EMOJI_ERROR} This snipe has been deleted.`);
    }

    const snipe = snipes.get(message.channel.id);
    if (!snipe || Date.now() > snipe.expiresAt) {
      return message.reply(`${EMOJI_ERROR} No message has been deleted in the past 2 hours.`);
    }

    const embed = createEmbed({
      description: snipe.content || '*No content (attachment or embed only)*',
      color: 0x5865F2
    }).setAuthor({ name: snipe.nickname, iconURL: snipe.avatarURL }).setFooter({ text: formatTodayTime(snipe.timestamp) });

    if (snipe.attachments && snipe.attachments.length > 0) {
      embed.setImage(snipe.attachments[0]);
    }

    const sentMsg = await message.reply({ embeds: [embed] });
    lastSnipeMessage.set(message.channel.id, sentMsg);
    lastSnipeEmbedData.set(message.channel.id, { ...embed.data, timestamp: Date.now() });
    await saveSnipes();
    return;
  }
}

function handleMessageDelete(message) {
  if (
    message.partial ||
    message.author.bot ||
    (message.client && message.author.id === message.client.user.id) ||
    (typeof message.content === "string" && message.content.trim().startsWith("."))
  ) return;

  const member = message.member || message.guild.members.cache.get(message.author.id);
  const timestamp = Date.now();
  snipes.set(message.channel.id, {
    content: message.content || "*No text content*",
    nickname: member ? member.displayName : message.author.username,
    avatarURL: member ? member.displayAvatarURL({ dynamic: true }) : message.author.displayAvatarURL({ dynamic: true }),
    timestamp,
    attachments: Array.from(message.attachments.values()).map(a => a.url),
    expiresAt: timestamp + 2 * 60 * 60 * 1000
  });
  saveSnipes();
}

module.exports = {
  handleSnipeCommands,
  handleMessageDelete
};
```

===== FILE: commands/test.js =====
```javascript
const { ActionRowBuilder, ButtonBuilder, ButtonStyle, ModalBuilder, TextInputBuilder, TextInputStyle, EmbedBuilder } = require("discord.js");
const { semanticButton, buildNavRow } = require('../utils/ui');
// Jest placeholder (ignored at runtime). Keeps test suite from failing on empty file import.
if (process.env.JEST_WORKER_ID !== undefined) {
  describe('test command placeholder', () => {
    it('loads module', () => {
      expect(true).toBe(true);
    });
  });
}
const { OWNER_ID } = require("./moderation/permissions");
const { config, saveConfig } = require("../utils/storage");
const { TEST_LOG_CHANNEL } = require("../utils/logChannels");
const { spawnTestDrop } = require("../utils/cashDrops");
const { clearTestingCash, getTestingCash } = require("../utils/cash");
const theme = require("../utils/theme");
const { createEmbed, safeAddField } = require('../utils/embeds');
const ActiveMenus = require("../utils/activeMenus");

const CATEGORY_ROOT = "root";

function buildRootEmbed() {
  const embed = createEmbed({
    title: '🧪 Test Console',
    description: 'Pick a category to test features in a safe sandbox that does not affect production data.',
    color: theme.colors.primary
  });
  safeAddField(embed, 'General', 'Warnings, Logs, Member events (placeholder)');
  safeAddField(embed, 'Events', 'Economy, Cash Drops');
  embed.setFooter({ text: `Testing Mode: ${config.testingMode ? 'ON' : 'OFF'}` });
  return embed;
}

function rootRows() {
  return [ buildNavRow([
    semanticButton('primary', { id: 'test_general', label: 'General', emoji: '🧰' }),
    semanticButton('primary', { id: 'test_events', label: 'Events', emoji: '🎟️' }),
    semanticButton(config.testingMode ? 'danger' : 'success', { id: 'test_toggle', label: config.testingMode ? 'Disable' : 'Enable', emoji: '🧪' }),
    semanticButton('danger', { id: 'test_close', label: 'Close', emoji: theme.emojis.close || '✖' })
  ]) ];
}

function buildEventsEmbed() {
  const embed = createEmbed({ title: '🎟️ Test: Events', description: 'Choose an event category to test.', color: theme.colors.neutral });
  safeAddField(embed, 'Economy', 'Cash Drops');
  return embed;
}

function eventsRows() {
  return [ buildNavRow([
    semanticButton('primary', { id: 'test_events_economy', label: 'Economy', emoji: '💰' }),
    semanticButton('nav', { id: 'test_back_root', label: 'Back', emoji: '⬅️' }),
    semanticButton('danger', { id: 'test_close', label: 'Close', emoji: theme.emojis.close || '✖' })
  ]) ];
}

function buildEconomyEmbed() {
  const bal = getTestingCash(OWNER_ID);
  const embed = createEmbed({
    title: '💰 Test: Economy — Cash Drops',
    description: 'Spawn a test cash drop in the testing channel and try claiming it.\nTest-mode drops and balances are sandboxed and do not affect real cash.',
    color: theme.colors.primary
  });
  safeAddField(embed, 'Your test balance', `$${bal.toLocaleString()}`, true);
  return embed;
}

function economyRows() {
  return [ buildNavRow([
    semanticButton('primary', { id: 'test_econ_spawn', label: 'Spawn Test Drop', emoji: '🪙' }),
    semanticButton('nav', { id: 'test_econ_clear', label: 'Clear Test Balances', emoji: '🧹' }),
    semanticButton('nav', { id: 'test_back_events', label: 'Back', emoji: '⬅️' }),
    semanticButton('danger', { id: 'test_close', label: 'Close', emoji: theme.emojis.close || '✖' })
  ]) ];
}

async function handleTestCommand(client, message) {
  if (String(message.author.id) !== String(OWNER_ID)) return;
  const sent = await message.channel.send({ embeds: [buildRootEmbed()], components: rootRows() });
  ActiveMenus.registerMessage(sent, { type: 'testmenu', userId: message.author.id, data: { view: 'root' } });
}

ActiveMenus.registerHandler('testmenu', async (interaction, session) => {
  if (interaction.user.id !== session.userId) return interaction.reply({ content: 'Not your session.', flags: 1<<6 });
  const id = interaction.customId;
  const data = session.data || {}; // { view }

  if (id === 'test_close') {
    try { await interaction.message.edit({ components: [] }); } catch {}
  if (!interaction.replied && !interaction.deferred) await interaction.reply({ content: 'Closed.', flags: 1<<6 });
    return;
  }
  if (id === 'test_toggle') {
    config.testingMode = !config.testingMode; saveConfig();
    return interaction.update({ embeds: [buildRootEmbed()], components: rootRows() });
  }
  if (id === 'test_general') {
    data.view = 'general';
  const embed = createEmbed({ title: '🧰 Test: General', description: 'Placeholder for general test utilities.', color: theme.colors.neutral });
    return interaction.update({ embeds: [embed], components: [ buildNavRow([
      semanticButton('nav', { id: 'test_back_root', label: 'Back', emoji: '⬅️' }),
      semanticButton('danger', { id: 'test_close', label: 'Close', emoji: theme.emojis.close || '✖' })
    ]) ] });
  }
  if (id === 'test_events') {
    data.view = 'events';
    return interaction.update({ embeds: [buildEventsEmbed()], components: eventsRows() });
  }
  if (id === 'test_back_root') {
    data.view = 'root';
    return interaction.update({ embeds: [buildRootEmbed()], components: rootRows() });
  }
  if (id === 'test_back_events') {
    data.view = 'events';
    return interaction.update({ embeds: [buildEventsEmbed()], components: eventsRows() });
  }
  if (id === 'test_events_economy') {
    data.view = 'economy';
    return interaction.update({ embeds: [buildEconomyEmbed()], components: economyRows() });
  }
  if (id === 'test_econ_spawn') {
  if (!config.testingMode) return interaction.reply({ content: 'Enable Testing Mode first.', flags: 1<<6 });
    const modalId = `test_spawn_${Date.now()}`;
    const modal = new ModalBuilder().setCustomId(modalId).setTitle('Spawn Test Cash Drop').addComponents(
      new ActionRowBuilder().addComponents(new TextInputBuilder().setCustomId('amount').setLabel('Amount (optional)').setStyle(TextInputStyle.Short).setRequired(false))
    );
    await interaction.showModal(modal);
    try {
      const submitted = await interaction.awaitModalSubmit({ time: 30000, filter: m => m.customId === modalId && m.user.id === interaction.user.id });
      const raw = submitted.fields.getTextInputValue('amount').trim();
      const num = raw ? Math.max(1, Math.floor(Number(raw) || 0)) : undefined;
      const drop = spawnTestDrop(num);
      const channel = await interaction.client.channels.fetch(TEST_LOG_CHANNEL).catch(() => null);
      if (channel) {
        const embed = createEmbed({
          title: '🧪 Test Cash Drop',
          description: `Type this word to claim it first:\n\n→ \`${drop.word}\``,
          color: theme.colors.warning
        });
        safeAddField(embed, 'Reward', `**$${drop.amount.toLocaleString()}**`, true);
        embed.setFooter({ text: 'First correct message wins (testing).' });
        await channel.send({ embeds: [embed] }).catch(() => {});
      }
  await submitted.reply({ content: `Spawned a test drop of ${drop.amount} in <#${TEST_LOG_CHANNEL}>.`, flags: 1<<6 });
      try { await interaction.message.edit({ embeds: [buildEconomyEmbed()], components: economyRows() }); } catch {}
    } catch {}
    return;
  }
  if (id === 'test_econ_clear') {
    clearTestingCash();
    return interaction.update({ embeds: [buildEconomyEmbed()], components: economyRows() });
  }
});

module.exports = { handleTestCommand };
```

===== FILE: config/botConfig.json =====
```json
{
  "snipingWhitelist": [
    "1232701768383729790",
    "1232701768987578460",
    "1382889736103792740",
    "1232701768987578463",
    "1376087369794719774",
    "1376496427068297276",
    "1413966369296220233"
  ],
  "moderatorRoles": [
    "1375958357730525387",
    "1375957787800113182",
    "1375957925356638228"
  ],
  "warnings": {
    "432610292342587392": [],
    "1413738051779428362": [],
    "349282473085239298": [],
    "1165431695953121372": [],
    "475744554910351370": []
  },
  "escalation": {
    "muteThreshold": 2,
    "muteDuration": 7200000,
    "kickThreshold": 3
  },
  "defaultMuteDuration": 3600000,
  "modLogChannelId": "1232701768383729791",
  "testingMode": false,
  "roleLogBlacklist": [
    "1232701768329199666",
    "1232701768341655617",
    "1232701768354369554",
    "1232701768362754145",
    "1232701768375210151",
    "1232701768316620842",
    "1232701768362754142"
  ],
  "snipeMode": "whitelist",
  "snipingChannelList": [],
  "levelRewards": {
    "5": [
      "1232701768362754147",
      "1232701768354369551"
    ],
    "10": [
      "1232701768362754148",
      "1403501108151975966"
    ],
    "15": [
      "1232701768375210145",
      "1232701768354369552"
    ],
    "20": [
      "1232701768375210146"
    ],
    "25": [
      "1232701768375210147"
    ],
    "40": [
      "1232701768375210148"
    ],
    "75": [
      "1232701768375210149"
    ],
    "100": [
      "1382911184058978454"
    ]
  },
  "vcLevelRewards": {},
  "levelingMode": "blacklist",
  "levelingChannelList": [
    "1404040754233610250",
    "1232701768987578465",
    "1232701768383729789",
    "1232701768383729790",
    "1232701769461661745"
  ],
  "roleXPBlacklist": [
    "1232701768341655619"
  ],
  "globalXPMultiplier": 1,
  "cashDrops": {
    "dropChance": 0.02,
    "minAmount": 25,
    "maxAmount": 125,
    "lifetimeMs": 60000
  },
  "maxPurgeLimit": 100,
  "blacklistedChannels": [],
  "moderatorLogChannelId": null,
  "autoMessages": {
    "defaultDeleteMs": 0
  },
  "testingWarnings": {
    "349282473085239298": [
      {
        "moderator": "349282473085239298",
        "reason": "Rude language",
        "date": 1756861900370
      },
      {
        "moderator": "349282473085239298",
        "reason": "Rude language",
        "date": 1757260817382
      }
    ]
  },
  "testingSeed": {
    "349282473085239298": [
      {
        "moderator": "349282473085239298",
        "reason": "Rude language",
        "date": 1756861900370
      },
      {
        "moderator": "349282473085239298",
        "reason": "Rude language",
        "date": 1757260817382
      }
    ]
  },
  "commandLogging": {
    "enabled": false,
    "maxEntries": 500,
    "testingCompare": true,
    "logChannelId": null,
    "sendIntervalMs": 5000
  }
}
```

===== FILE: config/categories.js =====
```javascript
const { ButtonStyle } = require("discord.js");
const { config } = require("../utils/storage");

const categories = {
  Sniping: {
    description: "Settings for sniping commands",
    settings: {
      SnipeMode: {
        description: "Choose whether to use a whitelist or blacklist for sniping channels.",
        getDisplay: () => config.snipeMode === "blacklist" ? "Blacklist" : "Whitelist",
        buttons: [
          { id: "setWhitelist", label: "Whitelist", style: ButtonStyle.Success },
          { id: "setBlacklist", label: "Blacklist", style: ButtonStyle.Danger }
        ]
      },
      ChannelList: {
        description: () =>
          config.snipeMode === "blacklist"
            ? "Channels where snipes are not allowed."
            : "Channels where snipes are allowed.",
        getDisplay: () =>
          config.snipingChannelList && config.snipingChannelList.length
            ? config.snipingChannelList.map(id => `<#${id}>`).join("\n")
            : "*None*",
        buttons: [
          { id: "addChannel", label: "➕ Add Channel", style: ButtonStyle.Success },
          { id: "removeChannel", label: "➖ Remove Channel", style: ButtonStyle.Danger },
        ]
      }
    }
  },
  Moderation: {
    description: "Settings for moderation commands",
    settings: {
      ModeratorRoles: {
        description: "Roles allowed to use moderation commands",
        getDisplay: () => config.moderatorRoles.length
          ? config.moderatorRoles.map(id => `<@&${id}>`).join("\n")
          : "*None*",
        buttons: [
          { id: "addRole", label: "➕ Add Role", style: ButtonStyle.Success },
          { id: "removeRole", label: "➖ Remove Role", style: ButtonStyle.Danger },
        ]
      }
    }
  }
};

module.exports = {
  categories
};

```

===== FILE: config/clockInEmbedTemplate.json =====
```json
{
  "content": "",
  "embeds": [
    {
      "title": "🕒 Staff Clock-In — {{EVENT_NAME}}",
      "description": "🕒 Staff Clock-In — {{EVENT_NAME}}\n\nSelect a position from the menu below. One slot per staff (auto-updates).",
      "color": 5793266,
      "fields": [
        { "name": "🗝️ Instance Manager (0/1)", "value": "—", "inline": true },
        { "name": "🛠️ Manager (0/5)", "value": "—", "inline": true },
        { "name": "🛡️ Bouncer (0/10)", "value": "—", "inline": true },
        { "name": "🍸 Bartender (0/15)", "value": "—", "inline": true },
        { "name": "🎯 Backup (0/20)", "value": "—", "inline": true },
        { "name": "⏳ Maybe/Late (0/50)", "value": "—", "inline": true }
      ],
      "footer": { "text": "" }
    }
  ],
  "components": [
    {
      "type": 1,
      "components": [
        {
          "type": 3,
            "custom_id": "clockin:{{EVENT_ID}}:{{AUTO_MESSAGE_ID}}",
            "placeholder": "📋 Select a position",
            "options": [
              { "label": "Instance Manager", "value": "instance_manager", "description": "IM slots 1" },
              { "label": "Manager", "value": "manager", "description": "M slots 5" },
              { "label": "Bouncer", "value": "bouncer", "description": "B slots 10" },
              { "label": "Bartender", "value": "bartender", "description": "BT slots 15" },
              { "label": "Backup", "value": "backup", "description": "BK slots 20" },
              { "label": "Maybe/Late", "value": "maybe", "description": "? slots 50" }
            ]
        }
      ]
    }
  ]
}

```

===== FILE: config/events.json =====
```json
{
  "nextId": 4,
  "events": [
    {
      "id": "3",
      "name": "Midnight Bar",
      "description": "Midnight Bar",
      "channelId": "1232701768832516098",
      "message": "# ⊰-------『✩ Midnight Bar :wine_glass: ✩』-------⊱\n\n Check our ongoing Instances [here](https://vrchat.com/home/group/grp_d05ea22e-5c38-476e-9884-1cbea50643eb/instances).\nWe open daily, check the schedule in: https://discord.com/channels/1232701768316620840/1375987053950533722/1406328803227340941.\n### :busts_in_silhouette: Looking to apply for staff?\nHead over to <#1232701768832516101> and fill out a staff application.\nApplying for Staff will get you a spot on the TV as well! \n\n### :alarm_clock: Today's Opening Times: \n˸˸˸˸˸˸˸˸˸˸˸˸˸˸˸˸˸˸˸˸˸˸˸˸˸˸˸˸˸˸˸˸˸˸˸˸˸˸˸˸˸˸˸˸˸˸˸˸˸˸˸˸˸˸\n**1st Opening**: <t:1754452800:t> - <t:1754467200:t>\n˸˸˸˸˸˸˸˸˸˸˸˸˸˸˸˸˸˸˸˸˸˸˸˸˸˸˸˸˸˸˸˸˸˸˸˸˸˸˸˸˸˸˸˸˸˸˸˸˸˸˸˸˸˸\n~~**2nd Opening**: <t:1757412000:t> - <t:1757433600:t>~~\n˸˸˸˸˸˸˸˸˸˸˸˸˸˸˸˸˸˸˸˸˸˸˸˸˸˸˸˸˸˸˸˸˸˸˸˸˸˸˸˸˸˸˸˸˸˸˸˸˸˸˸˸˸˸\n\n### :bell: Want to get notified for this event?\nHead over to <#1402656938956689419> and subscribe to the Midnight Bar.\nOr simply press the button below to subscribe to get notified.\n\n[Support us on Patreon! ](https://www.patreon.com/c/lnhvrc) <a:heartsblack:1402694900163809402>\n\n# The Midnight bar is opening: <t:1757390400:R>",
      "messageJSON": null,
      "ranges": [
        {
          "start": "6:00",
          "end": "10:00"
        }
      ],
      "enabled": true,
      "times": [
        "6:00-10:00"
      ],
      "days": [
        2,
        3,
        4,
        5,
        0
      ],
      "type": "multi-daily",
      "color": 43520,
      "dynamicBaseContent": "# ⊰-------『✩ Midnight Bar :wine_glass: ✩』-------⊱\n\n Check our ongoing Instances [here](https://vrchat.com/home/group/grp_d05ea22e-5c38-476e-9884-1cbea50643eb/instances).\nWe open daily, check the schedule in: https://discord.com/channels/1232701768316620840/1375987053950533722/1406328803227340941.\n### :busts_in_silhouette: Looking to apply for staff?\nHead over to <#1232701768832516101> and fill out a staff application.\nApplying for Staff will get you a spot on the TV as well! \n\n### :alarm_clock: Today's Opening Times: \n˸˸˸˸˸˸˸˸˸˸˸˸˸˸˸˸˸˸˸˸˸˸˸˸˸˸˸˸˸˸˸˸˸˸˸˸˸˸˸˸˸˸˸˸˸˸˸˸˸˸˸˸˸˸\n**1st Opening**: <t:1754452800:t> - <t:1754467200:t>\n˸˸˸˸˸˸˸˸˸˸˸˸˸˸˸˸˸˸˸˸˸˸˸˸˸˸˸˸˸˸˸˸˸˸˸˸˸˸˸˸˸˸˸˸˸˸˸˸˸˸˸˸˸˸\n~~**2nd Opening**: <t:1757412000:t> - <t:1757433600:t>~~\n˸˸˸˸˸˸˸˸˸˸˸˸˸˸˸˸˸˸˸˸˸˸˸˸˸˸˸˸˸˸˸˸˸˸˸˸˸˸˸˸˸˸˸˸˸˸˸˸˸˸˸˸˸˸\n\n### :bell: Want to get notified for this event?\nHead over to <#1402656938956689419> and subscribe to the Midnight Bar.\nOr simply press the button below to subscribe to get notified.\n\n[Support us on Patreon! ](https://www.patreon.com/c/lnhvrc) <a:heartsblack:1402694900163809402>\n\n# The Midnight bar is opening: <t:1757563200:R>",
      "anchorChannelId": "1232701768832516098",
      "anchorMessageId": "1414992903914258454",
      "autoMessages": [
        {
          "id": "1",
          "offsetMinutes": 0,
          "enabled": true,
          "message": "{\n  \"embeds\": [\n    {\n      \"title\": \"Midnight Bar is open!\",\n      \"description\": \"**The Midnight Bar** is now open, [come join us for a drink!](https://vrchat.com/home/group/grp_d05ea22e-5c38-476e-9884-1cbea50643eb/instances)\\n\\nWe will be open until: <timestamp_close:t>\",\n      \"fields\": []\n    }\n  ],\n  \"content\": \"<@&1380303846877696153>\"\n}",
          "messageJSON": {
            "embeds": [
              {
                "title": "Midnight Bar is open!",
                "description": "**The Midnight Bar** is now open, [come join us for a drink!](https://vrchat.com/home/group/grp_d05ea22e-5c38-476e-9884-1cbea50643eb/instances)\n\nWe will be open until: <timestamp_close:t>",
                "fields": []
              }
            ],
            "content": "<@&1380303846877696153>"
          }
        },
        {
          "id": "2",
          "offsetMinutes": 1200,
          "enabled": true,
          "message": "{\n  \"content\": \"\",\n  \"embeds\": [\n    {\n      \"title\": \"🕒 Staff Clock In — Midnight Bar\",\n      \"description\": \"Staff clock-in for: https://discord.com/channels/1232701768316620840/1232701768832516098/1414992903914258454\\nPlease select your role below to clock in.\\n\\n**Instance Manager** is responsible for opening, managing, and closing an instance.\",\n      \"color\": 3447003,\n      \"fields\": [\n        {\n          \"name\": \"📝 Instance Manager (1 slot)\",\n          \"value\": \"0 / 1\\n\",\n          \"inline\": false\n        },\n        {\n          \"name\": \"🛠️ Manager\",\n          \"value\": \"*None*\",\n          \"inline\": true\n        },\n        {\n          \"name\": \"🛡️ Bouncer\",\n          \"value\": \"*None*\",\n          \"inline\": true\n        },\n        {\n          \"name\": \"🍸 Bartender\",\n          \"value\": \"*None*\",\n          \"inline\": true\n        },\n        {\n          \"name\": \"🎯 Backup\",\n          \"value\": \"*None*\",\n          \"inline\": true\n        },\n        {\n          \"name\": \"⏳ Maybe / Late\",\n          \"value\": \"*None*\",\n          \"inline\": false\n        },\n        {\n          \"name\": \"Eligable roles\",\n          \"value\": \"<@&1375995842858582096>, <@&1380277718091829368>, <@&1380323145621180466>, <@&1375958480380493844>\"\n        }\n      ],\n      \"footer\": {\n        \"text\": \"Late Night Hours | Staff clock in for the Midnight Bar\"\n      }\n    }\n  ],\n  \"components\": [\n    {\n      \"type\": 1,\n      \"components\": [\n        {\n          \"type\": 3,\n          \"custom_id\": \"clockin:{{EVENT_ID}}:{{AUTO_MESSAGE_ID}}\",\n          \"placeholder\": \"📋 Select your position\",\n          \"options\": [\n            {\n              \"label\": \"Instance Manager\",\n              \"value\": \"instance_manager\",\n              \"description\": \"1 slot available\",\n              \"emoji\": {\n                \"name\": \"📝\"\n              }\n            },\n            {\n              \"label\": \"Manager\",\n              \"value\": \"manager\",\n              \"emoji\": {\n                \"name\": \"🛠️\"\n              }\n            },\n            {\n              \"label\": \"Bouncer\",\n              \"value\": \"bouncer\",\n              \"emoji\": {\n                \"name\": \"🛡️\"\n              }\n            },\n            {\n              \"label\": \"Bartender\",\n              \"value\": \"bartender\",\n              \"emoji\": {\n                \"name\": \"🍸\"\n              }\n            },\n            {\n              \"label\": \"Backup\",\n              \"value\": \"backup\",\n              \"emoji\": {\n                \"name\": \"🎯\"\n              }\n            },\n            {\n              \"label\": \"Maybe / Late\",\n              \"value\": \"maybe\",\n              \"emoji\": {\n                \"name\": \"⏳\"\n              }\n            }\n          ],\n          \"flows\": {\n            \"maybe\": {\n              \"actions\": [\n                {\n                  \"type\": 0\n                }\n              ]\n            }\n          }\n        }\n      ]\n    }\n  ]\n}",
          "messageJSON": {
            "content": "",
            "embeds": [
              {
                "title": "🕒 Staff Clock In — Midnight Bar",
                "description": "Staff clock-in for: https://discord.com/channels/1232701768316620840/1232701768832516098/1414992903914258454\nPlease select your role below to clock in.\n\n**Instance Manager** is responsible for opening, managing, and closing an instance.",
                "color": 3447003,
                "fields": [
                  {
                    "name": "📝 Instance Manager (1 slot)",
                    "value": "0 / 1\n",
                    "inline": false
                  },
                  {
                    "name": "🛠️ Manager",
                    "value": "*None*",
                    "inline": true
                  },
                  {
                    "name": "🛡️ Bouncer",
                    "value": "*None*",
                    "inline": true
                  },
                  {
                    "name": "🍸 Bartender",
                    "value": "*None*",
                    "inline": true
                  },
                  {
                    "name": "🎯 Backup",
                    "value": "*None*",
                    "inline": true
                  },
                  {
                    "name": "⏳ Maybe / Late",
                    "value": "*None*",
                    "inline": false
                  },
                  {
                    "name": "Eligable roles",
                    "value": "<@&1375995842858582096>, <@&1380277718091829368>, <@&1380323145621180466>, <@&1375958480380493844>"
                  }
                ],
                "footer": {
                  "text": "Late Night Hours | Staff clock in for the Midnight Bar"
                }
              }
            ],
            "components": [
              {
                "type": 1,
                "components": [
                  {
                    "type": 3,
                    "custom_id": "clockin:{{EVENT_ID}}:{{AUTO_MESSAGE_ID}}",
                    "placeholder": "📋 Select your position",
                    "options": [
                      {
                        "label": "Instance Manager",
                        "value": "instance_manager",
                        "description": "1 slot available",
                        "emoji": {
                          "name": "📝"
                        }
                      },
                      {
                        "label": "Manager",
                        "value": "manager",
                        "emoji": {
                          "name": "🛠️"
                        }
                      },
                      {
                        "label": "Bouncer",
                        "value": "bouncer",
                        "emoji": {
                          "name": "🛡️"
                        }
                      },
                      {
                        "label": "Bartender",
                        "value": "bartender",
                        "emoji": {
                          "name": "🍸"
                        }
                      },
                      {
                        "label": "Backup",
                        "value": "backup",
                        "emoji": {
                          "name": "🎯"
                        }
                      },
                      {
                        "label": "Maybe / Late",
                        "value": "maybe",
                        "emoji": {
                          "name": "⏳"
                        }
                      }
                    ],
                    "flows": {
                      "maybe": {
                        "actions": [
                          {
                            "type": 0
                          }
                        ]
                      }
                    }
                  }
                ]
              }
            ]
          },
          "channelId": "1376497592871030865",
          "isClockIn": false,
          "__skipUntil": 1757508587804,
          "lastManualTrigger": 1757504987804
        }
      ],
      "nextAutoId": 3,
      "__auto_2_6:00-10:00": 1757455214645,
      "__auto_1_6:00-10:00": 1757476809648,
      "__notifMsgs": {
        "2": {
          "channelId": "1376497592871030865",
          "ids": [
            "1415303188491538564",
            "1415303239468843131"
          ]
        }
      }
    }
  ]
}
```

===== FILE: config/roles.js =====
```javascript
module.exports = {
  OWNER_ID: "349282473085239298",
  CHANNEL_ID: "1412917089840398346",
  ROLES: {
    Owners: "1385448879822213161",
    Manager: "1375958480380493844",
    Security: "1375958589658632313",
    Staff: "1380323145621180466",
    Trainee: "1380277718091829368",
    Inactive: "1412983968227262605"
  },
  ROLE_ORDER: ["Owners", "Manager", "Security", "Staff", "Trainee", "Inactive"],
  ROLE_EMOJIS: {
    Owners: "👑",
    Manager: "📋",
    Security: "🛡️",
    Staff: "💼",
    Trainee: "🎓",
    Inactive: "💤"
  }
};

```

===== FILE: config/schedules.json =====
```json
{
  "nextId": 26,
  "schedules": []
}
```

===== FILE: events/guildEvents.js =====
```javascript
const { logMemberLeave } = require("../utils/memberLogs");
const { logRoleChange } = require("../utils/roleLogs");
const { logMessageDelete, logMessageEdit } = require("../utils/messageLogs");
const { handleMessageDelete: handleSnipeDelete } = require("../commands/snipes");

function attachGuildEvents(client) {
  // Member leaves
  client.on("guildMemberRemove", async (member) => {
    try {
      await logMemberLeave(client, member, false);
    } catch (err) {
      console.error("[guildMemberRemove] log error:", err);
    }
  });

  // Role add/remove
  client.on("guildMemberUpdate", async (oldMember, newMember) => {
    try {
      const oldRoles = new Set(oldMember.roles.cache.keys());
      const newRoles = new Set(newMember.roles.cache.keys());

      // Added roles
      for (const roleId of newRoles) {
        if (!oldRoles.has(roleId)) {
          const role = newMember.guild.roles.cache.get(roleId);
          if (role) await logRoleChange(client, newMember, role, "add");
        }
      }
      // Removed roles
      for (const roleId of oldRoles) {
        if (!newRoles.has(roleId)) {
          const role = newMember.guild.roles.cache.get(roleId);
          if (role) await logRoleChange(client, newMember, role, "remove");
        }
      }
    } catch (err) {
      console.error("[guildMemberUpdate] role log error:", err);
    }
  });

  // Message delete/edit logs + snipes
  client.on("messageDelete", async (message) => {
    try { await logMessageDelete(client, message); } catch (err) { console.error("[messageDelete] log error:", err); }
    try { handleSnipeDelete(message); } catch (err) { console.error("[messageDelete] snipe error:", err); }
  });
  client.on("messageUpdate", async (oldMessage, newMessage) => {
    try { await logMessageEdit(client, oldMessage, newMessage); } catch (err) { console.error("[messageUpdate] log error:", err); }
  });
}

module.exports = { attachGuildEvents };

```

===== FILE: events/interactionEvents.js =====
```javascript
const { InteractionType, ModalBuilder, TextInputBuilder, TextInputStyle, ActionRowBuilder, ButtonBuilder, ButtonStyle } = require("discord.js");
const { ALLOWED_ROLES, CHATBOX_BUTTON_ID, isModerator, OWNER_ID } = require("../commands/moderation/permissions");
const { handleWarningButtons } = require("../commands/moderation/index");
const { config, saveConfig } = require("../utils/storage");
const { EMOJI_SUCCESS, EMOJI_ERROR } = require("../commands/moderation/replies");
const { renderSettingEmbed } = require("../commands/configMenu");
const { handleScheduleModal, handleEventCreateModal, handleEventEditModal, handleEventNotificationModal } = require("../commands/schedule");
const { getEvent, updateEvent } = require('../utils/eventsStorage');
const ActiveMenus = require("../utils/activeMenus");
const { sendModLog } = require("../utils/modLogs");
const { logError } = require('../utils/errorUtil');

// Instrumentation: detect legacy ephemeral property usage at runtime.
function instrumentInteraction(interaction) {
  if (interaction.__ephemeralInstrumented) return;
  interaction.__ephemeralInstrumented = true;
  const wrap = (methodName) => {
    if (typeof interaction[methodName] !== 'function') return;
    const original = interaction[methodName].bind(interaction);
    interaction[methodName] = async function wrapped(options, ...rest) {
      try {
        if (options && typeof options === 'object' && 'ephemeral' in options) {
          logError('deprecated_ephemeral', new Error(`Interaction.${methodName} invoked with deprecated ephemeral option (id=${interaction.id})`));
        }
      } catch {}
      return original(options, ...rest);
    };
  };
  ['reply','followUp','editReply','deferReply','deferUpdate'].forEach(wrap);
}
const { sendUserDM } = require("../commands/moderation/dm");
const { parseDurationAndReason } = require("../utils/time");
const { handleBalanceCommand, buildDepositMenuPayload, buildWithdrawMenuPayload, buildBalancePayload, bankColor, buildStatusLine } = require("../commands/balance");
const { addProgress } = require("../utils/depositProgress");
const { depositToBank, withdrawFromBank, amountToNextThreshold, quoteDeposit, getBank, getBaseLimit, computeMaxAffordableDeposit, computeTaxForDeposit } = require("../utils/bank");
const { getCash, getTestingCash } = require("../utils/cash");
const theme = require("../utils/theme");
const { semanticButton, buildNavRow } = require("../utils/ui");

// Pending Kick/Ban confirmations: key = `${userId}:${action}:${moderatorId}` -> { reason: string|null, originChannelId?:string, originMessageId?:string }
const pendingPunishments = new Map();

function attachInteractionEvents(client) {
  // Idempotent attach guard to prevent duplicate listener registration
  if (client.__interactionListenerAttached) return;
  client.__interactionListenerAttached = true;
  client.on("interactionCreate", async (interaction) => {
  // Attach command logging wrappers to interaction reply/edit methods
  try { require('../utils/commandLogger').instrumentInteractionLogging(interaction); } catch {}
    try {
      // Route persistent session UIs first
  if (interaction.isButton() || interaction.isStringSelectMenu()) {
        const res = await ActiveMenus.processInteraction(interaction);
        if (res && res.handled) return;
      }

      // Cash balance quick button (with cash drop broadcast redirect)
      if (interaction.isButton() && interaction.customId && interaction.customId.startsWith("cash:check")) {
        const { buildBalancePayload } = require("../commands/balance");
        const payload = buildBalancePayload(interaction.user.id);
        let jumpLink = null;
        try {
          const { activeDrops } = require('../utils/cashDrops');
          const dropActive = activeDrops && Array.from(activeDrops.values()).some(d => d && !d.claimedBy && d.expiresAt > Date.now());
          if (dropActive) {
            const BROADCAST_CHANNEL_ID = '1232701768987578462';
            const ch = await interaction.client.channels.fetch(BROADCAST_CHANNEL_ID).catch(()=>null);
            if (ch && ch.send) {
              const pubMsg = await ch.send({ content: `🔍 Balance Check: <@${interaction.user.id}>`, ...payload, allowedMentions:{ users:[interaction.user.id] } }).catch(()=>null);
              if (pubMsg) jumpLink = `https://discord.com/channels/${pubMsg.guildId}/${pubMsg.channelId}/${pubMsg.id}`;
            }
          }
        } catch {}
        if (jumpLink) {
          await interaction.reply({ content: `Balance posted here → ${jumpLink}`, flags: 1<<6 }).catch(()=>{});
        } else {
          await interaction.reply({ ...payload, flags: 1<<6 }).catch(() => {});
        }
        return;
      }

      // --- New Balance Menu System ---
      if (interaction.isButton() && interaction.customId === "bank:menu:deposit") {
        await interaction.deferUpdate().catch(() => {});
        try { await interaction.message.edit(buildDepositMenuPayload(interaction.user.id)); } catch {}
        return;
      }
      if (interaction.isButton() && interaction.customId === "bank:menu:withdraw") {
        await interaction.deferUpdate().catch(() => {});
        try { await interaction.message.edit(buildWithdrawMenuPayload(interaction.user.id)); } catch {}
        return;
      }
      if (interaction.isButton() && interaction.customId === "bank:back") {
        await interaction.deferUpdate().catch(() => {});
        try { await interaction.message.edit(buildBalancePayload(interaction.user.id)); } catch {}
        return;
      }

      // Deposit amount (opens modal) -> ephemeral confirmation
      if (interaction.isButton() && interaction.customId === "bank:deposit:amount") {
        const modalId = `bank_deposit_amount_${Date.now()}`;
        const modal = new ModalBuilder().setCustomId(modalId).setTitle("Deposit Amount").addComponents(new ActionRowBuilder().addComponents(
          new TextInputBuilder().setCustomId("amount").setLabel("Amount (number)").setStyle(TextInputStyle.Short).setRequired(true)
        ));
        await interaction.showModal(modal);
        const submitted = await interaction.awaitModalSubmit({ time: 30000, filter: i => i.customId === modalId && i.user.id === interaction.user.id }).catch(() => null);
        if (!submitted) return;
        const raw = submitted.fields.getTextInputValue("amount");
        const amt = Math.max(0, Math.floor(Number((raw||"").replace(/[^0-9]/g, "")) || 0));
  if (amt <= 0) { await submitted.reply({ content: "❌ Enter a positive amount.", flags: 1<<6 }); return; }
        const q = quoteDeposit(interaction.user.id, amt);
  if (!q.ok) { await submitted.reply({ content: "❌ Invalid amount.", flags: 1<<6 }); return; }
        const taxPct = q.deposit > 0 ? (q.tax / q.deposit) * 100 : 0;
        let warningLine = "";
        if (q.requiresConfirmation) {
          warningLine = `\n\n⚠️ **Warning:** Above / crossing daily limit. Tax: **$${q.tax.toLocaleString()}** (${taxPct.toFixed(1)}%) (Total Cost: **$${q.totalCost.toLocaleString()}**).`;
        } else if (q.tax > 0) {
          warningLine = `\n\nTax: **$${q.tax.toLocaleString()}** (${taxPct.toFixed(1)}%) (Total Cost: **$${q.totalCost.toLocaleString()}**).`;
        }
        const content = `Confirm depositing **$${q.deposit.toLocaleString()}**?${warningLine}`;
        const rootMsgId = interaction.message?.id; // original menu message id
        const row = new ActionRowBuilder().addComponents(
          semanticButton('success', { id: `bank:confirm:${q.deposit}:${q.tax}:${q.totalCost}:${rootMsgId}`, label: 'Confirm' }),
          semanticButton('primary', { id: `bank:confirm:toLimit:${rootMsgId}`, label: 'To Limit' }),
          semanticButton('nav', { id: 'bank:decline', label: 'Cancel' })
        );
  await submitted.reply({ content, components: [row], flags: 1<<6 }).catch(() => {});
        return;
      }

      // Deposit Max logic per spec
      if (interaction.isButton() && interaction.customId === "bank:deposit:max") {
        const bankBal = getBank(interaction.user.id) || 0;
        const base = getBaseLimit();
        const maxAff = computeMaxAffordableDeposit(interaction.user.id);
        if (maxAff.deposit <= 0) {
          await interaction.reply({ content: "Nothing to deposit.", flags: 1<<6 }).catch(()=>{});
          return;
        }
        const taxPct = maxAff.deposit > 0 ? (maxAff.tax / maxAff.deposit) * 100 : 0;
        const warnNeeded = bankBal >= base || (bankBal < base && bankBal + maxAff.deposit > base);
        const warn = warnNeeded ? `\n\n⚠️ **Warning:** Above / crossing daily limit. Tax: **$${maxAff.tax.toLocaleString()}** (${taxPct.toFixed(1)}%) (Total Cost: **$${maxAff.totalCost.toLocaleString()}**).` : (maxAff.tax ? `\n\nTax: **$${maxAff.tax.toLocaleString()}** (${taxPct.toFixed(1)}%)` : "");
        const content = `Confirm Deposit Max: **$${maxAff.deposit.toLocaleString()}**?${warn}`;
        const rootMsgId = interaction.message?.id;
        const row = new ActionRowBuilder().addComponents(
          semanticButton('danger', { id: `bank:confirm:${maxAff.deposit}:${maxAff.tax}:${maxAff.totalCost}:${rootMsgId}`, label: 'Confirm Max' }),
          semanticButton('primary', { id: `bank:confirm:toLimit:${rootMsgId}`, label: 'To Limit' }),
          semanticButton('nav', { id: 'bank:decline', label: 'Cancel' })
        );
  await interaction.reply({ content, components: [row], flags: 1<<6 }).catch(()=>{});
        return;
      }

      // Withdraw amount
      if (interaction.isButton() && interaction.customId === "bank:withdraw:amount") {
        const modalId = `bank_withdraw_amount_${Date.now()}`;
        const modal = new ModalBuilder().setCustomId(modalId).setTitle("Withdraw Amount").addComponents(new ActionRowBuilder().addComponents(
          new TextInputBuilder().setCustomId("amount").setLabel("Amount (number)").setStyle(TextInputStyle.Short).setRequired(true)
        ));
        await interaction.showModal(modal);
        const submitted = await interaction.awaitModalSubmit({ time:30000, filter:i=>i.customId===modalId && i.user.id===interaction.user.id }).catch(()=>null);
        if (!submitted) return;
        const raw = submitted.fields.getTextInputValue("amount");
        const amt = Math.max(0, Math.floor(Number((raw||"").replace(/[^0-9]/g, ""))||0));
  if (amt<=0) { await submitted.reply({ content: "❌ Enter a positive amount.", flags:1<<6 }); return; }
  if (amt > getBank(interaction.user.id)) { await submitted.reply({ content: "❌ You don't have that much in the bank.", flags:1<<6 }); return; }
        const content = `Confirm withdrawing $${amt.toLocaleString()}?`;
        const rootMsgId = interaction.message?.id;
        const row = new ActionRowBuilder().addComponents(
          semanticButton('success', { id: `bank:withdraw:confirm:${amt}:${rootMsgId}`, label: 'Confirm' }),
          semanticButton('nav', { id: 'bank:decline', label: 'Cancel' })
        );
  await submitted.reply({ content, components:[row], flags:1<<6 }).catch(()=>{});
        return;
      }

      // Withdraw Max (no penalty) -> confirm
      if (interaction.isButton() && interaction.customId === "bank:withdraw:max") {
        const bankBal = getBank(interaction.user.id);
  if (bankBal <= 0) { await interaction.reply({ content: "Bank is empty.", flags:1<<6 }).catch(()=>{}); return; }
        const rootMsgId = interaction.message?.id;
        const row = new ActionRowBuilder().addComponents(
          semanticButton('danger', { id: `bank:withdraw:confirm:${bankBal}:${rootMsgId}`, label: 'Confirm Withdraw All' }),
          semanticButton('nav', { id: 'bank:decline', label: 'Cancel' })
        );
  await interaction.reply({ content: `Withdraw all $${bankBal.toLocaleString()}?`, components:[row], flags:1<<6 }).catch(()=>{});
        return;
      }

      // Confirmation handlers
      if (interaction.isButton() && interaction.customId.startsWith("bank:confirm:toLimit")) {
        const parts = interaction.customId.split(":");
        const rootId = parts[3];
        const base = getBaseLimit();
        const bankBal = getBank(interaction.user.id);
        if (bankBal >= base) {
          await interaction.reply({ content: "Already at or above the daily limit.", flags:1<<6 }).catch(()=>{});
          return;
        }
        const needed = base - bankBal;
        const q = quoteDeposit(interaction.user.id, needed);
  if (!q.ok) { await interaction.reply({ content: "❌ Could not compute required amount.", flags:1<<6 }).catch(()=>{}); return; }
  const res = depositToBank(interaction.user.id, q.deposit, { allowAboveLimit:true });
  if (!res.ok) { await interaction.reply({ content: `❌ ${res.error||"Deposit failed"}`, flags:1<<6 }).catch(()=>{}); return; }
  addProgress(interaction.user.id, res.moved || 0);
  const pct = res.moved ? ((res.tax || 0) / res.moved) * 100 : 0;
  await interaction.reply({ content: `✅ Deposited $${res.moved.toLocaleString()} to reach the daily limit.${res.tax?` Tax $${res.tax.toLocaleString()} (${pct.toFixed(1)}%)`:''}`, flags:1<<6 }).catch(()=>{});
        // Revert original menu (if we have the id) back to root balance
        if (rootId) {
          try {
            const channel = interaction.channel;
            if (channel?.messages?.fetch) {
              const rootMsg = await channel.messages.fetch(rootId).catch(()=>null);
              if (rootMsg) await rootMsg.edit(buildBalancePayload(interaction.user.id)).catch(()=>{});
            }
          } catch {}
        }
        return;
      }
      if (interaction.isButton() && interaction.customId.startsWith("bank:confirm:")) {
        const parts = interaction.customId.split(":");
        const depositAmt = Number(parts[2])||0;
        const tax = Number(parts[3])||0;
        const total = Number(parts[4])|| (depositAmt+tax);
        const rootId = parts[5];
        const res = depositToBank(interaction.user.id, depositAmt, { allowAboveLimit:true });
  if (!res.ok) { await interaction.reply({ content: `❌ ${res.error||"Deposit failed"}`, flags:1<<6 }).catch(()=>{}); return; }
        addProgress(interaction.user.id, res.moved || 0);
  await interaction.reply({ content: `✅ Deposited $${res.moved.toLocaleString()}${tax?` (Tax $${tax.toLocaleString()})`:""}.`, flags:1<<6 }).catch(()=>{});
        // Revert original menu back to balance root if we know it
        if (rootId) {
          try {
            const channel = interaction.channel;
            if (channel?.messages?.fetch) {
              const rootMsg = await channel.messages.fetch(rootId).catch(()=>null);
              if (rootMsg) await rootMsg.edit(buildBalancePayload(interaction.user.id)).catch(()=>{});
            }
          } catch {}
        }
        return;
      }
      if (interaction.isButton() && interaction.customId.startsWith("bank:withdraw:confirm:")) {
        const parts = interaction.customId.split(":");
        const amt = Number(parts[3])||0;
        const rootId = parts[4];
        const res = withdrawFromBank(interaction.user.id, amt);
  if (!res.ok) { await interaction.reply({ content: `❌ ${res.error||"Withdraw failed"}`, flags:1<<6 }).catch(()=>{}); return; }
  await interaction.reply({ content: `✅ Withdrew $${res.moved.toLocaleString()}.`, flags:1<<6 }).catch(()=>{});
        // Revert to root balance menu (withdraw does not affect progress)
        if (rootId) {
          try {
            const channel = interaction.channel;
            if (channel?.messages?.fetch) {
              const rootMsg = await channel.messages.fetch(rootId).catch(()=>null);
              if (rootMsg) await rootMsg.edit(buildBalancePayload(interaction.user.id)).catch(()=>{});
            }
          } catch {}
        }
        return;
      }
      if (interaction.isButton() && (interaction.customId === "bank:decline")) {
  await interaction.reply({ content: "❌ Cancelled.", flags: 64 }).catch(()=>{});
        return;
      }

  // (Old handlers removed and replaced by new menu system above)

      // Warnings dashboard/buttons/selects/modals (only routes warns:*)
      if (
        (interaction.isButton() && interaction.customId?.startsWith("warns:")) ||
        (interaction.isStringSelectMenu() && interaction.customId?.startsWith("warns:")) ||
        (interaction.type === InteractionType.ModalSubmit && interaction.customId?.startsWith("warns:"))
      ) {
        await handleWarningButtons(client, interaction);
        return;
      }

      // Staff-only quick moderation actions from mod logs
      if (interaction.isButton() && interaction.customId?.startsWith("modact:")) {
        const parts = interaction.customId.split(":");
        // Patterns:
        // - modact:menu:<group>:<userId>
        // - modact:<action>:<userId>[:durationMs]
        // - modact:init:<kick|ban>:<userId>
        // - modact:confirm:<kick|ban>:<userId>
        // - modact:cancel:<kick|ban>:<userId>
        // - modact:changeReason:<kick|ban>:<userId>
        const kind = parts[1];
        const act = (kind === "menu" || ["init", "confirm", "cancel", "changeReason", "back"].includes(kind)) ? null : kind;
        const group = kind === "menu" ? parts[2] : null;
        const flowAction = ["init", "confirm", "cancel", "changeReason"].includes(kind) ? parts[2] : null; // kick|ban
        const uid = kind === "menu" ? parts[3] : (["init", "confirm", "cancel", "changeReason", "back"].includes(kind) ? parts[3] : parts[2]);
        const durMs = parts[4] ? Number(parts[4]) : (parts[3] && !["menu", "init", "confirm", "cancel", "changeReason", "back"].includes(kind) ? Number(parts[3]) : null);

        // Permission gate
        const member = interaction.member;
        if (!member || !isModerator(member)) {
          await interaction.reply({ content: `${EMOJI_ERROR} You are not allowed to use this.`, flags: 1<<6 }).catch(() => {});
          return;
        }

        // Resolve target
        const guild = interaction.guild;
        const targetMember = guild ? await guild.members.fetch(uid).catch(() => null) : null;
        const targetUser = targetMember?.user || (await client.users.fetch(uid).catch(() => null));
        if (!targetMember && !targetUser) {
          await interaction.reply({ content: `${EMOJI_ERROR} Could not resolve user.`, flags: 1<<6 }).catch(() => {});
          return;
        }

        const isTesting = !!config.testingMode;

        // Permission/hierarchy helpers for kick/ban
        const canActKickBan = (action) => {
          const g = interaction.guild;
          if (!g) return { ok: false, msg: `${EMOJI_ERROR} Not in a guild.` };
          const me = g.members?.me;
          const targetInGuild = !!targetMember;
          // Target membership constraints
          if (action === "kick" && !targetInGuild) {
            return { ok: false, msg: `${EMOJI_ERROR} That user is not in the server.` };
          }
          // Self-protection
          if (interaction.user.id === uid) {
            return { ok: false, msg: `${EMOJI_ERROR} You cannot ${action} yourself.` };
          }
          // Bot permission checks
          const needPerm = action === "kick" ? "KickMembers" : "BanMembers";
          if (!me || !me.permissions?.has?.(needPerm)) {
            return { ok: false, msg: `${EMOJI_ERROR} I lack permission to ${action} members.` };
          }
          // Role hierarchy checks when target is in guild
          if (targetInGuild) {
            const actorOwner = g.ownerId === interaction.user.id;
            if (!actorOwner) {
              const actorHighest = interaction.member?.roles?.highest?.position ?? 0;
              const targetHighest = targetMember.roles?.highest?.position ?? 0;
              if (actorHighest <= targetHighest) {
                return { ok: false, msg: `${EMOJI_ERROR} You cannot act on a member with an equal or higher role.` };
              }
            }
            const botHighest = me.roles?.highest?.position ?? 0;
            const targetHighest = targetMember.roles?.highest?.position ?? 0;
            if (botHighest <= targetHighest) {
              return { ok: false, msg: `${EMOJI_ERROR} I cannot act on a member with an equal or higher role than mine.` };
            }
          }
          return { ok: true };
        };

        // Helpers to access warnings store
        const ensureStores = () => {
          if (typeof config.warnings !== "object" || !config.warnings) config.warnings = {};
          if (typeof config.testingWarnings !== "object" || !config.testingWarnings) config.testingWarnings = {};
        };
        const getStore = () => (config.testingMode ? config.testingWarnings : config.warnings);
        const saveStore = () => { try { saveConfig(); } catch {} };

        // Helpers to build and swap rows on the original message
          const { semanticButton } = require('../utils/ui');
          const buildTopRow = () => new ActionRowBuilder().addComponents(
            semanticButton('nav', { id: `modact:menu:warnings:${uid}`, label: 'Warnings', emoji: '⚠️' }),
            semanticButton('nav', { id: `modact:menu:mute:${uid}`, label: 'Mute', emoji: '⏰' }),
            semanticButton('nav', { id: `modact:init:kick:${uid}`, label: 'Kick', emoji: '👢' }),
            semanticButton('danger', { id: `modact:init:ban:${uid}`, label: 'Ban', emoji: '🔨' })
          );
        const swapRows = async (rows) => {
          await interaction.deferUpdate().catch(() => {});
          try { await interaction.message.edit({ components: rows }); } catch {}
        };

        // In-message submenus
        if (kind === "menu") {
          if (group === "warnings") {
            ensureStores();
            const store = getStore();
            const count = Array.isArray(store[uid]) ? store[uid].length : 0;
            const rows = [
              new ActionRowBuilder().addComponents(
                semanticButton('nav', { id: `modact:addwarn:${uid}`, label: 'Warn+', emoji: '➕' }),
                semanticButton('nav', { id: `modact:removewarn:${uid}`, label: 'Warn-', emoji: '➖', enabled: count !== 0 }),
                semanticButton('nav', { id: `modact:back:${uid}`, label: 'Back', emoji: '⬅️' })
              )
            ];
            await swapRows(rows);
            return;
          } else if (group === "mute") {
            const isTimedOut = !!(targetMember?.communicationDisabledUntilTimestamp && targetMember.communicationDisabledUntilTimestamp > Date.now());
            const rows = [
              new ActionRowBuilder().addComponents(
                semanticButton('danger', { id: `modact:mute:${uid}:3600000`, label: '1h', emoji: '⏱️' }),
                semanticButton('danger', { id: `modact:mute:${uid}:7200000`, label: '2h', emoji: '⏱️' }),
                semanticButton('danger', { id: `modact:mute:${uid}:21600000`, label: '6h', emoji: '⏱️' }),
                semanticButton('danger', { id: `modact:mute:${uid}:86400000`, label: '24h', emoji: '⏱️' })
              ),
              new ActionRowBuilder().addComponents(
                semanticButton('success', { id: `modact:unmute:${uid}`, label: 'Unmute', emoji: '✅', enabled: isTimedOut }),
                semanticButton('nav', { id: `modact:back:${uid}`, label: 'Back', emoji: '⬅️' })
              )
            ];
            await swapRows(rows);
            return;
          }
        }

        // Back to top-level row
        if (kind === "back") {
          await swapRows([buildTopRow()]);
          return;
        }

        // Kick/Ban flow: init -> optional reason -> ephemeral confirmation (confirm/cancel/changeReason)
        if (kind === "init" && (flowAction === "kick" || flowAction === "ban")) {
          const guard = canActKickBan(flowAction);
          if (!guard.ok) {
            await interaction.reply({ content: guard.msg, flags: 1<<6 }).catch(() => {});
            return;
          }
          // Prompt optional reason
          const modalId = `modact_reason_${flowAction}_${uid}_${Date.now()}`;
          const modal = new ModalBuilder()
            .setCustomId(modalId)
            .setTitle("Optional Reason")
            .addComponents(new ActionRowBuilder().addComponents(
              new TextInputBuilder().setCustomId("reason").setLabel("Reason (optional)").setStyle(TextInputStyle.Paragraph).setRequired(false)
            ));
          await interaction.showModal(modal);
          const submitted = await interaction.awaitModalSubmit({ time: 30000, filter: i => i.customId === modalId && i.user.id === interaction.user.id }).catch(() => null);
          if (!submitted) {
            // User closed/dismissed the modal — do not send any confirmation message
            return;
          }
          let reason = null;
          const r = submitted.fields.getTextInputValue("reason");
          if (r && r.trim()) reason = r.trim();
          const key = `${uid}:${flowAction}:${interaction.user.id}`;
          // store origin message so we can restore buttons on cancel/confirm
          pendingPunishments.set(key, { reason, originChannelId: interaction.channelId, originMessageId: interaction.message?.id });
          const reasonText = reason && reason.trim() ? reason.trim() : "None";
          const content = `<@${uid}> will be ${flowAction === "kick" ? "kicked" : "banned"}.\nAre you sure you would like to proceed?\n\nReason provided: ${reasonText}`;
          const row = new ActionRowBuilder().addComponents(
            semanticButton('success', { id: `modact:confirm:${flowAction}:${uid}`, label: 'Confirm' }),
            semanticButton('danger', { id: `modact:cancel:${flowAction}:${uid}`, label: 'Cancel' }),
            semanticButton('primary', { id: `modact:changeReason:${flowAction}:${uid}`, label: 'Reason' })
          );
          await submitted.reply({ content, components: [row], flags: 1<<6 }).catch(() => {});
          return;
        }

        if ((kind === "confirm" || kind === "cancel" || kind === "changeReason") && (flowAction === "kick" || flowAction === "ban")) {
          const key = `${uid}:${flowAction}:${interaction.user.id}`;
          const state = pendingPunishments.get(key) || { reason: null };
          if (kind === "cancel") {
            await interaction.reply({ content: `${EMOJI_SUCCESS} ${flowAction === "kick" ? "Kick" : "Ban"} cancelled.`, flags: 1<<6 }).catch(() => {});
            pendingPunishments.delete(key);
            // restore original message buttons to top row
            try {
              if (state.originChannelId && state.originMessageId) {
                const channel = await client.channels.fetch(state.originChannelId).catch(() => null);
                const msg = await channel?.messages?.fetch?.(state.originMessageId).catch(() => null);
                if (msg) {
                  await msg.edit({ components: [buildTopRow()] }).catch(() => {});
                }
              }
            } catch {}
            return;
          }
          if (kind === "changeReason") {
            const modalId = `modact_reason_change_${flowAction}_${uid}_${Date.now()}`;
            const modal = new ModalBuilder()
              .setCustomId(modalId)
              .setTitle("Change Reason")
              .addComponents(new ActionRowBuilder().addComponents(
                new TextInputBuilder().setCustomId("reason").setLabel("Reason (optional)").setStyle(TextInputStyle.Paragraph).setRequired(false).setValue(state.reason || "")
              ));
            await interaction.showModal(modal);
            const submitted = await interaction.awaitModalSubmit({ time: 30000, filter: i => i.customId === modalId && i.user.id === interaction.user.id }).catch(() => null);
            if (submitted) {
              const r = submitted.fields.getTextInputValue("reason");
              const newReason = r && r.trim() ? r.trim() : null;
              pendingPunishments.set(key, { reason: newReason, originChannelId: state.originChannelId, originMessageId: state.originMessageId });
              const reasonText = newReason ? newReason : "None";
              const content = `<@${uid}> will be ${flowAction === "kick" ? "kicked" : "banned"}.\nAre you sure you would like to proceed?\n\nReason provided: ${reasonText}`;
              const row = new ActionRowBuilder().addComponents(
                semanticButton('success', { id: `modact:confirm:${flowAction}:${uid}`, label: 'Confirm' }),
                semanticButton('danger', { id: `modact:cancel:${flowAction}:${uid}`, label: 'Cancel' }),
                semanticButton('primary', { id: `modact:changeReason:${flowAction}:${uid}`, label: 'Reason' })
              );
              await submitted.reply({ content, components: [row], flags: 1<<6 }).catch(() => {});
            }
            return;
          }
          if (kind === "confirm") {
            const guard = canActKickBan(flowAction);
            if (!guard.ok) {
              await interaction.reply({ content: guard.msg, flags: 1<<6 }).catch(() => {});
              pendingPunishments.delete(key);
              // restore original message buttons to top row
              try {
                if (state.originChannelId && state.originMessageId) {
                  const channel = await client.channels.fetch(state.originChannelId).catch(() => null);
                  const msg = await channel?.messages?.fetch?.(state.originMessageId).catch(() => null);
                  if (msg) {
                    const { semanticButton } = require('../utils/ui');
                    const buildTopRow = () => new ActionRowBuilder().addComponents(
                      semanticButton('nav', { id: `modact:menu:warnings:${uid}`, label: 'Warnings', emoji: '⚠️' }),
                      semanticButton('nav', { id: `modact:menu:mute:${uid}`, label: 'Mute', emoji: '⏰' }),
                      semanticButton('nav', { id: `modact:init:kick:${uid}`, label: 'Kick', emoji: '👢' }),
                      semanticButton('danger', { id: `modact:init:ban:${uid}`, label: 'Ban', emoji: '🔨' })
                    );
                    await msg.edit({ components: [buildTopRow()] }).catch(() => {});
                  }
                }
              } catch {}
              return;
            }
            // Execute kick/ban with reason (default: no reason)
            const reason = state.reason || "No reason provided";
            if (!isTesting && targetMember) {
              try {
                if (flowAction === "kick") await targetMember.kick(reason);
                else await targetMember.ban({ reason });
              } catch {}
            } else if (!isTesting && !targetMember && flowAction === "ban" && interaction.guild) {
              try { await interaction.guild.members.ban(uid, { reason }); } catch {}
            }
            await sendUserDM(targetMember || targetUser, flowAction === "kick" ? "kicked" : "banned", null, reason);
            await sendModLog(client, targetMember || targetUser, interaction.user, flowAction === "kick" ? "kicked" : "banned", reason, true, null, null);
            pendingPunishments.delete(key);
            await interaction.reply({ content: `${EMOJI_SUCCESS} ${flowAction === "kick" ? "Kick" : "Ban"} issued${isTesting ? " (testing)" : ""}.`, flags: 1<<6 }).catch(() => {});
            // restore original message buttons to top row
            try {
              if (state.originChannelId && state.originMessageId) {
                const channel = await client.channels.fetch(state.originChannelId).catch(() => null);
                const msg = await channel?.messages?.fetch?.(state.originMessageId).catch(() => null);
                if (msg) {
                  await msg.edit({ components: [buildTopRow()] }).catch(() => {});
                }
              }
            } catch {}
            return;
          }
        }

        // Warn/mute/unmute actions
        if (act === "addwarn") {
          // Persist a warning and evaluate simple escalation
          ensureStores();
          const store = getStore();
          const arr = Array.isArray(store[uid]) ? store[uid] : [];
          const entry = { moderator: interaction.user.id, reason: null, date: Date.now(), logMsgId: null };
          arr.push(entry);
          store[uid] = arr;
          saveStore();

          const total = arr.length;
          const esc = config.escalation || {};
          const muteT = Math.max(1, Number(esc.muteThreshold || 3));
          const kickT = Math.max(muteT + 1, Number(esc.kickThreshold || 5));
          const muteMs = Number.isFinite(esc.muteDuration) ? esc.muteDuration : 2 * 60 * 60 * 1000;

          let extra = null, durText = null;
          if (total >= kickT) {
            extra = `Due to reaching ${total} warnings, you have been kicked.`;
            if (!isTesting && targetMember) { try { await targetMember.kick(); } catch {} }
          } else if (total >= muteT) {
            extra = `Due to reaching ${total} warnings, you have been muted.`;
            if (!isTesting && targetMember) { try { await targetMember.timeout(Math.min(muteMs, 14*24*60*60*1000)); } catch {} }
            const ms = require("ms"); durText = ms(muteMs, { long: true });
          }
          // remaining line
          let remainingLine = null;
          if (total < muteT) remainingLine = `${muteT - total} warning${muteT - total === 1 ? "" : "s"} remaining until mute`;
          else if (total < kickT) remainingLine = `${kickT - total} warning${kickT - total === 1 ? "" : "s"} remaining until kick`;

          await sendUserDM(targetMember || targetUser, "warned", durText, null, `${remainingLine ? remainingLine+"\n" : ""}${extra || ""}`.trim());
          const combinedReason = extra || null;
          const nxtRemain = remainingLine ? parseInt((remainingLine.match(/^(\d+)/)||[0,0])[1],10)||0 : 0;
          await sendModLog(client, targetMember || targetUser, interaction.user, "warned", combinedReason, true, durText, nxtRemain);
          // Refresh submenu state
          const count = arr.length;
          const rows = [
            new ActionRowBuilder().addComponents(
              semanticButton('nav', { id: `modact:addwarn:${uid}`, label: 'Warn+', emoji: '➕' }),
              semanticButton('nav', { id: `modact:removewarn:${uid}`, label: 'Warn-', emoji: '➖', enabled: count !== 0 }),
              semanticButton('nav', { id: `modact:back:${uid}`, label: 'Back', emoji: '⬅️' })
            )
          ];
          await interaction.deferUpdate().catch(() => {});
          try { await interaction.message.edit({ components: rows }); } catch {}
          return;
        }

        if (act === "removewarn") {
          // Remove last warning if exists
          ensureStores();
          const store = getStore();
          const arr = Array.isArray(store[uid]) ? store[uid] : [];
          if (!arr.length) {
            await interaction.deferUpdate().catch(() => {});
            return;
          }
          const removed = arr.pop();
          store[uid] = arr; saveStore();
          // recompute remaining
          const esc = config.escalation || {};
          const muteT = Math.max(1, Number(esc.muteThreshold || 3));
          const kickT = Math.max(muteT + 1, Number(esc.kickThreshold || 5));
          let remainingLine = null;
          if (arr.length < muteT) remainingLine = `${muteT - arr.length} warning${muteT - arr.length === 1 ? "" : "s"} remaining until mute`;
          else if (arr.length < kickT) remainingLine = `${kickT - arr.length} warning${kickT - arr.length === 1 ? "" : "s"} remaining until kick`;
          const nxtRemain = remainingLine ? parseInt((remainingLine.match(/^(\d+)/)||[0,0])[1],10)||0 : 0;
          await sendUserDM(targetMember || targetUser, "warning removed", null, null, null);
          const reasonForLog = remainingLine ? `${removed?.reason || "No reason"}\n\n${remainingLine}` : `${removed?.reason || "No reason"}`;
          await sendModLog(client, targetMember || targetUser, interaction.user, "warning removed", reasonForLog, true, null, nxtRemain);
          const count = arr.length;
          const rows = [
            new ActionRowBuilder().addComponents(
              semanticButton('nav', { id: `modact:addwarn:${uid}`, label: 'Warn+', emoji: '➕' }),
              semanticButton('nav', { id: `modact:removewarn:${uid}`, label: 'Warn-', emoji: '➖', enabled: count !== 0 }),
              semanticButton('nav', { id: `modact:back:${uid}`, label: 'Back', emoji: '⬅️' })
            )
          ];
          await interaction.deferUpdate().catch(() => {});
          try { await interaction.message.edit({ components: rows }); } catch {}
          return;
        }

        if (act === "mute") {
          // Apply timeout if possible
          if (!isTesting && targetMember && typeof targetMember.timeout === "function" && Number.isFinite(durMs)) {
            try { await targetMember.timeout(Math.min(durMs, 14 * 24 * 60 * 60 * 1000)); } catch {}
          }
          const ms = require("ms");
          const durText = Number.isFinite(durMs) ? ms(durMs, { long: true }) : null;
          await sendUserDM(targetMember || targetUser, "muted", durText, null);
          await sendModLog(client, targetMember || targetUser, interaction.user, "muted", null, true, durText, null);
          // Refresh mute submenu
          const isTimedOut = !!(targetMember?.communicationDisabledUntilTimestamp && targetMember.communicationDisabledUntilTimestamp > Date.now());
          const rows = [
            new ActionRowBuilder().addComponents(
              new ButtonBuilder().setCustomId(`modact:mute:${uid}:3600000`).setLabel("1h").setStyle(ButtonStyle.Danger).setEmoji("⏱️"),
              new ButtonBuilder().setCustomId(`modact:mute:${uid}:7200000`).setLabel("2h").setStyle(ButtonStyle.Danger).setEmoji("⏱️"),
              new ButtonBuilder().setCustomId(`modact:mute:${uid}:21600000`).setLabel("6h").setStyle(ButtonStyle.Danger).setEmoji("⏱️"),
              new ButtonBuilder().setCustomId(`modact:mute:${uid}:86400000`).setLabel("24h").setStyle(ButtonStyle.Danger).setEmoji("⏱️")
            ),
            new ActionRowBuilder().addComponents(
              new ButtonBuilder().setCustomId(`modact:unmute:${uid}`).setLabel("Unmute").setStyle(ButtonStyle.Success).setEmoji("✅").setDisabled(!isTimedOut),
              new ButtonBuilder().setCustomId(`modact:back:${uid}`).setLabel("Back").setStyle(ButtonStyle.Secondary).setEmoji("⬅️")
            )
          ];
          await interaction.deferUpdate().catch(() => {});
          try { await interaction.message.edit({ components: rows }); } catch {}
          return;
        }

        if (act === "unmute") {
          if (!isTesting && targetMember) {
            try { if (typeof targetMember.timeout === "function") await targetMember.timeout(null); } catch {}
          }
          await sendUserDM(targetMember || targetUser, "unmuted");
          await sendModLog(client, targetMember || targetUser, interaction.user, "unmuted", null, false, null, null);
          const isTimedOut = !!(targetMember?.communicationDisabledUntilTimestamp && targetMember.communicationDisabledUntilTimestamp > Date.now());
          const rows = [
            new ActionRowBuilder().addComponents(
              new ButtonBuilder().setCustomId(`modact:mute:${uid}:3600000`).setLabel("1h").setStyle(ButtonStyle.Danger).setEmoji("⏱️"),
              new ButtonBuilder().setCustomId(`modact:mute:${uid}:7200000`).setLabel("2h").setStyle(ButtonStyle.Danger).setEmoji("⏱️"),
              new ButtonBuilder().setCustomId(`modact:mute:${uid}:21600000`).setLabel("6h").setStyle(ButtonStyle.Danger).setEmoji("⏱️"),
              new ButtonBuilder().setCustomId(`modact:mute:${uid}:86400000`).setLabel("24h").setStyle(ButtonStyle.Danger).setEmoji("⏱️")
            ),
            new ActionRowBuilder().addComponents(
              new ButtonBuilder().setCustomId(`modact:unmute:${uid}`).setLabel("Unmute").setStyle(ButtonStyle.Success).setEmoji("✅").setDisabled(!isTimedOut),
              new ButtonBuilder().setCustomId(`modact:back:${uid}`).setLabel("Back").setStyle(ButtonStyle.Secondary).setEmoji("⬅️")
            )
          ];
          await interaction.deferUpdate().catch(() => {});
          try { await interaction.message.edit({ components: rows }); } catch {}
          return;
        }

        if (act === "kick" || act === "ban") {
          // Legacy direct actions not used; route to init flow
          await interaction.deferUpdate().catch(() => {});
          return;
        }

        // Unknown/modact fallthrough
  await interaction.reply({ content: `${EMOJI_ERROR} Unknown action.`, flags: 1<<6 }).catch(() => {});
        return;
      }

      // StaffTeam Chatbox Button
      if (interaction.isButton() && interaction.customId === CHATBOX_BUTTON_ID) {
        const member = interaction.member;
        const hasRole = member.roles.cache.some(role => ALLOWED_ROLES.includes(role.id));
        if (!hasRole) {
          await interaction.reply({ content: "You are not allowed to use this", flags: 1<<6 });
          return;
        }
        await interaction.showModal(
          new ModalBuilder()
            .setCustomId("staffteam_chatbox_modal")
            .setTitle("Staff Team Chatbox")
            .addComponents(
              new ActionRowBuilder().addComponents(
                new TextInputBuilder()
                  .setCustomId("chatbox_input")
                  .setLabel("Type your message")
                  .setStyle(TextInputStyle.Paragraph)
                  .setRequired(true)
              )
            )
        );
        return;
      }

      // StaffTeam Chatbox Modal Submit
      if (interaction.type === InteractionType.ModalSubmit && interaction.customId === "staffteam_chatbox_modal") {
        const member = interaction.member;
        const hasRole = member.roles.cache.some(role => ALLOWED_ROLES.includes(role.id));
        if (!hasRole) {
          await interaction.reply({ content: "You are not allowed to use this.", flags: 1<<6 });
          return;
        }
        const messageContent = interaction.fields.getTextInputValue("chatbox_input");
        const channel = await client.channels.fetch("1232701768383729790").catch(() => null);
        if (channel) {
          await channel.send({ content: `💬 **Staff Chatbox Message from <@${member.id}>:**\n${messageContent}` });
        }
  await interaction.reply({ content: "Your message has been sent!", flags: 1<<6 });
        return;
      }

      // Event notification signup button (role toggle)
      if (interaction.isButton() && interaction.customId.startsWith('event_notify_')) {
        const NOTIFY_ROLE_ID = '1380303846877696153';
        const member = interaction.member;
  if (!member) { await interaction.reply({ content: 'Could not resolve member.', flags: 1<<6 }).catch(()=>{}); return; }
        const hasRole = member.roles.cache.has(NOTIFY_ROLE_ID);
        try {
          if (hasRole) {
            await member.roles.remove(NOTIFY_ROLE_ID, 'Toggle event notification subscription');
            await interaction.reply({ content: `Removed role: <@&${NOTIFY_ROLE_ID}>. You will no longer receive notifications for this event.`, flags: 1<<6 }).catch(()=>{});
          } else {
            await member.roles.add(NOTIFY_ROLE_ID, 'Toggle event notification subscription');
            await interaction.reply({ content: `Granted role: <@&${NOTIFY_ROLE_ID}>. You will now be notified whenever this event starts.`, flags: 1<<6 }).catch(()=>{});
          }
          // Removed dynamic label toggle per request: keep the button text constant for all users.
        } catch (e) {
          await interaction.reply({ content: 'Failed to toggle role: '+ (e.message||e), flags: 1<<6 }).catch(()=>{});
        }
        return;
      }

      // Snipe config modal submit (add/remove channel)
      if (
        interaction.type === InteractionType.ModalSubmit &&
        interaction.customId.startsWith("modal_snipe_")
      ) {
        const parts = interaction.customId.split("_");
        // modal_snipe_{action}_{messageId}_{category}_{setting}
        const action = parts[2];
        const originMessageId = parts[3];
        const originCategory = parts[4];
        const originSetting = parts[5];
        const raw = interaction.fields.getTextInputValue("channelInput");
        const channelId = (raw || "").replace(/[^0-9]/g, "");
        const channel = interaction.guild?.channels?.cache?.get(channelId);
        if (!channel) {
          await interaction.reply({ content: `${EMOJI_ERROR} Invalid or unknown channel.`, flags: 1<<6 });
          return;
        }

        const mode = config.snipeMode === "blacklist" ? "blacklist" : "whitelist";
        if (mode === "whitelist") {
          if (action === "addChannel") {
            if (!Array.isArray(config.snipingWhitelist)) config.snipingWhitelist = [];
            if (!config.snipingWhitelist.includes(channel.id)) {
              config.snipingWhitelist.push(channel.id);
              saveConfig();
              await interaction.reply({ content: `${EMOJI_SUCCESS} Added <#${channel.id}> to whitelist.`, flags: 1<<6 });
            } else {
              await interaction.reply({ content: `${EMOJI_ERROR} Channel already in whitelist.`, flags: 1<<6 });
            }
          } else if (action === "removeChannel") {
            if (Array.isArray(config.snipingWhitelist) && config.snipingWhitelist.includes(channel.id)) {
              config.snipingWhitelist = config.snipingWhitelist.filter(id => id !== channel.id);
              saveConfig();
              await interaction.reply({ content: `${EMOJI_SUCCESS} Removed <#${channel.id}> from whitelist.`, flags: 1<<6 });
            } else {
              await interaction.reply({ content: `${EMOJI_ERROR} Channel not in whitelist.`, flags: 1<<6 });
            }
          } else {
            await interaction.reply({ content: `${EMOJI_ERROR} Unknown action.`, flags: 1<<6 });
          }
        } else {
          // blacklist mode uses snipingChannelList
          if (action === "addChannel") {
            if (!Array.isArray(config.snipingChannelList)) config.snipingChannelList = [];
            if (!config.snipingChannelList.includes(channel.id)) {
              config.snipingChannelList.push(channel.id);
              saveConfig();
              await interaction.reply({ content: `${EMOJI_SUCCESS} Added <#${channel.id}> to blacklist.`, flags: 1<<6 });
            } else {
              await interaction.reply({ content: `${EMOJI_ERROR} Channel already in blacklist.`, flags: 1<<6 });
            }
          } else if (action === "removeChannel") {
            if (Array.isArray(config.snipingChannelList) && config.snipingChannelList.includes(channel.id)) {
              config.snipingChannelList = config.snipingChannelList.filter(id => id !== channel.id);
              saveConfig();
              await interaction.reply({ content: `${EMOJI_SUCCESS} Removed <#${channel.id}> from blacklist.`, flags: 1<<6 });
            } else {
              await interaction.reply({ content: `${EMOJI_ERROR} Channel not in blacklist.`, flags: 1<<6 });
            }
          } else {
            await interaction.reply({ content: `${EMOJI_ERROR} Unknown action.`, flags: 1<<6 });
          }
        }
        // Try to refresh the original config menu message embed if visible
        try {
          if (originMessageId && originCategory && originSetting) {
            const msg = await interaction.channel.messages.fetch(originMessageId).catch(() => null);
            if (msg) {
              const { embed, row } = renderSettingEmbed(originCategory, originSetting);
              const components = Array.isArray(row) ? row : [row];
              await msg.edit({ embeds: [embed], components }).catch(() => {});
            }
          }
        } catch {}
        return;
      }

      // Schedule creation modal submit
      if (interaction.type === InteractionType.ModalSubmit && interaction.customId.startsWith("schedule_create_modal")) {
        await handleScheduleModal(interaction);
        return;
      }
      // Event creation modal submit (id pattern: event_create_modal_<managerMessageId>)
      if (interaction.type === InteractionType.ModalSubmit && interaction.customId.startsWith("event_create_modal")) {
        await handleEventCreateModal(interaction);
        return;
      }
      if (interaction.type === InteractionType.ModalSubmit && /^event_(times|days|msg|edit)_modal_/.test(interaction.customId)) {
        await handleEventEditModal(interaction);
        return;
      }
  // Auto message notification modals (add / offset / message / channel / unified edit)
  if (interaction.type === InteractionType.ModalSubmit && /^(notif_(add|offset|msg|channel|edit)_modal_)/.test(interaction.customId)) {
        await handleEventNotificationModal(interaction);
        return;
      }

      // Clock-In position select
      if (interaction.isStringSelectMenu() && interaction.customId.startsWith('clockin:')) {
        const parts = interaction.customId.split(':'); // clockin:eventId:notifId
        const evId = parts[1];
        const notifId = parts[2]; // not used yet for constraints
        let ev = getEvent(evId);
        if (!ev) {
          try { const { getEvent: ge } = require('../utils/eventsStorage'); ev = ge(evId); } catch {}
        }
        // Fallback: try to resolve by message id if the event id was not found (e.g., after restart)
        if (!ev && interaction.message?.id) {
          try {
            const { getEvents } = require('../utils/eventsStorage');
            const all = getEvents();
            ev = all.find(e => Array.isArray(e.__clockIn?.messageIds) && e.__clockIn.messageIds.includes(interaction.message.id)) || null;
          } catch {}
        }
        if (!ev) { await interaction.reply({ content:'Event missing.', flags:1<<6 }).catch(()=>{}); return; }
        const member = interaction.member;
  if (!member) { await interaction.reply({ content:'Member not found.', flags:1<<6 }).catch(()=>{}); return; }
        const choice = interaction.values[0];
        const ROLE_REQUIRED = '1375958480380493844';
        const POS_META = {
          'instance_manager': { label: 'Instance Manager', max:1, role: ROLE_REQUIRED },
          'manager': { label: 'Manager', max:Infinity, role: ROLE_REQUIRED },
          'bouncer': { label: 'Bouncer', max:Infinity },
          'bartender': { label: 'Bartender', max:Infinity },
          'backup': { label: 'Backup', max:Infinity },
          'maybe': { label: 'Maybe/Late', max:Infinity }
        };
  if (!POS_META[choice]) { await interaction.reply({ content:'Invalid selection.', flags:1<<6 }).catch(()=>{}); return; }
        const meta = POS_META[choice];
        if (meta.role && !member.roles.cache.has(meta.role)) {
          await interaction.reply({ content:`You need the required role to select ${meta.label}.`, flags:1<<6 }).catch(()=>{}); return;
        }
        const clockKey = '__clockIn';
        const state = ev[clockKey] && typeof ev[clockKey]==='object' ? { ...ev[clockKey] } : { positions: {}, messageIds: [] };
        if (!state.positions) state.positions = {};
        // Remove user from all other positions first
        for (const key of Object.keys(state.positions)) {
          state.positions[key] = Array.isArray(state.positions[key]) ? state.positions[key].filter(id=>id!==member.id) : [];
        }
        if (!Array.isArray(state.positions[choice])) state.positions[choice] = [];
  if (meta.max !== Infinity && state.positions[choice].length >= meta.max) {
          await interaction.reply({ content:`${meta.label} is full.`, flags:1<<6 }).catch(()=>{}); return;
        }
        state.positions[choice].push(member.id);
        updateEvent(ev.id, { [clockKey]: state });
        // Re-render all clock-in messages for this event
        try {
          // Build embed JSON per the required template (keeps IM limited, others unlimited)
          const fmtMentions = (arr=[]) => {
            if (!Array.isArray(arr) || arr.length === 0) return '*None*';
            const s = arr.map(id=>`<@${id}>`).join(', ');
            return config.testingMode ? s.replace(/<@&?\d+>/g, m=>`\`${m}\``) : s;
          };
          const nameSafe = ev.name || 'Event';
          const embed = {
            title: `🕒 Staff Clock In — ${nameSafe}`,
            description: 'Please select your role below to clock in.\n\n**Instance Manager** is responsible for opening, managing and closing an instance.',
            color: 3447003,
            fields: [
              { name: '📝 Instance Manager (1 slot)', value: `${(state.positions.instance_manager||[]).length} / 1\n${fmtMentions(state.positions.instance_manager)}`, inline: false },
              { name: '🛠️ Manager',   value: fmtMentions(state.positions.manager),   inline: true },
              { name: '🛡️ Bouncer',   value: fmtMentions(state.positions.bouncer),   inline: true },
              { name: '🍸 Bartender', value: fmtMentions(state.positions.bartender), inline: true },
              { name: '🎯 Backup',    value: fmtMentions(state.positions.backup),    inline: true },
              { name: '⏳ Maybe / Late', value: fmtMentions(state.positions.maybe), inline: false },
              { name: 'Eligible roles', value: '<@&1375995842858582096>, <@&1380277718091829368>, <@&1380323145621180466>, <@&1375958480380493844>' }
            ],
            footer: { text: `Late Night Hours | Staff clock in for ${nameSafe}` }
          };
          // Choose a channel: prefer stored clock-in channel, then event channel, finally current interaction channel
          const chId = (ev.__clockIn && ev.__clockIn.channelId) || ev.channelId || interaction.channelId;
          const channel = chId ? (await interaction.client.channels.fetch(chId).catch(()=>null)) : null;
          for (const mid of state.messageIds || []) {
            try {
              const msg = channel && channel.messages ? await channel.messages.fetch(mid).catch(()=>null) : null;
              if (msg) await msg.edit({ content: '', embeds:[embed] }).catch(()=>{});
            } catch {}
          }
        } catch {}
  await interaction.reply({ content:`Registered as ${meta.label}.`, flags:1<<6 }).catch(()=>{});
        return;
      }
    } catch (err) {
      console.error("[Interaction Error]", err);
      if (interaction.isRepliable() && !interaction.replied && !interaction.deferred) {
  await interaction.reply({ content: `An error occurred.\n${err.message || err}`, flags: 1<<6 }).catch(() => {});
      }
    }
  });
}

module.exports = { attachInteractionEvents };

```

===== FILE: events/messages.js =====
```javascript
const { handleHelpCommand } = require("../commands/help");
const path = require('path'); // needed for restart spawn entry resolution
const { handleModerationCommands } = require("../commands/moderation/moderationCommands");
const { handlePurgeCommand } = require("../commands/moderation/purge");
const { handleWarningsCommand } = require("../commands/moderation/warnings");
const { handleSnipeCommands } = require("../commands/snipes");
const { handleMessageCreate } = require("../commands/configMenu");
// Rank/profile consolidated in profile command
const { handleRankCommand } = require("../commands/profile");
const { handleTestCommand } = require("../commands/test");
const { handleLeaderboardCommand } = require("../commands/leaderboard");
const { handleProfileCommand } = require("../commands/profile");
const { handleDiagnosticsCommand } = require("../commands/diagnostics");
const { handleLeveling } = require("../utils/leveling");
const { handleScheduleCommand } = require("../commands/schedule");
const { handleScriptsCommand } = require("../commands/scripts");
const { maybeSpawnDrop, tryClaimDrop } = require("../utils/cashDrops");
const { EmbedBuilder, ActionRowBuilder, ButtonBuilder, ButtonStyle } = require("discord.js");
const { semanticButton, buildNavRow } = require('../utils/ui');
const { config } = require("../utils/storage");
const { handleCashCommand } = require("../commands/cash");
const { handleBalanceCommand } = require("../commands/balance");
const { handleMetricsCommand } = require("../commands/metrics");
const { handleClockInStateCommand } = require("../commands/clockin");
const { markCommand } = require('../services/metricsService');
const { checkPolicy } = require('../utils/policy');
const theme = require("../utils/theme");
const { TEST_LOG_CHANNEL } = require("../utils/logChannels");
const { snapshotSessions } = require("../utils/activeMenus");
const { levels } = require("../utils/levels");
const { vcLevels } = require("../utils/vcLevels");
const { getTopCash } = require("../utils/cash");
const { getRecentErrors, clearErrorLog } = require('../utils/errorUtil');
// Simple in-memory command cooldowns
const _cooldowns = new Map(); // key cmd:user -> lastTs
function cdOk(userId, cmd, ms=2000) {
  const k = cmd+':'+userId; const now = Date.now(); const prev = _cooldowns.get(k)||0; if (now - prev < ms) return false; _cooldowns.set(k, now); return true;
}
const ActiveMenus = require('../utils/activeMenus');

const LEVEL_ROLES = {
  5: "1232701768362754147",
  10: "1232701768362754148",
  16: "1232701768375210145",
  20: "1232701768375210146",
  25: "1232701768375210147",
  40: "1232701768375210149",
  75: "1382911184058978454",
  100: "1232701768375210148"
};

function attachMessageEvents(client) {
  if (client.__messageListenerAttached) return; // prevent multiple registrations
  client.__messageListenerAttached = true;
  client.on("messageCreate", async (message) => {
    if (message.author.bot) return;
    // Global duplicate guard (prevents double XP, drops, and command replies if listener attached twice)
    try {
      const set = (client.__handledMessages = client.__handledMessages || new Set());
      if (set.has(message.id)) return; // already fully processed
      set.add(message.id);
      if (set.size > 10000) { // prune oldest ~20%
        let i = 0; for (const id of set) { set.delete(id); if (++i > 2000) break; }
      }
    } catch {}
    // Award leveling XP for all non-bot messages (gated in handleLeveling by channel rules)
    await handleLeveling(message, LEVEL_ROLES);
    // Cash drops: first check if a drop can be claimed by this message
    const claimed = tryClaimDrop(message);
    if (claimed) {
      const testTag = claimed.testing ? " [TEST]" : "";
      const claimEmbed = new EmbedBuilder()
        .setTitle(`🎉 Cash Claimed${testTag}`)
        .setColor(theme.colors.success)
        .setDescription(`Looks like someone snagged the bag! You received **$${claimed.amount.toLocaleString()}**.`)
        .addFields({ name: "New Balance", value: `${claimed.testing ? "(test) " : ""}$${Number(claimed.newBalance || 0).toLocaleString()}` , inline: true })
        .setFooter({ text: "Keep chatting for more surprise drops!" });
      const row = buildNavRow([
        semanticButton('primary', { id: claimed.testing ? 'cash:check:test' : 'cash:check', label: 'Balance', emoji: '💳' })
      ]);
      try { await message.reply({ embeds: [claimEmbed], components: [row], allowedMentions: { repliedUser: false } }); } catch {}
    } else {
      const drop = maybeSpawnDrop(message, config);
      if (drop) {
        const isTest = !!drop.testing;
    const spawnEmbed = new EmbedBuilder()
          .setTitle(`${isTest ? "🧪 " : ""}💸 A Wild Cash Drop Appeared!`)
          .setColor(theme.colors.warning)
          .setDescription(
            `It looks like someone dropped some cash!\n` +
            `Type this word to claim it first:\n\n` +
            `→ \`${drop.word}\``
          )
          .addFields(
      { name: "Reward", value: `**$${drop.amount.toLocaleString()}**`, inline: true },
            { name: "How", value: "Send the word exactly as shown.", inline: true }
          )
          .setFooter({ text: "First correct message wins. Good luck!" });
  try { await message.reply({ embeds: [spawnEmbed], allowedMentions: { repliedUser: false } }); } catch {}
      }
    }

  if (!message.content.startsWith(".")) return;

    const args = message.content.slice(1).trim().split(/\s+/);
    const command = args.shift().toLowerCase();

  const { start: logStart, finish: logFinish, normalizeMsgShape, diffExpected } = require('../utils/commandLogger');
  let _logCtx = null; let _sentMsg = null; let _expected = null;
  try {
      if (command === "help") {
    _logCtx = logStart({ name: 'help', userId: message.author.id, channelId: message.channelId, guildId: message.guildId, input: { content: message.content } });
    _sentMsg = await handleHelpCommand(client, message); markCommand();
      } else if (["mute", "unmute", "timeout", "untimeout", "ban", "kick", "warn", "removewarn"].includes(command)) {
        if (!checkPolicy(command, message)) return;
        if (!cdOk(message.author.id, command, 2500)) return;
    _logCtx = logStart({ name: command, userId: message.author.id, channelId: message.channelId, guildId: message.guildId, input: { content: message.content, args } });
    _sentMsg = await handleModerationCommands(client, message, command, args); markCommand();
      } else if (command === 'purge' || command === 'clean') {
        if (!checkPolicy('purge', message)) return;
        if (!cdOk(message.author.id, 'purge', 5000)) return;
    _logCtx = logStart({ name: 'purge', userId: message.author.id, channelId: message.channelId, guildId: message.guildId, input: { content: message.content, args } });
    _sentMsg = await handlePurgeCommand(client, message, args); markCommand();
      } else if (["snipe", "s", "ds"].includes(command)) {
    _logCtx = logStart({ name: 'snipe', userId: message.author.id, channelId: message.channelId, guildId: message.guildId, input: { content: message.content, alias: command, args } });
    _sentMsg = await handleSnipeCommands(client, message, command, args); markCommand();
      } else if (command === "warnings" || command === "warns") {
    _logCtx = logStart({ name: 'warnings', userId: message.author.id, channelId: message.channelId, guildId: message.guildId, input: { content: message.content } });
    _sentMsg = await handleWarningsCommand(client, message); markCommand();
      } else if (command === "config") {
        if (!checkPolicy('config', message)) return;
    _logCtx = logStart({ name: 'config', userId: message.author.id, channelId: message.channelId, guildId: message.guildId, input: { content: message.content } });
    _sentMsg = await handleMessageCreate(client, message); markCommand();
      } else if (command === "level" || command === "rank") {
    _logCtx = logStart({ name: 'rank', userId: message.author.id, channelId: message.channelId, guildId: message.guildId, input: { content: message.content } });
    _sentMsg = await handleRankCommand(client, message); markCommand();
      } else if (command === "profile" || command === "p") {
    _logCtx = logStart({ name: 'profile', userId: message.author.id, channelId: message.channelId, guildId: message.guildId, input: { content: message.content } });
    _sentMsg = await handleProfileCommand(client, message); markCommand();
      } else if (command === "test") {
        if (!checkPolicy('test', message)) return;
    _logCtx = logStart({ name: 'test', userId: message.author.id, channelId: message.channelId, guildId: message.guildId, input: { content: message.content } });
    _sentMsg = await handleTestCommand(client, message); markCommand();
      } else if (command === "leaderboard" || command === "lb") {
    _logCtx = logStart({ name: 'leaderboard', userId: message.author.id, channelId: message.channelId, guildId: message.guildId, input: { content: message.content } });
    _sentMsg = await handleLeaderboardCommand(client, message); markCommand();
      } else if (command === "restart") {
        if (message.author.id !== process.env.OWNER_ID) return;
        // Record restart timestamp for next boot to compute downtime
        try {
          const fs = require("fs");
            fs.writeFileSync("./config/lastShutdown.json", JSON.stringify({ ts: Date.now() }));
        } catch {}
        await message.reply({ content: "🔄 Restarting bot...", allowedMentions: { repliedUser: false } }).catch(() => {});
        // Spawn a tiny helper that waits for lock to clear, then starts index.js
        try {
          const { spawn } = require('child_process');
          const nodeExec = process.argv[0];
          const helper = path.resolve(__dirname, '..', 'scripts', 'restartHelper.js');
          const child = spawn(nodeExec, [helper], {
            cwd: process.cwd(),
            env: process.env,
            detached: true,
            stdio: 'ignore',
            windowsHide: true
          });
          child.unref();
        } catch (e) {
          console.error('[restart spawn failed]', e);
          // Fall back to plain exit (expect external supervisor like pm2/systemd/VSCode to restart)
        }
        setTimeout(() => process.exit(0), 200);
      } else if (command === "stop") {
        if (message.author.id !== process.env.OWNER_ID) return;
        await message.reply("🛑 Stopping bot...");
        process.exit(0);
    } else if (command === "schedule") {
  _logCtx = logStart({ name: 'schedule', userId: message.author.id, channelId: message.channelId, guildId: message.guildId, input: { content: message.content } });
  _sentMsg = await handleScheduleCommand(client, message);
      } else if (command === "scripts") {
  _logCtx = logStart({ name: 'scripts', userId: message.author.id, channelId: message.channelId, guildId: message.guildId, input: { content: message.content } });
  _sentMsg = await handleScriptsCommand(client, message); markCommand();
      } else if (command === "cash") {
  _logCtx = logStart({ name: 'cash', userId: message.author.id, channelId: message.channelId, guildId: message.guildId, input: { content: message.content } });
  _sentMsg = await handleCashCommand(client, message); markCommand();
      } else if (command === "balance" || command === "bal") {
  _logCtx = logStart({ name: 'balance', userId: message.author.id, channelId: message.channelId, guildId: message.guildId, input: { content: message.content } });
  _sentMsg = await handleBalanceCommand(client, message); markCommand();
      } else if (command === "diag" || command === "diagnostics") {
  _logCtx = logStart({ name: 'diagnostics', userId: message.author.id, channelId: message.channelId, guildId: message.guildId, input: { content: message.content } });
  _sentMsg = await handleDiagnosticsCommand(client, message); markCommand();
      } else if (command === 'metrics') {
  _logCtx = logStart({ name: 'metrics', userId: message.author.id, channelId: message.channelId, guildId: message.guildId, input: { content: message.content } });
  _sentMsg = await handleMetricsCommand(client, message); markCommand();
  } else if (command === 'clockinstate') {
  _logCtx = logStart({ name: 'clockinstate', userId: message.author.id, channelId: message.channelId, guildId: message.guildId, input: { content: message.content } });
  _sentMsg = await handleClockInStateCommand(client, message); markCommand();
  } else if (command === 'errors' || command === 'err') {
        if (message.author.id !== process.env.OWNER_ID) return;
  _logCtx = logStart({ name: 'errors', userId: message.author.id, channelId: message.channelId, guildId: message.guildId, input: { content: message.content, args } });
        // Accept patterns: .errors, .errors 25, .errors embed 25, .errors 25 embed
        const embedMode = args.some(a => a.toLowerCase() === 'embed');
        const numArg = args.find(a => /^(\d+)$/.test(a));
        const limit = Math.min(50, Number(numArg) || 15);
        const recent = getRecentErrors(limit);
        if (!recent.length) return message.reply({ content: '✅ No recent errors recorded.', allowedMentions: { repliedUser: false } });
        const rows = recent.map((e,i) => ({
          idx: i,
          ts: new Date(e.ts).toISOString().replace('T',' ').replace('Z',''),
          scope: e.scope,
          first: (e.message||'').split('\n')[0].slice(0, 200)
        }));
        if (!embedMode) {
          const lines = rows.map(r => `#${r.idx} ${r.ts.split(' ')[1]} [${r.scope}] ${r.first}`);
          const content = '🧾 Recent Errors (newest last)\n' + lines.join('\n');
          _sentMsg = await message.reply({ content: content.slice(0, 1900), allowedMentions: { repliedUser: false } });
          return;
        }
        // Embed mode
        const { createEmbed, safeAddField } = require('../utils/embeds');
        const pageSize = 10;
        const totalPages = Math.max(1, Math.ceil(rows.length / pageSize));
        const buildPage = (page) => {
          const start = page * pageSize;
          const slice = rows.slice(start, start + pageSize);
          const embed = createEmbed({ title: '🧾 Recent Errors', description: `Page ${page+1}/${totalPages} • ${rows.length} item(s)`, color: 'danger' });
          for (const r of slice) {
            safeAddField(embed, `#${r.idx} [${r.scope}] ${r.ts.split(' ')[1]}`, r.first || '(no message)');
          }
          return embed;
        };
        const { ActionRowBuilder, ButtonBuilder, ButtonStyle } = require('discord.js');
        const row = (page) => buildNavRow([
          semanticButton('nav', { id: 'err_prev', label: 'Prev', enabled: page!==0 }),
          semanticButton('nav', { id: 'err_next', label: 'Next', enabled: page < totalPages-1 }),
          semanticButton('primary', { id: 'err_refresh', label: 'Refresh' })
        ]);
  _sentMsg = await message.reply({ embeds: [buildPage(0)], components: [row(0)], allowedMentions: { repliedUser: false } });
  ActiveMenus.registerMessage(_sentMsg, { type: 'errors', userId: message.author.id, data: { page: 0, limit } });
      } else if (command === 'clearerrors' || command === 'cerr') {
        if (message.author.id !== process.env.OWNER_ID) return;
        clearErrorLog();
  _logCtx = logStart({ name: 'clearerrors', userId: message.author.id, channelId: message.channelId, guildId: message.guildId, input: { content: message.content } });
  _sentMsg = await message.reply({ content: '🧹 Error log cleared.', allowedMentions: { repliedUser: false } });
      } else if (command === 'errdetail') {
        if (message.author.id !== process.env.OWNER_ID) return;
        const idx = Number(args[0]);
  _logCtx = logStart({ name: 'errdetail', userId: message.author.id, channelId: message.channelId, guildId: message.guildId, input: { content: message.content, args } });
  if (!Number.isInteger(idx)) { _sentMsg = await message.reply({ content: 'Provide an index from .errors list.', allowedMentions:{repliedUser:false}}); return; }
        const full = getRecentErrors(100);
  if (idx < 0 || idx >= full.length) { _sentMsg = await message.reply({ content: 'Index out of range.', allowedMentions:{repliedUser:false}}); return; }
        const entry = full[idx];
        const { createEmbed, addChunkedField } = require('../utils/embeds');
        const embed = createEmbed({ title: `Error #${idx} [${entry.scope}]`, description: new Date(entry.ts).toISOString(), color: 'danger' });
        addChunkedField(embed, 'Stack / Message', entry.message, 950);
  _sentMsg = await message.reply({ embeds:[embed], allowedMentions:{repliedUser:false}});
      }
    } catch (err) {
      console.error(`[Message Command Error]:`, err);
      message.reply(`<:VRLSad:1413770577080094802> An error occurred while executing \`${command}\`.\nDetails: \`${err.message || err}\``);
    }

    // finalize logging for commands we wrapped
    try {
      if (_logCtx) {
        const actual = normalizeMsgShape(_sentMsg);
        let diff = null;
        if (config.testingMode && _expected) diff = diffExpected(actual, _expected);
        logFinish(client, _logCtx, { actual, expected: _expected || null, diff });
      }
    } catch {}

    // Already handled above for all messages
  });
}

module.exports = { attachMessageEvents };

// Register interactive errors menu handler
try {
  const { createEmbed, safeAddField } = require('../utils/embeds');
  ActiveMenus.registerHandler('errors', async (interaction, session) => {
    if (!interaction.isButton()) return;
    if (interaction.user.id !== session.userId) {
  return interaction.reply({ content: 'Not your session.', flags: 1<<6 }).catch(()=>{});
    }
    const { customId } = interaction;
    const { getRecentErrors } = require('../utils/errorUtil');
    let page = session.data.page || 0;
    const limit = session.data.limit || 15;
    const rows = getRecentErrors(limit).map((e,i) => ({
      idx: i,
      ts: new Date(e.ts).toISOString().replace('T',' ').replace('Z',''),
      scope: e.scope,
      first: (e.message||'').split('\n')[0].slice(0, 200)
    }));
    const pageSize = 10;
    const totalPages = Math.max(1, Math.ceil(rows.length / pageSize));
    if (customId === 'err_prev') page = Math.max(0, page - 1);
    if (customId === 'err_next') page = Math.min(totalPages - 1, page + 1);
    if (customId === 'err_refresh') page = Math.min(page, totalPages - 1);
  // Close button removed per design request
    const start = page * pageSize;
  const slice = rows.slice(start, start + pageSize);
  const embed = createEmbed({ title: '🧾 Recent Errors', description: `Page ${page+1}/${totalPages} • ${rows.length} item(s)`, color: 'danger' });
  for (const r of slice) safeAddField(embed, `#${r.idx} [${r.scope}] ${r.ts.split(' ')[1]}`, r.first || '(no message)');
    const { ActionRowBuilder, ButtonBuilder, ButtonStyle } = require('discord.js');
    const row = buildNavRow([
      semanticButton('nav', { id: 'err_prev', label: 'Prev', enabled: page!==0 }),
      semanticButton('nav', { id: 'err_next', label: 'Next', enabled: page < totalPages-1 }),
      semanticButton('primary', { id: 'err_refresh', label: 'Refresh' }),
      semanticButton('danger', { id: 'err_close', label: 'Close' })
    ]);
    session.data.page = page;
    try { await interaction.update({ embeds: [embed], components: [row] }); } catch {}
  });
} catch {}

// Purge confirmation handler
try {
  const { executePurge } = require('../commands/moderation/purge');
  ActiveMenus.registerHandler('purgeConfirm', async (interaction, session) => {
    if (!interaction.isButton()) return;
    if (interaction.user.id !== session.userId) {
  return interaction.reply({ content: 'Not your confirmation.', flags: 1<<6 }).catch(()=>{});
    }
    const { customId } = interaction;
    if (customId === 'purge_cancel') {
      try { await interaction.update({ content: 'Purge cancelled.', embeds: [], components: [] }); } catch {}
      return;
    }
    if (customId === 'purge_confirm') {
      const { count, userFilter } = session.data || {};
      try { await interaction.update({ content: 'Executing purge...', embeds: [], components: [] }); } catch {}
      // Reconstruct a pseudo message object interface for executePurge (needs channel & reply)
      const channel = interaction.channel;
      const fakeMessage = {
        channel,
        author: interaction.user,
        member: interaction.member,
        reply: (opts) => interaction.followUp ? interaction.followUp(opts) : channel.send(opts)
      };
      await require('../commands/moderation/purge').executePurge(interaction.client, fakeMessage, count, userFilter);
    }
  });
} catch {}

```

===== FILE: index.js =====
```javascript
// Thin bootstrapper to new src/ entrypoint to enable project reorganization without breaking scripts
module.exports = require('./src/index');

```

===== FILE: package-lock.json =====
```json
{
  "name": "Miyako",
  "lockfileVersion": 3,
  "requires": true,
  "packages": {
    "": {
      "dependencies": {
        "discord.js": "^14.22.1",
        "dotenv": "^17.2.2",
        "ms": "^2.1.3"
      },
      "devDependencies": {
        "jest": "^29.7.0"
      }
    },
    "node_modules/@babel/code-frame": {
      "version": "7.27.1",
      "resolved": "https://registry.npmjs.org/@babel/code-frame/-/code-frame-7.27.1.tgz",
      "integrity": "sha512-cjQ7ZlQ0Mv3b47hABuTevyTuYN4i+loJKGeV9flcCgIK37cCXRh+L1bd3iBHlynerhQ7BhCkn2BPbQUL+rGqFg==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "@babel/helper-validator-identifier": "^7.27.1",
        "js-tokens": "^4.0.0",
        "picocolors": "^1.1.1"
      },
      "engines": {
        "node": ">=6.9.0"
      }
    },
    "node_modules/@babel/compat-data": {
      "version": "7.28.4",
      "resolved": "https://registry.npmjs.org/@babel/compat-data/-/compat-data-7.28.4.tgz",
      "integrity": "sha512-YsmSKC29MJwf0gF8Rjjrg5LQCmyh+j/nD8/eP7f+BeoQTKYqs9RoWbjGOdy0+1Ekr68RJZMUOPVQaQisnIo4Rw==",
      "dev": true,
      "license": "MIT",
      "engines": {
        "node": ">=6.9.0"
      }
    },
    "node_modules/@babel/core": {
      "version": "7.28.4",
      "resolved": "https://registry.npmjs.org/@babel/core/-/core-7.28.4.tgz",
      "integrity": "sha512-2BCOP7TN8M+gVDj7/ht3hsaO/B/n5oDbiAyyvnRlNOs+u1o+JWNYTQrmpuNp1/Wq2gcFrI01JAW+paEKDMx/CA==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "@babel/code-frame": "^7.27.1",
        "@babel/generator": "^7.28.3",
        "@babel/helper-compilation-targets": "^7.27.2",
        "@babel/helper-module-transforms": "^7.28.3",
        "@babel/helpers": "^7.28.4",
        "@babel/parser": "^7.28.4",
        "@babel/template": "^7.27.2",
        "@babel/traverse": "^7.28.4",
        "@babel/types": "^7.28.4",
        "@jridgewell/remapping": "^2.3.5",
        "convert-source-map": "^2.0.0",
        "debug": "^4.1.0",
        "gensync": "^1.0.0-beta.2",
        "json5": "^2.2.3",
        "semver": "^6.3.1"
      },
      "engines": {
        "node": ">=6.9.0"
      },
      "funding": {
        "type": "opencollective",
        "url": "https://opencollective.com/babel"
      }
    },
    "node_modules/@babel/generator": {
      "version": "7.28.3",
      "resolved": "https://registry.npmjs.org/@babel/generator/-/generator-7.28.3.tgz",
      "integrity": "sha512-3lSpxGgvnmZznmBkCRnVREPUFJv2wrv9iAoFDvADJc0ypmdOxdUtcLeBgBJ6zE0PMeTKnxeQzyk0xTBq4Ep7zw==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "@babel/parser": "^7.28.3",
        "@babel/types": "^7.28.2",
        "@jridgewell/gen-mapping": "^0.3.12",
        "@jridgewell/trace-mapping": "^0.3.28",
        "jsesc": "^3.0.2"
      },
      "engines": {
        "node": ">=6.9.0"
      }
    },
    "node_modules/@babel/helper-compilation-targets": {
      "version": "7.27.2",
      "resolved": "https://registry.npmjs.org/@babel/helper-compilation-targets/-/helper-compilation-targets-7.27.2.tgz",
      "integrity": "sha512-2+1thGUUWWjLTYTHZWK1n8Yga0ijBz1XAhUXcKy81rd5g6yh7hGqMp45v7cadSbEHc9G3OTv45SyneRN3ps4DQ==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "@babel/compat-data": "^7.27.2",
        "@babel/helper-validator-option": "^7.27.1",
        "browserslist": "^4.24.0",
        "lru-cache": "^5.1.1",
        "semver": "^6.3.1"
      },
      "engines": {
        "node": ">=6.9.0"
      }
    },
    "node_modules/@babel/helper-globals": {
      "version": "7.28.0",
      "resolved": "https://registry.npmjs.org/@babel/helper-globals/-/helper-globals-7.28.0.tgz",
      "integrity": "sha512-+W6cISkXFa1jXsDEdYA8HeevQT/FULhxzR99pxphltZcVaugps53THCeiWA8SguxxpSp3gKPiuYfSWopkLQ4hw==",
      "dev": true,
      "license": "MIT",
      "engines": {
        "node": ">=6.9.0"
      }
    },
    "node_modules/@babel/helper-module-imports": {
      "version": "7.27.1",
      "resolved": "https://registry.npmjs.org/@babel/helper-module-imports/-/helper-module-imports-7.27.1.tgz",
      "integrity": "sha512-0gSFWUPNXNopqtIPQvlD5WgXYI5GY2kP2cCvoT8kczjbfcfuIljTbcWrulD1CIPIX2gt1wghbDy08yE1p+/r3w==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "@babel/traverse": "^7.27.1",
        "@babel/types": "^7.27.1"
      },
      "engines": {
        "node": ">=6.9.0"
      }
    },
    "node_modules/@babel/helper-module-transforms": {
      "version": "7.28.3",
      "resolved": "https://registry.npmjs.org/@babel/helper-module-transforms/-/helper-module-transforms-7.28.3.tgz",
      "integrity": "sha512-gytXUbs8k2sXS9PnQptz5o0QnpLL51SwASIORY6XaBKF88nsOT0Zw9szLqlSGQDP/4TljBAD5y98p2U1fqkdsw==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "@babel/helper-module-imports": "^7.27.1",
        "@babel/helper-validator-identifier": "^7.27.1",
        "@babel/traverse": "^7.28.3"
      },
      "engines": {
        "node": ">=6.9.0"
      },
      "peerDependencies": {
        "@babel/core": "^7.0.0"
      }
    },
    "node_modules/@babel/helper-plugin-utils": {
      "version": "7.27.1",
      "resolved": "https://registry.npmjs.org/@babel/helper-plugin-utils/-/helper-plugin-utils-7.27.1.tgz",
      "integrity": "sha512-1gn1Up5YXka3YYAHGKpbideQ5Yjf1tDa9qYcgysz+cNCXukyLl6DjPXhD3VRwSb8c0J9tA4b2+rHEZtc6R0tlw==",
      "dev": true,
      "license": "MIT",
      "engines": {
        "node": ">=6.9.0"
      }
    },
    "node_modules/@babel/helper-string-parser": {
      "version": "7.27.1",
      "resolved": "https://registry.npmjs.org/@babel/helper-string-parser/-/helper-string-parser-7.27.1.tgz",
      "integrity": "sha512-qMlSxKbpRlAridDExk92nSobyDdpPijUq2DW6oDnUqd0iOGxmQjyqhMIihI9+zv4LPyZdRje2cavWPbCbWm3eA==",
      "dev": true,
      "license": "MIT",
      "engines": {
        "node": ">=6.9.0"
      }
    },
    "node_modules/@babel/helper-validator-identifier": {
      "version": "7.27.1",
      "resolved": "https://registry.npmjs.org/@babel/helper-validator-identifier/-/helper-validator-identifier-7.27.1.tgz",
      "integrity": "sha512-D2hP9eA+Sqx1kBZgzxZh0y1trbuU+JoDkiEwqhQ36nodYqJwyEIhPSdMNd7lOm/4io72luTPWH20Yda0xOuUow==",
      "dev": true,
      "license": "MIT",
      "engines": {
        "node": ">=6.9.0"
      }
    },
    "node_modules/@babel/helper-validator-option": {
      "version": "7.27.1",
      "resolved": "https://registry.npmjs.org/@babel/helper-validator-option/-/helper-validator-option-7.27.1.tgz",
      "integrity": "sha512-YvjJow9FxbhFFKDSuFnVCe2WxXk1zWc22fFePVNEaWJEu8IrZVlda6N0uHwzZrUM1il7NC9Mlp4MaJYbYd9JSg==",
      "dev": true,
      "license": "MIT",
      "engines": {
        "node": ">=6.9.0"
      }
    },
    "node_modules/@babel/helpers": {
      "version": "7.28.4",
      "resolved": "https://registry.npmjs.org/@babel/helpers/-/helpers-7.28.4.tgz",
      "integrity": "sha512-HFN59MmQXGHVyYadKLVumYsA9dBFun/ldYxipEjzA4196jpLZd8UjEEBLkbEkvfYreDqJhZxYAWFPtrfhNpj4w==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "@babel/template": "^7.27.2",
        "@babel/types": "^7.28.4"
      },
      "engines": {
        "node": ">=6.9.0"
      }
    },
    "node_modules/@babel/parser": {
      "version": "7.28.4",
      "resolved": "https://registry.npmjs.org/@babel/parser/-/parser-7.28.4.tgz",
      "integrity": "sha512-yZbBqeM6TkpP9du/I2pUZnJsRMGGvOuIrhjzC1AwHwW+6he4mni6Bp/m8ijn0iOuZuPI2BfkCoSRunpyjnrQKg==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "@babel/types": "^7.28.4"
      },
      "bin": {
        "parser": "bin/babel-parser.js"
      },
      "engines": {
        "node": ">=6.0.0"
      }
    },
    "node_modules/@babel/plugin-syntax-async-generators": {
      "version": "7.8.4",
      "resolved": "https://registry.npmjs.org/@babel/plugin-syntax-async-generators/-/plugin-syntax-async-generators-7.8.4.tgz",
      "integrity": "sha512-tycmZxkGfZaxhMRbXlPXuVFpdWlXpir2W4AMhSJgRKzk/eDlIXOhb2LHWoLpDF7TEHylV5zNhykX6KAgHJmTNw==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "@babel/helper-plugin-utils": "^7.8.0"
      },
      "peerDependencies": {
        "@babel/core": "^7.0.0-0"
      }
    },
    "node_modules/@babel/plugin-syntax-bigint": {
      "version": "7.8.3",
      "resolved": "https://registry.npmjs.org/@babel/plugin-syntax-bigint/-/plugin-syntax-bigint-7.8.3.tgz",
      "integrity": "sha512-wnTnFlG+YxQm3vDxpGE57Pj0srRU4sHE/mDkt1qv2YJJSeUAec2ma4WLUnUPeKjyrfntVwe/N6dCXpU+zL3Npg==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "@babel/helper-plugin-utils": "^7.8.0"
      },
      "peerDependencies": {
        "@babel/core": "^7.0.0-0"
      }
    },
    "node_modules/@babel/plugin-syntax-class-properties": {
      "version": "7.12.13",
      "resolved": "https://registry.npmjs.org/@babel/plugin-syntax-class-properties/-/plugin-syntax-class-properties-7.12.13.tgz",
      "integrity": "sha512-fm4idjKla0YahUNgFNLCB0qySdsoPiZP3iQE3rky0mBUtMZ23yDJ9SJdg6dXTSDnulOVqiF3Hgr9nbXvXTQZYA==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "@babel/helper-plugin-utils": "^7.12.13"
      },
      "peerDependencies": {
        "@babel/core": "^7.0.0-0"
      }
    },
    "node_modules/@babel/plugin-syntax-class-static-block": {
      "version": "7.14.5",
      "resolved": "https://registry.npmjs.org/@babel/plugin-syntax-class-static-block/-/plugin-syntax-class-static-block-7.14.5.tgz",
      "integrity": "sha512-b+YyPmr6ldyNnM6sqYeMWE+bgJcJpO6yS4QD7ymxgH34GBPNDM/THBh8iunyvKIZztiwLH4CJZ0RxTk9emgpjw==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "@babel/helper-plugin-utils": "^7.14.5"
      },
      "engines": {
        "node": ">=6.9.0"
      },
      "peerDependencies": {
        "@babel/core": "^7.0.0-0"
      }
    },
    "node_modules/@babel/plugin-syntax-import-attributes": {
      "version": "7.27.1",
      "resolved": "https://registry.npmjs.org/@babel/plugin-syntax-import-attributes/-/plugin-syntax-import-attributes-7.27.1.tgz",
      "integrity": "sha512-oFT0FrKHgF53f4vOsZGi2Hh3I35PfSmVs4IBFLFj4dnafP+hIWDLg3VyKmUHfLoLHlyxY4C7DGtmHuJgn+IGww==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "@babel/helper-plugin-utils": "^7.27.1"
      },
      "engines": {
        "node": ">=6.9.0"
      },
      "peerDependencies": {
        "@babel/core": "^7.0.0-0"
      }
    },
    "node_modules/@babel/plugin-syntax-import-meta": {
      "version": "7.10.4",
      "resolved": "https://registry.npmjs.org/@babel/plugin-syntax-import-meta/-/plugin-syntax-import-meta-7.10.4.tgz",
      "integrity": "sha512-Yqfm+XDx0+Prh3VSeEQCPU81yC+JWZ2pDPFSS4ZdpfZhp4MkFMaDC1UqseovEKwSUpnIL7+vK+Clp7bfh0iD7g==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "@babel/helper-plugin-utils": "^7.10.4"
      },
      "peerDependencies": {
        "@babel/core": "^7.0.0-0"
      }
    },
    "node_modules/@babel/plugin-syntax-json-strings": {
      "version": "7.8.3",
      "resolved": "https://registry.npmjs.org/@babel/plugin-syntax-json-strings/-/plugin-syntax-json-strings-7.8.3.tgz",
      "integrity": "sha512-lY6kdGpWHvjoe2vk4WrAapEuBR69EMxZl+RoGRhrFGNYVK8mOPAW8VfbT/ZgrFbXlDNiiaxQnAtgVCZ6jv30EA==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "@babel/helper-plugin-utils": "^7.8.0"
      },
      "peerDependencies": {
        "@babel/core": "^7.0.0-0"
      }
    },
    "node_modules/@babel/plugin-syntax-jsx": {
      "version": "7.27.1",
      "resolved": "https://registry.npmjs.org/@babel/plugin-syntax-jsx/-/plugin-syntax-jsx-7.27.1.tgz",
      "integrity": "sha512-y8YTNIeKoyhGd9O0Jiyzyyqk8gdjnumGTQPsz0xOZOQ2RmkVJeZ1vmmfIvFEKqucBG6axJGBZDE/7iI5suUI/w==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "@babel/helper-plugin-utils": "^7.27.1"
      },
      "engines": {
        "node": ">=6.9.0"
      },
      "peerDependencies": {
        "@babel/core": "^7.0.0-0"
      }
    },
    "node_modules/@babel/plugin-syntax-logical-assignment-operators": {
      "version": "7.10.4",
      "resolved": "https://registry.npmjs.org/@babel/plugin-syntax-logical-assignment-operators/-/plugin-syntax-logical-assignment-operators-7.10.4.tgz",
      "integrity": "sha512-d8waShlpFDinQ5MtvGU9xDAOzKH47+FFoney2baFIoMr952hKOLp1HR7VszoZvOsV/4+RRszNY7D17ba0te0ig==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "@babel/helper-plugin-utils": "^7.10.4"
      },
      "peerDependencies": {
        "@babel/core": "^7.0.0-0"
      }
    },
    "node_modules/@babel/plugin-syntax-nullish-coalescing-operator": {
      "version": "7.8.3",
      "resolved": "https://registry.npmjs.org/@babel/plugin-syntax-nullish-coalescing-operator/-/plugin-syntax-nullish-coalescing-operator-7.8.3.tgz",
      "integrity": "sha512-aSff4zPII1u2QD7y+F8oDsz19ew4IGEJg9SVW+bqwpwtfFleiQDMdzA/R+UlWDzfnHFCxxleFT0PMIrR36XLNQ==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "@babel/helper-plugin-utils": "^7.8.0"
      },
      "peerDependencies": {
        "@babel/core": "^7.0.0-0"
      }
    },
    "node_modules/@babel/plugin-syntax-numeric-separator": {
      "version": "7.10.4",
      "resolved": "https://registry.npmjs.org/@babel/plugin-syntax-numeric-separator/-/plugin-syntax-numeric-separator-7.10.4.tgz",
      "integrity": "sha512-9H6YdfkcK/uOnY/K7/aA2xpzaAgkQn37yzWUMRK7OaPOqOpGS1+n0H5hxT9AUw9EsSjPW8SVyMJwYRtWs3X3ug==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "@babel/helper-plugin-utils": "^7.10.4"
      },
      "peerDependencies": {
        "@babel/core": "^7.0.0-0"
      }
    },
    "node_modules/@babel/plugin-syntax-object-rest-spread": {
      "version": "7.8.3",
      "resolved": "https://registry.npmjs.org/@babel/plugin-syntax-object-rest-spread/-/plugin-syntax-object-rest-spread-7.8.3.tgz",
      "integrity": "sha512-XoqMijGZb9y3y2XskN+P1wUGiVwWZ5JmoDRwx5+3GmEplNyVM2s2Dg8ILFQm8rWM48orGy5YpI5Bl8U1y7ydlA==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "@babel/helper-plugin-utils": "^7.8.0"
      },
      "peerDependencies": {
        "@babel/core": "^7.0.0-0"
      }
    },
    "node_modules/@babel/plugin-syntax-optional-catch-binding": {
      "version": "7.8.3",
      "resolved": "https://registry.npmjs.org/@babel/plugin-syntax-optional-catch-binding/-/plugin-syntax-optional-catch-binding-7.8.3.tgz",
      "integrity": "sha512-6VPD0Pc1lpTqw0aKoeRTMiB+kWhAoT24PA+ksWSBrFtl5SIRVpZlwN3NNPQjehA2E/91FV3RjLWoVTglWcSV3Q==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "@babel/helper-plugin-utils": "^7.8.0"
      },
      "peerDependencies": {
        "@babel/core": "^7.0.0-0"
      }
    },
    "node_modules/@babel/plugin-syntax-optional-chaining": {
      "version": "7.8.3",
      "resolved": "https://registry.npmjs.org/@babel/plugin-syntax-optional-chaining/-/plugin-syntax-optional-chaining-7.8.3.tgz",
      "integrity": "sha512-KoK9ErH1MBlCPxV0VANkXW2/dw4vlbGDrFgz8bmUsBGYkFRcbRwMh6cIJubdPrkxRwuGdtCk0v/wPTKbQgBjkg==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "@babel/helper-plugin-utils": "^7.8.0"
      },
      "peerDependencies": {
        "@babel/core": "^7.0.0-0"
      }
    },
    "node_modules/@babel/plugin-syntax-private-property-in-object": {
      "version": "7.14.5",
      "resolved": "https://registry.npmjs.org/@babel/plugin-syntax-private-property-in-object/-/plugin-syntax-private-property-in-object-7.14.5.tgz",
      "integrity": "sha512-0wVnp9dxJ72ZUJDV27ZfbSj6iHLoytYZmh3rFcxNnvsJF3ktkzLDZPy/mA17HGsaQT3/DQsWYX1f1QGWkCoVUg==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "@babel/helper-plugin-utils": "^7.14.5"
      },
      "engines": {
        "node": ">=6.9.0"
      },
      "peerDependencies": {
        "@babel/core": "^7.0.0-0"
      }
    },
    "node_modules/@babel/plugin-syntax-top-level-await": {
      "version": "7.14.5",
      "resolved": "https://registry.npmjs.org/@babel/plugin-syntax-top-level-await/-/plugin-syntax-top-level-await-7.14.5.tgz",
      "integrity": "sha512-hx++upLv5U1rgYfwe1xBQUhRmU41NEvpUvrp8jkrSCdvGSnM5/qdRMtylJ6PG5OFkBaHkbTAKTnd3/YyESRHFw==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "@babel/helper-plugin-utils": "^7.14.5"
      },
      "engines": {
        "node": ">=6.9.0"
      },
      "peerDependencies": {
        "@babel/core": "^7.0.0-0"
      }
    },
    "node_modules/@babel/plugin-syntax-typescript": {
      "version": "7.27.1",
      "resolved": "https://registry.npmjs.org/@babel/plugin-syntax-typescript/-/plugin-syntax-typescript-7.27.1.tgz",
      "integrity": "sha512-xfYCBMxveHrRMnAWl1ZlPXOZjzkN82THFvLhQhFXFt81Z5HnN+EtUkZhv/zcKpmT3fzmWZB0ywiBrbC3vogbwQ==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "@babel/helper-plugin-utils": "^7.27.1"
      },
      "engines": {
        "node": ">=6.9.0"
      },
      "peerDependencies": {
        "@babel/core": "^7.0.0-0"
      }
    },
    "node_modules/@babel/template": {
      "version": "7.27.2",
      "resolved": "https://registry.npmjs.org/@babel/template/-/template-7.27.2.tgz",
      "integrity": "sha512-LPDZ85aEJyYSd18/DkjNh4/y1ntkE5KwUHWTiqgRxruuZL2F1yuHligVHLvcHY2vMHXttKFpJn6LwfI7cw7ODw==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "@babel/code-frame": "^7.27.1",
        "@babel/parser": "^7.27.2",
        "@babel/types": "^7.27.1"
      },
      "engines": {
        "node": ">=6.9.0"
      }
    },
    "node_modules/@babel/traverse": {
      "version": "7.28.4",
      "resolved": "https://registry.npmjs.org/@babel/traverse/-/traverse-7.28.4.tgz",
      "integrity": "sha512-YEzuboP2qvQavAcjgQNVgsvHIDv6ZpwXvcvjmyySP2DIMuByS/6ioU5G9pYrWHM6T2YDfc7xga9iNzYOs12CFQ==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "@babel/code-frame": "^7.27.1",
        "@babel/generator": "^7.28.3",
        "@babel/helper-globals": "^7.28.0",
        "@babel/parser": "^7.28.4",
        "@babel/template": "^7.27.2",
        "@babel/types": "^7.28.4",
        "debug": "^4.3.1"
      },
      "engines": {
        "node": ">=6.9.0"
      }
    },
    "node_modules/@babel/types": {
      "version": "7.28.4",
      "resolved": "https://registry.npmjs.org/@babel/types/-/types-7.28.4.tgz",
      "integrity": "sha512-bkFqkLhh3pMBUQQkpVgWDWq/lqzc2678eUyDlTBhRqhCHFguYYGM0Efga7tYk4TogG/3x0EEl66/OQ+WGbWB/Q==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "@babel/helper-string-parser": "^7.27.1",
        "@babel/helper-validator-identifier": "^7.27.1"
      },
      "engines": {
        "node": ">=6.9.0"
      }
    },
    "node_modules/@bcoe/v8-coverage": {
      "version": "0.2.3",
      "resolved": "https://registry.npmjs.org/@bcoe/v8-coverage/-/v8-coverage-0.2.3.tgz",
      "integrity": "sha512-0hYQ8SB4Db5zvZB4axdMHGwEaQjkZzFjQiN9LVYvIFB2nSUHW9tYpxWriPrWDASIxiaXax83REcLxuSdnGPZtw==",
      "dev": true,
      "license": "MIT"
    },
    "node_modules/@discordjs/builders": {
      "version": "1.11.3",
      "resolved": "https://registry.npmjs.org/@discordjs/builders/-/builders-1.11.3.tgz",
      "integrity": "sha512-p3kf5eV49CJiRTfhtutUCeivSyQ/l2JlKodW1ZquRwwvlOWmG9+6jFShX6x8rUiYhnP6wKI96rgN/SXMy5e5aw==",
      "license": "Apache-2.0",
      "dependencies": {
        "@discordjs/formatters": "^0.6.1",
        "@discordjs/util": "^1.1.1",
        "@sapphire/shapeshift": "^4.0.0",
        "discord-api-types": "^0.38.16",
        "fast-deep-equal": "^3.1.3",
        "ts-mixer": "^6.0.4",
        "tslib": "^2.6.3"
      },
      "engines": {
        "node": ">=16.11.0"
      },
      "funding": {
        "url": "https://github.com/discordjs/discord.js?sponsor"
      }
    },
    "node_modules/@discordjs/collection": {
      "version": "1.5.3",
      "resolved": "https://registry.npmjs.org/@discordjs/collection/-/collection-1.5.3.tgz",
      "integrity": "sha512-SVb428OMd3WO1paV3rm6tSjM4wC+Kecaa1EUGX7vc6/fddvw/6lg90z4QtCqm21zvVe92vMMDt9+DkIvjXImQQ==",
      "license": "Apache-2.0",
      "engines": {
        "node": ">=16.11.0"
      }
    },
    "node_modules/@discordjs/formatters": {
      "version": "0.6.1",
      "resolved": "https://registry.npmjs.org/@discordjs/formatters/-/formatters-0.6.1.tgz",
      "integrity": "sha512-5cnX+tASiPCqCWtFcFslxBVUaCetB0thvM/JyavhbXInP1HJIEU+Qv/zMrnuwSsX3yWH2lVXNJZeDK3EiP4HHg==",
      "license": "Apache-2.0",
      "dependencies": {
        "discord-api-types": "^0.38.1"
      },
      "engines": {
        "node": ">=16.11.0"
      },
      "funding": {
        "url": "https://github.com/discordjs/discord.js?sponsor"
      }
    },
    "node_modules/@discordjs/rest": {
      "version": "2.6.0",
      "resolved": "https://registry.npmjs.org/@discordjs/rest/-/rest-2.6.0.tgz",
      "integrity": "sha512-RDYrhmpB7mTvmCKcpj+pc5k7POKszS4E2O9TYc+U+Y4iaCP+r910QdO43qmpOja8LRr1RJ0b3U+CqVsnPqzf4w==",
      "license": "Apache-2.0",
      "dependencies": {
        "@discordjs/collection": "^2.1.1",
        "@discordjs/util": "^1.1.1",
        "@sapphire/async-queue": "^1.5.3",
        "@sapphire/snowflake": "^3.5.3",
        "@vladfrangu/async_event_emitter": "^2.4.6",
        "discord-api-types": "^0.38.16",
        "magic-bytes.js": "^1.10.0",
        "tslib": "^2.6.3",
        "undici": "6.21.3"
      },
      "engines": {
        "node": ">=18"
      },
      "funding": {
        "url": "https://github.com/discordjs/discord.js?sponsor"
      }
    },
    "node_modules/@discordjs/rest/node_modules/@discordjs/collection": {
      "version": "2.1.1",
      "resolved": "https://registry.npmjs.org/@discordjs/collection/-/collection-2.1.1.tgz",
      "integrity": "sha512-LiSusze9Tc7qF03sLCujF5iZp7K+vRNEDBZ86FT9aQAv3vxMLihUvKvpsCWiQ2DJq1tVckopKm1rxomgNUc9hg==",
      "license": "Apache-2.0",
      "engines": {
        "node": ">=18"
      },
      "funding": {
        "url": "https://github.com/discordjs/discord.js?sponsor"
      }
    },
    "node_modules/@discordjs/util": {
      "version": "1.1.1",
      "resolved": "https://registry.npmjs.org/@discordjs/util/-/util-1.1.1.tgz",
      "integrity": "sha512-eddz6UnOBEB1oITPinyrB2Pttej49M9FZQY8NxgEvc3tq6ZICZ19m70RsmzRdDHk80O9NoYN/25AqJl8vPVf/g==",
      "license": "Apache-2.0",
      "engines": {
        "node": ">=18"
      },
      "funding": {
        "url": "https://github.com/discordjs/discord.js?sponsor"
      }
    },
    "node_modules/@discordjs/ws": {
      "version": "1.2.3",
      "resolved": "https://registry.npmjs.org/@discordjs/ws/-/ws-1.2.3.tgz",
      "integrity": "sha512-wPlQDxEmlDg5IxhJPuxXr3Vy9AjYq5xCvFWGJyD7w7Np8ZGu+Mc+97LCoEc/+AYCo2IDpKioiH0/c/mj5ZR9Uw==",
      "license": "Apache-2.0",
      "dependencies": {
        "@discordjs/collection": "^2.1.0",
        "@discordjs/rest": "^2.5.1",
        "@discordjs/util": "^1.1.0",
        "@sapphire/async-queue": "^1.5.2",
        "@types/ws": "^8.5.10",
        "@vladfrangu/async_event_emitter": "^2.2.4",
        "discord-api-types": "^0.38.1",
        "tslib": "^2.6.2",
        "ws": "^8.17.0"
      },
      "engines": {
        "node": ">=16.11.0"
      },
      "funding": {
        "url": "https://github.com/discordjs/discord.js?sponsor"
      }
    },
    "node_modules/@discordjs/ws/node_modules/@discordjs/collection": {
      "version": "2.1.1",
      "resolved": "https://registry.npmjs.org/@discordjs/collection/-/collection-2.1.1.tgz",
      "integrity": "sha512-LiSusze9Tc7qF03sLCujF5iZp7K+vRNEDBZ86FT9aQAv3vxMLihUvKvpsCWiQ2DJq1tVckopKm1rxomgNUc9hg==",
      "license": "Apache-2.0",
      "engines": {
        "node": ">=18"
      },
      "funding": {
        "url": "https://github.com/discordjs/discord.js?sponsor"
      }
    },
    "node_modules/@istanbuljs/load-nyc-config": {
      "version": "1.1.0",
      "resolved": "https://registry.npmjs.org/@istanbuljs/load-nyc-config/-/load-nyc-config-1.1.0.tgz",
      "integrity": "sha512-VjeHSlIzpv/NyD3N0YuHfXOPDIixcA1q2ZV98wsMqcYlPmv2n3Yb2lYP9XMElnaFVXg5A7YLTeLu6V84uQDjmQ==",
      "dev": true,
      "license": "ISC",
      "dependencies": {
        "camelcase": "^5.3.1",
        "find-up": "^4.1.0",
        "get-package-type": "^0.1.0",
        "js-yaml": "^3.13.1",
        "resolve-from": "^5.0.0"
      },
      "engines": {
        "node": ">=8"
      }
    },
    "node_modules/@istanbuljs/schema": {
      "version": "0.1.3",
      "resolved": "https://registry.npmjs.org/@istanbuljs/schema/-/schema-0.1.3.tgz",
      "integrity": "sha512-ZXRY4jNvVgSVQ8DL3LTcakaAtXwTVUxE81hslsyD2AtoXW/wVob10HkOJ1X/pAlcI7D+2YoZKg5do8G/w6RYgA==",
      "dev": true,
      "license": "MIT",
      "engines": {
        "node": ">=8"
      }
    },
    "node_modules/@jest/console": {
      "version": "29.7.0",
      "resolved": "https://registry.npmjs.org/@jest/console/-/console-29.7.0.tgz",
      "integrity": "sha512-5Ni4CU7XHQi32IJ398EEP4RrB8eV09sXP2ROqD4bksHrnTree52PsxvX8tpL8LvTZ3pFzXyPbNQReSN41CAhOg==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "@jest/types": "^29.6.3",
        "@types/node": "*",
        "chalk": "^4.0.0",
        "jest-message-util": "^29.7.0",
        "jest-util": "^29.7.0",
        "slash": "^3.0.0"
      },
      "engines": {
        "node": "^14.15.0 || ^16.10.0 || >=18.0.0"
      }
    },
    "node_modules/@jest/core": {
      "version": "29.7.0",
      "resolved": "https://registry.npmjs.org/@jest/core/-/core-29.7.0.tgz",
      "integrity": "sha512-n7aeXWKMnGtDA48y8TLWJPJmLmmZ642Ceo78cYWEpiD7FzDgmNDV/GCVRorPABdXLJZ/9wzzgZAlHjXjxDHGsg==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "@jest/console": "^29.7.0",
        "@jest/reporters": "^29.7.0",
        "@jest/test-result": "^29.7.0",
        "@jest/transform": "^29.7.0",
        "@jest/types": "^29.6.3",
        "@types/node": "*",
        "ansi-escapes": "^4.2.1",
        "chalk": "^4.0.0",
        "ci-info": "^3.2.0",
        "exit": "^0.1.2",
        "graceful-fs": "^4.2.9",
        "jest-changed-files": "^29.7.0",
        "jest-config": "^29.7.0",
        "jest-haste-map": "^29.7.0",
        "jest-message-util": "^29.7.0",
        "jest-regex-util": "^29.6.3",
        "jest-resolve": "^29.7.0",
        "jest-resolve-dependencies": "^29.7.0",
        "jest-runner": "^29.7.0",
        "jest-runtime": "^29.7.0",
        "jest-snapshot": "^29.7.0",
        "jest-util": "^29.7.0",
        "jest-validate": "^29.7.0",
        "jest-watcher": "^29.7.0",
        "micromatch": "^4.0.4",
        "pretty-format": "^29.7.0",
        "slash": "^3.0.0",
        "strip-ansi": "^6.0.0"
      },
      "engines": {
        "node": "^14.15.0 || ^16.10.0 || >=18.0.0"
      },
      "peerDependencies": {
        "node-notifier": "^8.0.1 || ^9.0.0 || ^10.0.0"
      },
      "peerDependenciesMeta": {
        "node-notifier": {
          "optional": true
        }
      }
    },
    "node_modules/@jest/environment": {
      "version": "29.7.0",
      "resolved": "https://registry.npmjs.org/@jest/environment/-/environment-29.7.0.tgz",
      "integrity": "sha512-aQIfHDq33ExsN4jP1NWGXhxgQ/wixs60gDiKO+XVMd8Mn0NWPWgc34ZQDTb2jKaUWQ7MuwoitXAsN2XVXNMpAw==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "@jest/fake-timers": "^29.7.0",
        "@jest/types": "^29.6.3",
        "@types/node": "*",
        "jest-mock": "^29.7.0"
      },
      "engines": {
        "node": "^14.15.0 || ^16.10.0 || >=18.0.0"
      }
    },
    "node_modules/@jest/expect": {
      "version": "29.7.0",
      "resolved": "https://registry.npmjs.org/@jest/expect/-/expect-29.7.0.tgz",
      "integrity": "sha512-8uMeAMycttpva3P1lBHB8VciS9V0XAr3GymPpipdyQXbBcuhkLQOSe8E/p92RyAdToS6ZD1tFkX+CkhoECE0dQ==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "expect": "^29.7.0",
        "jest-snapshot": "^29.7.0"
      },
      "engines": {
        "node": "^14.15.0 || ^16.10.0 || >=18.0.0"
      }
    },
    "node_modules/@jest/expect-utils": {
      "version": "29.7.0",
      "resolved": "https://registry.npmjs.org/@jest/expect-utils/-/expect-utils-29.7.0.tgz",
      "integrity": "sha512-GlsNBWiFQFCVi9QVSx7f5AgMeLxe9YCCs5PuP2O2LdjDAA8Jh9eX7lA1Jq/xdXw3Wb3hyvlFNfZIfcRetSzYcA==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "jest-get-type": "^29.6.3"
      },
      "engines": {
        "node": "^14.15.0 || ^16.10.0 || >=18.0.0"
      }
    },
    "node_modules/@jest/fake-timers": {
      "version": "29.7.0",
      "resolved": "https://registry.npmjs.org/@jest/fake-timers/-/fake-timers-29.7.0.tgz",
      "integrity": "sha512-q4DH1Ha4TTFPdxLsqDXK1d3+ioSL7yL5oCMJZgDYm6i+6CygW5E5xVr/D1HdsGxjt1ZWSfUAs9OxSB/BNelWrQ==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "@jest/types": "^29.6.3",
        "@sinonjs/fake-timers": "^10.0.2",
        "@types/node": "*",
        "jest-message-util": "^29.7.0",
        "jest-mock": "^29.7.0",
        "jest-util": "^29.7.0"
      },
      "engines": {
        "node": "^14.15.0 || ^16.10.0 || >=18.0.0"
      }
    },
    "node_modules/@jest/globals": {
      "version": "29.7.0",
      "resolved": "https://registry.npmjs.org/@jest/globals/-/globals-29.7.0.tgz",
      "integrity": "sha512-mpiz3dutLbkW2MNFubUGUEVLkTGiqW6yLVTA+JbP6fI6J5iL9Y0Nlg8k95pcF8ctKwCS7WVxteBs29hhfAotzQ==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "@jest/environment": "^29.7.0",
        "@jest/expect": "^29.7.0",
        "@jest/types": "^29.6.3",
        "jest-mock": "^29.7.0"
      },
      "engines": {
        "node": "^14.15.0 || ^16.10.0 || >=18.0.0"
      }
    },
    "node_modules/@jest/reporters": {
      "version": "29.7.0",
      "resolved": "https://registry.npmjs.org/@jest/reporters/-/reporters-29.7.0.tgz",
      "integrity": "sha512-DApq0KJbJOEzAFYjHADNNxAE3KbhxQB1y5Kplb5Waqw6zVbuWatSnMjE5gs8FUgEPmNsnZA3NCWl9NG0ia04Pg==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "@bcoe/v8-coverage": "^0.2.3",
        "@jest/console": "^29.7.0",
        "@jest/test-result": "^29.7.0",
        "@jest/transform": "^29.7.0",
        "@jest/types": "^29.6.3",
        "@jridgewell/trace-mapping": "^0.3.18",
        "@types/node": "*",
        "chalk": "^4.0.0",
        "collect-v8-coverage": "^1.0.0",
        "exit": "^0.1.2",
        "glob": "^7.1.3",
        "graceful-fs": "^4.2.9",
        "istanbul-lib-coverage": "^3.0.0",
        "istanbul-lib-instrument": "^6.0.0",
        "istanbul-lib-report": "^3.0.0",
        "istanbul-lib-source-maps": "^4.0.0",
        "istanbul-reports": "^3.1.3",
        "jest-message-util": "^29.7.0",
        "jest-util": "^29.7.0",
        "jest-worker": "^29.7.0",
        "slash": "^3.0.0",
        "string-length": "^4.0.1",
        "strip-ansi": "^6.0.0",
        "v8-to-istanbul": "^9.0.1"
      },
      "engines": {
        "node": "^14.15.0 || ^16.10.0 || >=18.0.0"
      },
      "peerDependencies": {
        "node-notifier": "^8.0.1 || ^9.0.0 || ^10.0.0"
      },
      "peerDependenciesMeta": {
        "node-notifier": {
          "optional": true
        }
      }
    },
    "node_modules/@jest/schemas": {
      "version": "29.6.3",
      "resolved": "https://registry.npmjs.org/@jest/schemas/-/schemas-29.6.3.tgz",
      "integrity": "sha512-mo5j5X+jIZmJQveBKeS/clAueipV7KgiX1vMgCxam1RNYiqE1w62n0/tJJnHtjW8ZHcQco5gY85jA3mi0L+nSA==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "@sinclair/typebox": "^0.27.8"
      },
      "engines": {
        "node": "^14.15.0 || ^16.10.0 || >=18.0.0"
      }
    },
    "node_modules/@jest/source-map": {
      "version": "29.6.3",
      "resolved": "https://registry.npmjs.org/@jest/source-map/-/source-map-29.6.3.tgz",
      "integrity": "sha512-MHjT95QuipcPrpLM+8JMSzFx6eHp5Bm+4XeFDJlwsvVBjmKNiIAvasGK2fxz2WbGRlnvqehFbh07MMa7n3YJnw==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "@jridgewell/trace-mapping": "^0.3.18",
        "callsites": "^3.0.0",
        "graceful-fs": "^4.2.9"
      },
      "engines": {
        "node": "^14.15.0 || ^16.10.0 || >=18.0.0"
      }
    },
    "node_modules/@jest/test-result": {
      "version": "29.7.0",
      "resolved": "https://registry.npmjs.org/@jest/test-result/-/test-result-29.7.0.tgz",
      "integrity": "sha512-Fdx+tv6x1zlkJPcWXmMDAG2HBnaR9XPSd5aDWQVsfrZmLVT3lU1cwyxLgRmXR9yrq4NBoEm9BMsfgFzTQAbJYA==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "@jest/console": "^29.7.0",
        "@jest/types": "^29.6.3",
        "@types/istanbul-lib-coverage": "^2.0.0",
        "collect-v8-coverage": "^1.0.0"
      },
      "engines": {
        "node": "^14.15.0 || ^16.10.0 || >=18.0.0"
      }
    },
    "node_modules/@jest/test-sequencer": {
      "version": "29.7.0",
      "resolved": "https://registry.npmjs.org/@jest/test-sequencer/-/test-sequencer-29.7.0.tgz",
      "integrity": "sha512-GQwJ5WZVrKnOJuiYiAF52UNUJXgTZx1NHjFSEB0qEMmSZKAkdMoIzw/Cj6x6NF4AvV23AUqDpFzQkN/eYCYTxw==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "@jest/test-result": "^29.7.0",
        "graceful-fs": "^4.2.9",
        "jest-haste-map": "^29.7.0",
        "slash": "^3.0.0"
      },
      "engines": {
        "node": "^14.15.0 || ^16.10.0 || >=18.0.0"
      }
    },
    "node_modules/@jest/transform": {
      "version": "29.7.0",
      "resolved": "https://registry.npmjs.org/@jest/transform/-/transform-29.7.0.tgz",
      "integrity": "sha512-ok/BTPFzFKVMwO5eOHRrvnBVHdRy9IrsrW1GpMaQ9MCnilNLXQKmAX8s1YXDFaai9xJpac2ySzV0YeRRECr2Vw==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "@babel/core": "^7.11.6",
        "@jest/types": "^29.6.3",
        "@jridgewell/trace-mapping": "^0.3.18",
        "babel-plugin-istanbul": "^6.1.1",
        "chalk": "^4.0.0",
        "convert-source-map": "^2.0.0",
        "fast-json-stable-stringify": "^2.1.0",
        "graceful-fs": "^4.2.9",
        "jest-haste-map": "^29.7.0",
        "jest-regex-util": "^29.6.3",
        "jest-util": "^29.7.0",
        "micromatch": "^4.0.4",
        "pirates": "^4.0.4",
        "slash": "^3.0.0",
        "write-file-atomic": "^4.0.2"
      },
      "engines": {
        "node": "^14.15.0 || ^16.10.0 || >=18.0.0"
      }
    },
    "node_modules/@jest/types": {
      "version": "29.6.3",
      "resolved": "https://registry.npmjs.org/@jest/types/-/types-29.6.3.tgz",
      "integrity": "sha512-u3UPsIilWKOM3F9CXtrG8LEJmNxwoCQC/XVj4IKYXvvpx7QIi/Kg1LI5uDmDpKlac62NUtX7eLjRh+jVZcLOzw==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "@jest/schemas": "^29.6.3",
        "@types/istanbul-lib-coverage": "^2.0.0",
        "@types/istanbul-reports": "^3.0.0",
        "@types/node": "*",
        "@types/yargs": "^17.0.8",
        "chalk": "^4.0.0"
      },
      "engines": {
        "node": "^14.15.0 || ^16.10.0 || >=18.0.0"
      }
    },
    "node_modules/@jridgewell/gen-mapping": {
      "version": "0.3.13",
      "resolved": "https://registry.npmjs.org/@jridgewell/gen-mapping/-/gen-mapping-0.3.13.tgz",
      "integrity": "sha512-2kkt/7niJ6MgEPxF0bYdQ6etZaA+fQvDcLKckhy1yIQOzaoKjBBjSj63/aLVjYE3qhRt5dvM+uUyfCg6UKCBbA==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "@jridgewell/sourcemap-codec": "^1.5.0",
        "@jridgewell/trace-mapping": "^0.3.24"
      }
    },
    "node_modules/@jridgewell/remapping": {
      "version": "2.3.5",
      "resolved": "https://registry.npmjs.org/@jridgewell/remapping/-/remapping-2.3.5.tgz",
      "integrity": "sha512-LI9u/+laYG4Ds1TDKSJW2YPrIlcVYOwi2fUC6xB43lueCjgxV4lffOCZCtYFiH6TNOX+tQKXx97T4IKHbhyHEQ==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "@jridgewell/gen-mapping": "^0.3.5",
        "@jridgewell/trace-mapping": "^0.3.24"
      }
    },
    "node_modules/@jridgewell/resolve-uri": {
      "version": "3.1.2",
      "resolved": "https://registry.npmjs.org/@jridgewell/resolve-uri/-/resolve-uri-3.1.2.tgz",
      "integrity": "sha512-bRISgCIjP20/tbWSPWMEi54QVPRZExkuD9lJL+UIxUKtwVJA8wW1Trb1jMs1RFXo1CBTNZ/5hpC9QvmKWdopKw==",
      "dev": true,
      "license": "MIT",
      "engines": {
        "node": ">=6.0.0"
      }
    },
    "node_modules/@jridgewell/sourcemap-codec": {
      "version": "1.5.5",
      "resolved": "https://registry.npmjs.org/@jridgewell/sourcemap-codec/-/sourcemap-codec-1.5.5.tgz",
      "integrity": "sha512-cYQ9310grqxueWbl+WuIUIaiUaDcj7WOq5fVhEljNVgRfOUhY9fy2zTvfoqWsnebh8Sl70VScFbICvJnLKB0Og==",
      "dev": true,
      "license": "MIT"
    },
    "node_modules/@jridgewell/trace-mapping": {
      "version": "0.3.30",
      "resolved": "https://registry.npmjs.org/@jridgewell/trace-mapping/-/trace-mapping-0.3.30.tgz",
      "integrity": "sha512-GQ7Nw5G2lTu/BtHTKfXhKHok2WGetd4XYcVKGx00SjAk8GMwgJM3zr6zORiPGuOE+/vkc90KtTosSSvaCjKb2Q==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "@jridgewell/resolve-uri": "^3.1.0",
        "@jridgewell/sourcemap-codec": "^1.4.14"
      }
    },
    "node_modules/@sapphire/async-queue": {
      "version": "1.5.5",
      "resolved": "https://registry.npmjs.org/@sapphire/async-queue/-/async-queue-1.5.5.tgz",
      "integrity": "sha512-cvGzxbba6sav2zZkH8GPf2oGk9yYoD5qrNWdu9fRehifgnFZJMV+nuy2nON2roRO4yQQ+v7MK/Pktl/HgfsUXg==",
      "license": "MIT",
      "engines": {
        "node": ">=v14.0.0",
        "npm": ">=7.0.0"
      }
    },
    "node_modules/@sapphire/shapeshift": {
      "version": "4.0.0",
      "resolved": "https://registry.npmjs.org/@sapphire/shapeshift/-/shapeshift-4.0.0.tgz",
      "integrity": "sha512-d9dUmWVA7MMiKobL3VpLF8P2aeanRTu6ypG2OIaEv/ZHH/SUQ2iHOVyi5wAPjQ+HmnMuL0whK9ez8I/raWbtIg==",
      "license": "MIT",
      "dependencies": {
        "fast-deep-equal": "^3.1.3",
        "lodash": "^4.17.21"
      },
      "engines": {
        "node": ">=v16"
      }
    },
    "node_modules/@sapphire/snowflake": {
      "version": "3.5.3",
      "resolved": "https://registry.npmjs.org/@sapphire/snowflake/-/snowflake-3.5.3.tgz",
      "integrity": "sha512-jjmJywLAFoWeBi1W7994zZyiNWPIiqRRNAmSERxyg93xRGzNYvGjlZ0gR6x0F4gPRi2+0O6S71kOZYyr3cxaIQ==",
      "license": "MIT",
      "engines": {
        "node": ">=v14.0.0",
        "npm": ">=7.0.0"
      }
    },
    "node_modules/@sinclair/typebox": {
      "version": "0.27.8",
      "resolved": "https://registry.npmjs.org/@sinclair/typebox/-/typebox-0.27.8.tgz",
      "integrity": "sha512-+Fj43pSMwJs4KRrH/938Uf+uAELIgVBmQzg/q1YG10djyfA3TnrU8N8XzqCh/okZdszqBQTZf96idMfE5lnwTA==",
      "dev": true,
      "license": "MIT"
    },
    "node_modules/@sinonjs/commons": {
      "version": "3.0.1",
      "resolved": "https://registry.npmjs.org/@sinonjs/commons/-/commons-3.0.1.tgz",
      "integrity": "sha512-K3mCHKQ9sVh8o1C9cxkwxaOmXoAMlDxC1mYyHrjqOWEcBjYr76t96zL2zlj5dUGZ3HSw240X1qgH3Mjf1yJWpQ==",
      "dev": true,
      "license": "BSD-3-Clause",
      "dependencies": {
        "type-detect": "4.0.8"
      }
    },
    "node_modules/@sinonjs/fake-timers": {
      "version": "10.3.0",
      "resolved": "https://registry.npmjs.org/@sinonjs/fake-timers/-/fake-timers-10.3.0.tgz",
      "integrity": "sha512-V4BG07kuYSUkTCSBHG8G8TNhM+F19jXFWnQtzj+we8DrkpSBCee9Z3Ms8yiGer/dlmhe35/Xdgyo3/0rQKg7YA==",
      "dev": true,
      "license": "BSD-3-Clause",
      "dependencies": {
        "@sinonjs/commons": "^3.0.0"
      }
    },
    "node_modules/@types/babel__core": {
      "version": "7.20.5",
      "resolved": "https://registry.npmjs.org/@types/babel__core/-/babel__core-7.20.5.tgz",
      "integrity": "sha512-qoQprZvz5wQFJwMDqeseRXWv3rqMvhgpbXFfVyWhbx9X47POIA6i/+dXefEmZKoAgOaTdaIgNSMqMIU61yRyzA==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "@babel/parser": "^7.20.7",
        "@babel/types": "^7.20.7",
        "@types/babel__generator": "*",
        "@types/babel__template": "*",
        "@types/babel__traverse": "*"
      }
    },
    "node_modules/@types/babel__generator": {
      "version": "7.27.0",
      "resolved": "https://registry.npmjs.org/@types/babel__generator/-/babel__generator-7.27.0.tgz",
      "integrity": "sha512-ufFd2Xi92OAVPYsy+P4n7/U7e68fex0+Ee8gSG9KX7eo084CWiQ4sdxktvdl0bOPupXtVJPY19zk6EwWqUQ8lg==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "@babel/types": "^7.0.0"
      }
    },
    "node_modules/@types/babel__template": {
      "version": "7.4.4",
      "resolved": "https://registry.npmjs.org/@types/babel__template/-/babel__template-7.4.4.tgz",
      "integrity": "sha512-h/NUaSyG5EyxBIp8YRxo4RMe2/qQgvyowRwVMzhYhBCONbW8PUsg4lkFMrhgZhUe5z3L3MiLDuvyJ/CaPa2A8A==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "@babel/parser": "^7.1.0",
        "@babel/types": "^7.0.0"
      }
    },
    "node_modules/@types/babel__traverse": {
      "version": "7.28.0",
      "resolved": "https://registry.npmjs.org/@types/babel__traverse/-/babel__traverse-7.28.0.tgz",
      "integrity": "sha512-8PvcXf70gTDZBgt9ptxJ8elBeBjcLOAcOtoO/mPJjtji1+CdGbHgm77om1GrsPxsiE+uXIpNSK64UYaIwQXd4Q==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "@babel/types": "^7.28.2"
      }
    },
    "node_modules/@types/graceful-fs": {
      "version": "4.1.9",
      "resolved": "https://registry.npmjs.org/@types/graceful-fs/-/graceful-fs-4.1.9.tgz",
      "integrity": "sha512-olP3sd1qOEe5dXTSaFvQG+02VdRXcdytWLAZsAq1PecU8uqQAhkrnbli7DagjtXKW/Bl7YJbUsa8MPcuc8LHEQ==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "@types/node": "*"
      }
    },
    "node_modules/@types/istanbul-lib-coverage": {
      "version": "2.0.6",
      "resolved": "https://registry.npmjs.org/@types/istanbul-lib-coverage/-/istanbul-lib-coverage-2.0.6.tgz",
      "integrity": "sha512-2QF/t/auWm0lsy8XtKVPG19v3sSOQlJe/YHZgfjb/KBBHOGSV+J2q/S671rcq9uTBrLAXmZpqJiaQbMT+zNU1w==",
      "dev": true,
      "license": "MIT"
    },
    "node_modules/@types/istanbul-lib-report": {
      "version": "3.0.3",
      "resolved": "https://registry.npmjs.org/@types/istanbul-lib-report/-/istanbul-lib-report-3.0.3.tgz",
      "integrity": "sha512-NQn7AHQnk/RSLOxrBbGyJM/aVQ+pjj5HCgasFxc0K/KhoATfQ/47AyUl15I2yBUpihjmas+a+VJBOqecrFH+uA==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "@types/istanbul-lib-coverage": "*"
      }
    },
    "node_modules/@types/istanbul-reports": {
      "version": "3.0.4",
      "resolved": "https://registry.npmjs.org/@types/istanbul-reports/-/istanbul-reports-3.0.4.tgz",
      "integrity": "sha512-pk2B1NWalF9toCRu6gjBzR69syFjP4Od8WRAX+0mmf9lAjCRicLOWc+ZrxZHx/0XRjotgkF9t6iaMJ+aXcOdZQ==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "@types/istanbul-lib-report": "*"
      }
    },
    "node_modules/@types/node": {
      "version": "24.3.1",
      "resolved": "https://registry.npmjs.org/@types/node/-/node-24.3.1.tgz",
      "integrity": "sha512-3vXmQDXy+woz+gnrTvuvNrPzekOi+Ds0ReMxw0LzBiK3a+1k0kQn9f2NWk+lgD4rJehFUmYy2gMhJ2ZI+7YP9g==",
      "license": "MIT",
      "dependencies": {
        "undici-types": "~7.10.0"
      }
    },
    "node_modules/@types/stack-utils": {
      "version": "2.0.3",
      "resolved": "https://registry.npmjs.org/@types/stack-utils/-/stack-utils-2.0.3.tgz",
      "integrity": "sha512-9aEbYZ3TbYMznPdcdr3SmIrLXwC/AKZXQeCf9Pgao5CKb8CyHuEX5jzWPTkvregvhRJHcpRO6BFoGW9ycaOkYw==",
      "dev": true,
      "license": "MIT"
    },
    "node_modules/@types/ws": {
      "version": "8.18.1",
      "resolved": "https://registry.npmjs.org/@types/ws/-/ws-8.18.1.tgz",
      "integrity": "sha512-ThVF6DCVhA8kUGy+aazFQ4kXQ7E1Ty7A3ypFOe0IcJV8O/M511G99AW24irKrW56Wt44yG9+ij8FaqoBGkuBXg==",
      "license": "MIT",
      "dependencies": {
        "@types/node": "*"
      }
    },
    "node_modules/@types/yargs": {
      "version": "17.0.33",
      "resolved": "https://registry.npmjs.org/@types/yargs/-/yargs-17.0.33.tgz",
      "integrity": "sha512-WpxBCKWPLr4xSsHgz511rFJAM+wS28w2zEO1QDNY5zM/S8ok70NNfztH0xwhqKyaK0OHCbN98LDAZuy1ctxDkA==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "@types/yargs-parser": "*"
      }
    },
    "node_modules/@types/yargs-parser": {
      "version": "21.0.3",
      "resolved": "https://registry.npmjs.org/@types/yargs-parser/-/yargs-parser-21.0.3.tgz",
      "integrity": "sha512-I4q9QU9MQv4oEOz4tAHJtNz1cwuLxn2F3xcc2iV5WdqLPpUnj30aUuxt1mAxYTG+oe8CZMV/+6rU4S4gRDzqtQ==",
      "dev": true,
      "license": "MIT"
    },
    "node_modules/@vladfrangu/async_event_emitter": {
      "version": "2.4.6",
      "resolved": "https://registry.npmjs.org/@vladfrangu/async_event_emitter/-/async_event_emitter-2.4.6.tgz",
      "integrity": "sha512-RaI5qZo6D2CVS6sTHFKg1v5Ohq/+Bo2LZ5gzUEwZ/WkHhwtGTCB/sVLw8ijOkAUxasZ+WshN/Rzj4ywsABJ5ZA==",
      "license": "MIT",
      "engines": {
        "node": ">=v14.0.0",
        "npm": ">=7.0.0"
      }
    },
    "node_modules/ansi-escapes": {
      "version": "4.3.2",
      "resolved": "https://registry.npmjs.org/ansi-escapes/-/ansi-escapes-4.3.2.tgz",
      "integrity": "sha512-gKXj5ALrKWQLsYG9jlTRmR/xKluxHV+Z9QEwNIgCfM1/uwPMCuzVVnh5mwTd+OuBZcwSIMbqssNWRm1lE51QaQ==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "type-fest": "^0.21.3"
      },
      "engines": {
        "node": ">=8"
      },
      "funding": {
        "url": "https://github.com/sponsors/sindresorhus"
      }
    },
    "node_modules/ansi-regex": {
      "version": "5.0.1",
      "resolved": "https://registry.npmjs.org/ansi-regex/-/ansi-regex-5.0.1.tgz",
      "integrity": "sha512-quJQXlTSUGL2LH9SUXo8VwsY4soanhgo6LNSm84E1LBcE8s3O0wpdiRzyR9z/ZZJMlMWv37qOOb9pdJlMUEKFQ==",
      "dev": true,
      "license": "MIT",
      "engines": {
        "node": ">=8"
      }
    },
    "node_modules/ansi-styles": {
      "version": "4.3.0",
      "resolved": "https://registry.npmjs.org/ansi-styles/-/ansi-styles-4.3.0.tgz",
      "integrity": "sha512-zbB9rCJAT1rbjiVDb2hqKFHNYLxgtk8NURxZ3IZwD3F6NtxbXZQCnnSi1Lkx+IDohdPlFp222wVALIheZJQSEg==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "color-convert": "^2.0.1"
      },
      "engines": {
        "node": ">=8"
      },
      "funding": {
        "url": "https://github.com/chalk/ansi-styles?sponsor=1"
      }
    },
    "node_modules/anymatch": {
      "version": "3.1.3",
      "resolved": "https://registry.npmjs.org/anymatch/-/anymatch-3.1.3.tgz",
      "integrity": "sha512-KMReFUr0B4t+D+OBkjR3KYqvocp2XaSzO55UcB6mgQMd3KbcE+mWTyvVV7D/zsdEbNnV6acZUutkiHQXvTr1Rw==",
      "dev": true,
      "license": "ISC",
      "dependencies": {
        "normalize-path": "^3.0.0",
        "picomatch": "^2.0.4"
      },
      "engines": {
        "node": ">= 8"
      }
    },
    "node_modules/argparse": {
      "version": "1.0.10",
      "resolved": "https://registry.npmjs.org/argparse/-/argparse-1.0.10.tgz",
      "integrity": "sha512-o5Roy6tNG4SL/FOkCAN6RzjiakZS25RLYFrcMttJqbdd8BWrnA+fGz57iN5Pb06pvBGvl5gQ0B48dJlslXvoTg==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "sprintf-js": "~1.0.2"
      }
    },
    "node_modules/babel-jest": {
      "version": "29.7.0",
      "resolved": "https://registry.npmjs.org/babel-jest/-/babel-jest-29.7.0.tgz",
      "integrity": "sha512-BrvGY3xZSwEcCzKvKsCi2GgHqDqsYkOP4/by5xCgIwGXQxIEh+8ew3gmrE1y7XRR6LHZIj6yLYnUi/mm2KXKBg==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "@jest/transform": "^29.7.0",
        "@types/babel__core": "^7.1.14",
        "babel-plugin-istanbul": "^6.1.1",
        "babel-preset-jest": "^29.6.3",
        "chalk": "^4.0.0",
        "graceful-fs": "^4.2.9",
        "slash": "^3.0.0"
      },
      "engines": {
        "node": "^14.15.0 || ^16.10.0 || >=18.0.0"
      },
      "peerDependencies": {
        "@babel/core": "^7.8.0"
      }
    },
    "node_modules/babel-plugin-istanbul": {
      "version": "6.1.1",
      "resolved": "https://registry.npmjs.org/babel-plugin-istanbul/-/babel-plugin-istanbul-6.1.1.tgz",
      "integrity": "sha512-Y1IQok9821cC9onCx5otgFfRm7Lm+I+wwxOx738M/WLPZ9Q42m4IG5W0FNX8WLL2gYMZo3JkuXIH2DOpWM+qwA==",
      "dev": true,
      "license": "BSD-3-Clause",
      "dependencies": {
        "@babel/helper-plugin-utils": "^7.0.0",
        "@istanbuljs/load-nyc-config": "^1.0.0",
        "@istanbuljs/schema": "^0.1.2",
        "istanbul-lib-instrument": "^5.0.4",
        "test-exclude": "^6.0.0"
      },
      "engines": {
        "node": ">=8"
      }
    },
    "node_modules/babel-plugin-istanbul/node_modules/istanbul-lib-instrument": {
      "version": "5.2.1",
      "resolved": "https://registry.npmjs.org/istanbul-lib-instrument/-/istanbul-lib-instrument-5.2.1.tgz",
      "integrity": "sha512-pzqtp31nLv/XFOzXGuvhCb8qhjmTVo5vjVk19XE4CRlSWz0KoeJ3bw9XsA7nOp9YBf4qHjwBxkDzKcME/J29Yg==",
      "dev": true,
      "license": "BSD-3-Clause",
      "dependencies": {
        "@babel/core": "^7.12.3",
        "@babel/parser": "^7.14.7",
        "@istanbuljs/schema": "^0.1.2",
        "istanbul-lib-coverage": "^3.2.0",
        "semver": "^6.3.0"
      },
      "engines": {
        "node": ">=8"
      }
    },
    "node_modules/babel-plugin-jest-hoist": {
      "version": "29.6.3",
      "resolved": "https://registry.npmjs.org/babel-plugin-jest-hoist/-/babel-plugin-jest-hoist-29.6.3.tgz",
      "integrity": "sha512-ESAc/RJvGTFEzRwOTT4+lNDk/GNHMkKbNzsvT0qKRfDyyYTskxB5rnU2njIDYVxXCBHHEI1c0YwHob3WaYujOg==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "@babel/template": "^7.3.3",
        "@babel/types": "^7.3.3",
        "@types/babel__core": "^7.1.14",
        "@types/babel__traverse": "^7.0.6"
      },
      "engines": {
        "node": "^14.15.0 || ^16.10.0 || >=18.0.0"
      }
    },
    "node_modules/babel-preset-current-node-syntax": {
      "version": "1.2.0",
      "resolved": "https://registry.npmjs.org/babel-preset-current-node-syntax/-/babel-preset-current-node-syntax-1.2.0.tgz",
      "integrity": "sha512-E/VlAEzRrsLEb2+dv8yp3bo4scof3l9nR4lrld+Iy5NyVqgVYUJnDAmunkhPMisRI32Qc4iRiz425d8vM++2fg==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "@babel/plugin-syntax-async-generators": "^7.8.4",
        "@babel/plugin-syntax-bigint": "^7.8.3",
        "@babel/plugin-syntax-class-properties": "^7.12.13",
        "@babel/plugin-syntax-class-static-block": "^7.14.5",
        "@babel/plugin-syntax-import-attributes": "^7.24.7",
        "@babel/plugin-syntax-import-meta": "^7.10.4",
        "@babel/plugin-syntax-json-strings": "^7.8.3",
        "@babel/plugin-syntax-logical-assignment-operators": "^7.10.4",
        "@babel/plugin-syntax-nullish-coalescing-operator": "^7.8.3",
        "@babel/plugin-syntax-numeric-separator": "^7.10.4",
        "@babel/plugin-syntax-object-rest-spread": "^7.8.3",
        "@babel/plugin-syntax-optional-catch-binding": "^7.8.3",
        "@babel/plugin-syntax-optional-chaining": "^7.8.3",
        "@babel/plugin-syntax-private-property-in-object": "^7.14.5",
        "@babel/plugin-syntax-top-level-await": "^7.14.5"
      },
      "peerDependencies": {
        "@babel/core": "^7.0.0 || ^8.0.0-0"
      }
    },
    "node_modules/babel-preset-jest": {
      "version": "29.6.3",
      "resolved": "https://registry.npmjs.org/babel-preset-jest/-/babel-preset-jest-29.6.3.tgz",
      "integrity": "sha512-0B3bhxR6snWXJZtR/RliHTDPRgn1sNHOR0yVtq/IiQFyuOVjFS+wuio/R4gSNkyYmKmJB4wGZv2NZanmKmTnNA==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "babel-plugin-jest-hoist": "^29.6.3",
        "babel-preset-current-node-syntax": "^1.0.0"
      },
      "engines": {
        "node": "^14.15.0 || ^16.10.0 || >=18.0.0"
      },
      "peerDependencies": {
        "@babel/core": "^7.0.0"
      }
    },
    "node_modules/balanced-match": {
      "version": "1.0.2",
      "resolved": "https://registry.npmjs.org/balanced-match/-/balanced-match-1.0.2.tgz",
      "integrity": "sha512-3oSeUO0TMV67hN1AmbXsK4yaqU7tjiHlbxRDZOpH0KW9+CeX4bRAaX0Anxt0tx2MrpRpWwQaPwIlISEJhYU5Pw==",
      "dev": true,
      "license": "MIT"
    },
    "node_modules/brace-expansion": {
      "version": "1.1.12",
      "resolved": "https://registry.npmjs.org/brace-expansion/-/brace-expansion-1.1.12.tgz",
      "integrity": "sha512-9T9UjW3r0UW5c1Q7GTwllptXwhvYmEzFhzMfZ9H7FQWt+uZePjZPjBP/W1ZEyZ1twGWom5/56TF4lPcqjnDHcg==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "balanced-match": "^1.0.0",
        "concat-map": "0.0.1"
      }
    },
    "node_modules/braces": {
      "version": "3.0.3",
      "resolved": "https://registry.npmjs.org/braces/-/braces-3.0.3.tgz",
      "integrity": "sha512-yQbXgO/OSZVD2IsiLlro+7Hf6Q18EJrKSEsdoMzKePKXct3gvD8oLcOQdIzGupr5Fj+EDe8gO/lxc1BzfMpxvA==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "fill-range": "^7.1.1"
      },
      "engines": {
        "node": ">=8"
      }
    },
    "node_modules/browserslist": {
      "version": "4.25.4",
      "resolved": "https://registry.npmjs.org/browserslist/-/browserslist-4.25.4.tgz",
      "integrity": "sha512-4jYpcjabC606xJ3kw2QwGEZKX0Aw7sgQdZCvIK9dhVSPh76BKo+C+btT1RRofH7B+8iNpEbgGNVWiLki5q93yg==",
      "dev": true,
      "funding": [
        {
          "type": "opencollective",
          "url": "https://opencollective.com/browserslist"
        },
        {
          "type": "tidelift",
          "url": "https://tidelift.com/funding/github/npm/browserslist"
        },
        {
          "type": "github",
          "url": "https://github.com/sponsors/ai"
        }
      ],
      "license": "MIT",
      "dependencies": {
        "caniuse-lite": "^1.0.30001737",
        "electron-to-chromium": "^1.5.211",
        "node-releases": "^2.0.19",
        "update-browserslist-db": "^1.1.3"
      },
      "bin": {
        "browserslist": "cli.js"
      },
      "engines": {
        "node": "^6 || ^7 || ^8 || ^9 || ^10 || ^11 || ^12 || >=13.7"
      }
    },
    "node_modules/bser": {
      "version": "2.1.1",
      "resolved": "https://registry.npmjs.org/bser/-/bser-2.1.1.tgz",
      "integrity": "sha512-gQxTNE/GAfIIrmHLUE3oJyp5FO6HRBfhjnw4/wMmA63ZGDJnWBmgY/lyQBpnDUkGmAhbSe39tx2d/iTOAfglwQ==",
      "dev": true,
      "license": "Apache-2.0",
      "dependencies": {
        "node-int64": "^0.4.0"
      }
    },
    "node_modules/buffer-from": {
      "version": "1.1.2",
      "resolved": "https://registry.npmjs.org/buffer-from/-/buffer-from-1.1.2.tgz",
      "integrity": "sha512-E+XQCRwSbaaiChtv6k6Dwgc+bx+Bs6vuKJHHl5kox/BaKbhiXzqQOwK4cO22yElGp2OCmjwVhT3HmxgyPGnJfQ==",
      "dev": true,
      "license": "MIT"
    },
    "node_modules/callsites": {
      "version": "3.1.0",
      "resolved": "https://registry.npmjs.org/callsites/-/callsites-3.1.0.tgz",
      "integrity": "sha512-P8BjAsXvZS+VIDUI11hHCQEv74YT67YUi5JJFNWIqL235sBmjX4+qx9Muvls5ivyNENctx46xQLQ3aTuE7ssaQ==",
      "dev": true,
      "license": "MIT",
      "engines": {
        "node": ">=6"
      }
    },
    "node_modules/camelcase": {
      "version": "5.3.1",
      "resolved": "https://registry.npmjs.org/camelcase/-/camelcase-5.3.1.tgz",
      "integrity": "sha512-L28STB170nwWS63UjtlEOE3dldQApaJXZkOI1uMFfzf3rRuPegHaHesyee+YxQ+W6SvRDQV6UrdOdRiR153wJg==",
      "dev": true,
      "license": "MIT",
      "engines": {
        "node": ">=6"
      }
    },
    "node_modules/caniuse-lite": {
      "version": "1.0.30001741",
      "resolved": "https://registry.npmjs.org/caniuse-lite/-/caniuse-lite-1.0.30001741.tgz",
      "integrity": "sha512-QGUGitqsc8ARjLdgAfxETDhRbJ0REsP6O3I96TAth/mVjh2cYzN2u+3AzPP3aVSm2FehEItaJw1xd+IGBXWeSw==",
      "dev": true,
      "funding": [
        {
          "type": "opencollective",
          "url": "https://opencollective.com/browserslist"
        },
        {
          "type": "tidelift",
          "url": "https://tidelift.com/funding/github/npm/caniuse-lite"
        },
        {
          "type": "github",
          "url": "https://github.com/sponsors/ai"
        }
      ],
      "license": "CC-BY-4.0"
    },
    "node_modules/chalk": {
      "version": "4.1.2",
      "resolved": "https://registry.npmjs.org/chalk/-/chalk-4.1.2.tgz",
      "integrity": "sha512-oKnbhFyRIXpUuez8iBMmyEa4nbj4IOQyuhc/wy9kY7/WVPcwIO9VA668Pu8RkO7+0G76SLROeyw9CpQ061i4mA==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "ansi-styles": "^4.1.0",
        "supports-color": "^7.1.0"
      },
      "engines": {
        "node": ">=10"
      },
      "funding": {
        "url": "https://github.com/chalk/chalk?sponsor=1"
      }
    },
    "node_modules/char-regex": {
      "version": "1.0.2",
      "resolved": "https://registry.npmjs.org/char-regex/-/char-regex-1.0.2.tgz",
      "integrity": "sha512-kWWXztvZ5SBQV+eRgKFeh8q5sLuZY2+8WUIzlxWVTg+oGwY14qylx1KbKzHd8P6ZYkAg0xyIDU9JMHhyJMZ1jw==",
      "dev": true,
      "license": "MIT",
      "engines": {
        "node": ">=10"
      }
    },
    "node_modules/ci-info": {
      "version": "3.9.0",
      "resolved": "https://registry.npmjs.org/ci-info/-/ci-info-3.9.0.tgz",
      "integrity": "sha512-NIxF55hv4nSqQswkAeiOi1r83xy8JldOFDTWiug55KBu9Jnblncd2U6ViHmYgHf01TPZS77NJBhBMKdWj9HQMQ==",
      "dev": true,
      "funding": [
        {
          "type": "github",
          "url": "https://github.com/sponsors/sibiraj-s"
        }
      ],
      "license": "MIT",
      "engines": {
        "node": ">=8"
      }
    },
    "node_modules/cjs-module-lexer": {
      "version": "1.4.3",
      "resolved": "https://registry.npmjs.org/cjs-module-lexer/-/cjs-module-lexer-1.4.3.tgz",
      "integrity": "sha512-9z8TZaGM1pfswYeXrUpzPrkx8UnWYdhJclsiYMm6x/w5+nN+8Tf/LnAgfLGQCm59qAOxU8WwHEq2vNwF6i4j+Q==",
      "dev": true,
      "license": "MIT"
    },
    "node_modules/cliui": {
      "version": "8.0.1",
      "resolved": "https://registry.npmjs.org/cliui/-/cliui-8.0.1.tgz",
      "integrity": "sha512-BSeNnyus75C4//NQ9gQt1/csTXyo/8Sb+afLAkzAptFuMsod9HFokGNudZpi/oQV73hnVK+sR+5PVRMd+Dr7YQ==",
      "dev": true,
      "license": "ISC",
      "dependencies": {
        "string-width": "^4.2.0",
        "strip-ansi": "^6.0.1",
        "wrap-ansi": "^7.0.0"
      },
      "engines": {
        "node": ">=12"
      }
    },
    "node_modules/co": {
      "version": "4.6.0",
      "resolved": "https://registry.npmjs.org/co/-/co-4.6.0.tgz",
      "integrity": "sha512-QVb0dM5HvG+uaxitm8wONl7jltx8dqhfU33DcqtOZcLSVIKSDDLDi7+0LbAKiyI8hD9u42m2YxXSkMGWThaecQ==",
      "dev": true,
      "license": "MIT",
      "engines": {
        "iojs": ">= 1.0.0",
        "node": ">= 0.12.0"
      }
    },
    "node_modules/collect-v8-coverage": {
      "version": "1.0.2",
      "resolved": "https://registry.npmjs.org/collect-v8-coverage/-/collect-v8-coverage-1.0.2.tgz",
      "integrity": "sha512-lHl4d5/ONEbLlJvaJNtsF/Lz+WvB07u2ycqTYbdrq7UypDXailES4valYb2eWiJFxZlVmpGekfqoxQhzyFdT4Q==",
      "dev": true,
      "license": "MIT"
    },
    "node_modules/color-convert": {
      "version": "2.0.1",
      "resolved": "https://registry.npmjs.org/color-convert/-/color-convert-2.0.1.tgz",
      "integrity": "sha512-RRECPsj7iu/xb5oKYcsFHSppFNnsj/52OVTRKb4zP5onXwVF3zVmmToNcOfGC+CRDpfK/U584fMg38ZHCaElKQ==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "color-name": "~1.1.4"
      },
      "engines": {
        "node": ">=7.0.0"
      }
    },
    "node_modules/color-name": {
      "version": "1.1.4",
      "resolved": "https://registry.npmjs.org/color-name/-/color-name-1.1.4.tgz",
      "integrity": "sha512-dOy+3AuW3a2wNbZHIuMZpTcgjGuLU/uBL/ubcZF9OXbDo8ff4O8yVp5Bf0efS8uEoYo5q4Fx7dY9OgQGXgAsQA==",
      "dev": true,
      "license": "MIT"
    },
    "node_modules/concat-map": {
      "version": "0.0.1",
      "resolved": "https://registry.npmjs.org/concat-map/-/concat-map-0.0.1.tgz",
      "integrity": "sha512-/Srv4dswyQNBfohGpz9o6Yb3Gz3SrUDqBH5rTuhGR7ahtlbYKnVxw2bCFMRljaA7EXHaXZ8wsHdodFvbkhKmqg==",
      "dev": true,
      "license": "MIT"
    },
    "node_modules/convert-source-map": {
      "version": "2.0.0",
      "resolved": "https://registry.npmjs.org/convert-source-map/-/convert-source-map-2.0.0.tgz",
      "integrity": "sha512-Kvp459HrV2FEJ1CAsi1Ku+MY3kasH19TFykTz2xWmMeq6bk2NU3XXvfJ+Q61m0xktWwt+1HSYf3JZsTms3aRJg==",
      "dev": true,
      "license": "MIT"
    },
    "node_modules/create-jest": {
      "version": "29.7.0",
      "resolved": "https://registry.npmjs.org/create-jest/-/create-jest-29.7.0.tgz",
      "integrity": "sha512-Adz2bdH0Vq3F53KEMJOoftQFutWCukm6J24wbPWRO4k1kMY7gS7ds/uoJkNuV8wDCtWWnuwGcJwpWcih+zEW1Q==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "@jest/types": "^29.6.3",
        "chalk": "^4.0.0",
        "exit": "^0.1.2",
        "graceful-fs": "^4.2.9",
        "jest-config": "^29.7.0",
        "jest-util": "^29.7.0",
        "prompts": "^2.0.1"
      },
      "bin": {
        "create-jest": "bin/create-jest.js"
      },
      "engines": {
        "node": "^14.15.0 || ^16.10.0 || >=18.0.0"
      }
    },
    "node_modules/cross-spawn": {
      "version": "7.0.6",
      "resolved": "https://registry.npmjs.org/cross-spawn/-/cross-spawn-7.0.6.tgz",
      "integrity": "sha512-uV2QOWP2nWzsy2aMp8aRibhi9dlzF5Hgh5SHaB9OiTGEyDTiJJyx0uy51QXdyWbtAHNua4XJzUKca3OzKUd3vA==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "path-key": "^3.1.0",
        "shebang-command": "^2.0.0",
        "which": "^2.0.1"
      },
      "engines": {
        "node": ">= 8"
      }
    },
    "node_modules/debug": {
      "version": "4.4.1",
      "resolved": "https://registry.npmjs.org/debug/-/debug-4.4.1.tgz",
      "integrity": "sha512-KcKCqiftBJcZr++7ykoDIEwSa3XWowTfNPo92BYxjXiyYEVrUQh2aLyhxBCwww+heortUFxEJYcRzosstTEBYQ==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "ms": "^2.1.3"
      },
      "engines": {
        "node": ">=6.0"
      },
      "peerDependenciesMeta": {
        "supports-color": {
          "optional": true
        }
      }
    },
    "node_modules/dedent": {
      "version": "1.7.0",
      "resolved": "https://registry.npmjs.org/dedent/-/dedent-1.7.0.tgz",
      "integrity": "sha512-HGFtf8yhuhGhqO07SV79tRp+br4MnbdjeVxotpn1QBl30pcLLCQjX5b2295ll0fv8RKDKsmWYrl05usHM9CewQ==",
      "dev": true,
      "license": "MIT",
      "peerDependencies": {
        "babel-plugin-macros": "^3.1.0"
      },
      "peerDependenciesMeta": {
        "babel-plugin-macros": {
          "optional": true
        }
      }
    },
    "node_modules/deepmerge": {
      "version": "4.3.1",
      "resolved": "https://registry.npmjs.org/deepmerge/-/deepmerge-4.3.1.tgz",
      "integrity": "sha512-3sUqbMEc77XqpdNO7FRyRog+eW3ph+GYCbj+rK+uYyRMuwsVy0rMiVtPn+QJlKFvWP/1PYpapqYn0Me2knFn+A==",
      "dev": true,
      "license": "MIT",
      "engines": {
        "node": ">=0.10.0"
      }
    },
    "node_modules/detect-newline": {
      "version": "3.1.0",
      "resolved": "https://registry.npmjs.org/detect-newline/-/detect-newline-3.1.0.tgz",
      "integrity": "sha512-TLz+x/vEXm/Y7P7wn1EJFNLxYpUD4TgMosxY6fAVJUnJMbupHBOncxyWUG9OpTaH9EBD7uFI5LfEgmMOc54DsA==",
      "dev": true,
      "license": "MIT",
      "engines": {
        "node": ">=8"
      }
    },
    "node_modules/diff-sequences": {
      "version": "29.6.3",
      "resolved": "https://registry.npmjs.org/diff-sequences/-/diff-sequences-29.6.3.tgz",
      "integrity": "sha512-EjePK1srD3P08o2j4f0ExnylqRs5B9tJjcp9t1krH2qRi8CCdsYfwe9JgSLurFBWwq4uOlipzfk5fHNvwFKr8Q==",
      "dev": true,
      "license": "MIT",
      "engines": {
        "node": "^14.15.0 || ^16.10.0 || >=18.0.0"
      }
    },
    "node_modules/discord-api-types": {
      "version": "0.38.23",
      "resolved": "https://registry.npmjs.org/discord-api-types/-/discord-api-types-0.38.23.tgz",
      "integrity": "sha512-C8VjK0yxBUq1dakxGpUXQm4VSC7R+aaD2SIr3paj2a0bP/LRok1AqHiezp30GruK6Ba9FtQAKqYUMJPzsqv7IQ==",
      "license": "MIT",
      "workspaces": [
        "scripts/actions/documentation"
      ]
    },
    "node_modules/discord.js": {
      "version": "14.22.1",
      "resolved": "https://registry.npmjs.org/discord.js/-/discord.js-14.22.1.tgz",
      "integrity": "sha512-3k+Kisd/v570Jr68A1kNs7qVhNehDwDJAPe4DZ2Syt+/zobf9zEcuYFvsfIaAOgCa0BiHMfOOKQY4eYINl0z7w==",
      "license": "Apache-2.0",
      "dependencies": {
        "@discordjs/builders": "^1.11.2",
        "@discordjs/collection": "1.5.3",
        "@discordjs/formatters": "^0.6.1",
        "@discordjs/rest": "^2.6.0",
        "@discordjs/util": "^1.1.1",
        "@discordjs/ws": "^1.2.3",
        "@sapphire/snowflake": "3.5.3",
        "discord-api-types": "^0.38.16",
        "fast-deep-equal": "3.1.3",
        "lodash.snakecase": "4.1.1",
        "magic-bytes.js": "^1.10.0",
        "tslib": "^2.6.3",
        "undici": "6.21.3"
      },
      "engines": {
        "node": ">=18"
      },
      "funding": {
        "url": "https://github.com/discordjs/discord.js?sponsor"
      }
    },
    "node_modules/dotenv": {
      "version": "17.2.2",
      "resolved": "https://registry.npmjs.org/dotenv/-/dotenv-17.2.2.tgz",
      "integrity": "sha512-Sf2LSQP+bOlhKWWyhFsn0UsfdK/kCWRv1iuA2gXAwt3dyNabr6QSj00I2V10pidqz69soatm9ZwZvpQMTIOd5Q==",
      "license": "BSD-2-Clause",
      "engines": {
        "node": ">=12"
      },
      "funding": {
        "url": "https://dotenvx.com"
      }
    },
    "node_modules/electron-to-chromium": {
      "version": "1.5.215",
      "resolved": "https://registry.npmjs.org/electron-to-chromium/-/electron-to-chromium-1.5.215.tgz",
      "integrity": "sha512-TIvGp57UpeNetj/wV/xpFNpWGb0b/ROw372lHPx5Aafx02gjTBtWnEEcaSX3W2dLM3OSdGGyHX/cHl01JQsLaQ==",
      "dev": true,
      "license": "ISC"
    },
    "node_modules/emittery": {
      "version": "0.13.1",
      "resolved": "https://registry.npmjs.org/emittery/-/emittery-0.13.1.tgz",
      "integrity": "sha512-DeWwawk6r5yR9jFgnDKYt4sLS0LmHJJi3ZOnb5/JdbYwj3nW+FxQnHIjhBKz8YLC7oRNPVM9NQ47I3CVx34eqQ==",
      "dev": true,
      "license": "MIT",
      "engines": {
        "node": ">=12"
      },
      "funding": {
        "url": "https://github.com/sindresorhus/emittery?sponsor=1"
      }
    },
    "node_modules/emoji-regex": {
      "version": "8.0.0",
      "resolved": "https://registry.npmjs.org/emoji-regex/-/emoji-regex-8.0.0.tgz",
      "integrity": "sha512-MSjYzcWNOA0ewAHpz0MxpYFvwg6yjy1NG3xteoqz644VCo/RPgnr1/GGt+ic3iJTzQ8Eu3TdM14SawnVUmGE6A==",
      "dev": true,
      "license": "MIT"
    },
    "node_modules/error-ex": {
      "version": "1.3.2",
      "resolved": "https://registry.npmjs.org/error-ex/-/error-ex-1.3.2.tgz",
      "integrity": "sha512-7dFHNmqeFSEt2ZBsCriorKnn3Z2pj+fd9kmI6QoWw4//DL+icEBfc0U7qJCisqrTsKTjw4fNFy2pW9OqStD84g==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "is-arrayish": "^0.2.1"
      }
    },
    "node_modules/escalade": {
      "version": "3.2.0",
      "resolved": "https://registry.npmjs.org/escalade/-/escalade-3.2.0.tgz",
      "integrity": "sha512-WUj2qlxaQtO4g6Pq5c29GTcWGDyd8itL8zTlipgECz3JesAiiOKotd8JU6otB3PACgG6xkJUyVhboMS+bje/jA==",
      "dev": true,
      "license": "MIT",
      "engines": {
        "node": ">=6"
      }
    },
    "node_modules/escape-string-regexp": {
      "version": "2.0.0",
      "resolved": "https://registry.npmjs.org/escape-string-regexp/-/escape-string-regexp-2.0.0.tgz",
      "integrity": "sha512-UpzcLCXolUWcNu5HtVMHYdXJjArjsF9C0aNnquZYY4uW/Vu0miy5YoWvbV345HauVvcAUnpRuhMMcqTcGOY2+w==",
      "dev": true,
      "license": "MIT",
      "engines": {
        "node": ">=8"
      }
    },
    "node_modules/esprima": {
      "version": "4.0.1",
      "resolved": "https://registry.npmjs.org/esprima/-/esprima-4.0.1.tgz",
      "integrity": "sha512-eGuFFw7Upda+g4p+QHvnW0RyTX/SVeJBDM/gCtMARO0cLuT2HcEKnTPvhjV6aGeqrCB/sbNop0Kszm0jsaWU4A==",
      "dev": true,
      "license": "BSD-2-Clause",
      "bin": {
        "esparse": "bin/esparse.js",
        "esvalidate": "bin/esvalidate.js"
      },
      "engines": {
        "node": ">=4"
      }
    },
    "node_modules/execa": {
      "version": "5.1.1",
      "resolved": "https://registry.npmjs.org/execa/-/execa-5.1.1.tgz",
      "integrity": "sha512-8uSpZZocAZRBAPIEINJj3Lo9HyGitllczc27Eh5YYojjMFMn8yHMDMaUHE2Jqfq05D/wucwI4JGURyXt1vchyg==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "cross-spawn": "^7.0.3",
        "get-stream": "^6.0.0",
        "human-signals": "^2.1.0",
        "is-stream": "^2.0.0",
        "merge-stream": "^2.0.0",
        "npm-run-path": "^4.0.1",
        "onetime": "^5.1.2",
        "signal-exit": "^3.0.3",
        "strip-final-newline": "^2.0.0"
      },
      "engines": {
        "node": ">=10"
      },
      "funding": {
        "url": "https://github.com/sindresorhus/execa?sponsor=1"
      }
    },
    "node_modules/exit": {
      "version": "0.1.2",
      "resolved": "https://registry.npmjs.org/exit/-/exit-0.1.2.tgz",
      "integrity": "sha512-Zk/eNKV2zbjpKzrsQ+n1G6poVbErQxJ0LBOJXaKZ1EViLzH+hrLu9cdXI4zw9dBQJslwBEpbQ2P1oS7nDxs6jQ==",
      "dev": true,
      "engines": {
        "node": ">= 0.8.0"
      }
    },
    "node_modules/expect": {
      "version": "29.7.0",
      "resolved": "https://registry.npmjs.org/expect/-/expect-29.7.0.tgz",
      "integrity": "sha512-2Zks0hf1VLFYI1kbh0I5jP3KHHyCHpkfyHBzsSXRFgl/Bg9mWYfMW8oD+PdMPlEwy5HNsR9JutYy6pMeOh61nw==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "@jest/expect-utils": "^29.7.0",
        "jest-get-type": "^29.6.3",
        "jest-matcher-utils": "^29.7.0",
        "jest-message-util": "^29.7.0",
        "jest-util": "^29.7.0"
      },
      "engines": {
        "node": "^14.15.0 || ^16.10.0 || >=18.0.0"
      }
    },
    "node_modules/fast-deep-equal": {
      "version": "3.1.3",
      "resolved": "https://registry.npmjs.org/fast-deep-equal/-/fast-deep-equal-3.1.3.tgz",
      "integrity": "sha512-f3qQ9oQy9j2AhBe/H9VC91wLmKBCCU/gDOnKNAYG5hswO7BLKj09Hc5HYNz9cGI++xlpDCIgDaitVs03ATR84Q==",
      "license": "MIT"
    },
    "node_modules/fast-json-stable-stringify": {
      "version": "2.1.0",
      "resolved": "https://registry.npmjs.org/fast-json-stable-stringify/-/fast-json-stable-stringify-2.1.0.tgz",
      "integrity": "sha512-lhd/wF+Lk98HZoTCtlVraHtfh5XYijIjalXck7saUtuanSDyLMxnHhSXEDJqHxD7msR8D0uCmqlkwjCV8xvwHw==",
      "dev": true,
      "license": "MIT"
    },
    "node_modules/fb-watchman": {
      "version": "2.0.2",
      "resolved": "https://registry.npmjs.org/fb-watchman/-/fb-watchman-2.0.2.tgz",
      "integrity": "sha512-p5161BqbuCaSnB8jIbzQHOlpgsPmK5rJVDfDKO91Axs5NC1uu3HRQm6wt9cd9/+GtQQIO53JdGXXoyDpTAsgYA==",
      "dev": true,
      "license": "Apache-2.0",
      "dependencies": {
        "bser": "2.1.1"
      }
    },
    "node_modules/fill-range": {
      "version": "7.1.1",
      "resolved": "https://registry.npmjs.org/fill-range/-/fill-range-7.1.1.tgz",
      "integrity": "sha512-YsGpe3WHLK8ZYi4tWDg2Jy3ebRz2rXowDxnld4bkQB00cc/1Zw9AWnC0i9ztDJitivtQvaI9KaLyKrc+hBW0yg==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "to-regex-range": "^5.0.1"
      },
      "engines": {
        "node": ">=8"
      }
    },
    "node_modules/find-up": {
      "version": "4.1.0",
      "resolved": "https://registry.npmjs.org/find-up/-/find-up-4.1.0.tgz",
      "integrity": "sha512-PpOwAdQ/YlXQ2vj8a3h8IipDuYRi3wceVQQGYWxNINccq40Anw7BlsEXCMbt1Zt+OLA6Fq9suIpIWD0OsnISlw==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "locate-path": "^5.0.0",
        "path-exists": "^4.0.0"
      },
      "engines": {
        "node": ">=8"
      }
    },
    "node_modules/fs.realpath": {
      "version": "1.0.0",
      "resolved": "https://registry.npmjs.org/fs.realpath/-/fs.realpath-1.0.0.tgz",
      "integrity": "sha512-OO0pH2lK6a0hZnAdau5ItzHPI6pUlvI7jMVnxUQRtw4owF2wk8lOSabtGDCTP4Ggrg2MbGnWO9X8K1t4+fGMDw==",
      "dev": true,
      "license": "ISC"
    },
    "node_modules/fsevents": {
      "version": "2.3.3",
      "resolved": "https://registry.npmjs.org/fsevents/-/fsevents-2.3.3.tgz",
      "integrity": "sha512-5xoDfX+fL7faATnagmWPpbFtwh/R77WmMMqqHGS65C3vvB0YHrgF+B1YmZ3441tMj5n63k0212XNoJwzlhffQw==",
      "dev": true,
      "hasInstallScript": true,
      "license": "MIT",
      "optional": true,
      "os": [
        "darwin"
      ],
      "engines": {
        "node": "^8.16.0 || ^10.6.0 || >=11.0.0"
      }
    },
    "node_modules/function-bind": {
      "version": "1.1.2",
      "resolved": "https://registry.npmjs.org/function-bind/-/function-bind-1.1.2.tgz",
      "integrity": "sha512-7XHNxH7qX9xG5mIwxkhumTox/MIRNcOgDrxWsMt2pAr23WHp6MrRlN7FBSFpCpr+oVO0F744iUgR82nJMfG2SA==",
      "dev": true,
      "license": "MIT",
      "funding": {
        "url": "https://github.com/sponsors/ljharb"
      }
    },
    "node_modules/gensync": {
      "version": "1.0.0-beta.2",
      "resolved": "https://registry.npmjs.org/gensync/-/gensync-1.0.0-beta.2.tgz",
      "integrity": "sha512-3hN7NaskYvMDLQY55gnW3NQ+mesEAepTqlg+VEbj7zzqEMBVNhzcGYYeqFo/TlYz6eQiFcp1HcsCZO+nGgS8zg==",
      "dev": true,
      "license": "MIT",
      "engines": {
        "node": ">=6.9.0"
      }
    },
    "node_modules/get-caller-file": {
      "version": "2.0.5",
      "resolved": "https://registry.npmjs.org/get-caller-file/-/get-caller-file-2.0.5.tgz",
      "integrity": "sha512-DyFP3BM/3YHTQOCUL/w0OZHR0lpKeGrxotcHWcqNEdnltqFwXVfhEBQ94eIo34AfQpo0rGki4cyIiftY06h2Fg==",
      "dev": true,
      "license": "ISC",
      "engines": {
        "node": "6.* || 8.* || >= 10.*"
      }
    },
    "node_modules/get-package-type": {
      "version": "0.1.0",
      "resolved": "https://registry.npmjs.org/get-package-type/-/get-package-type-0.1.0.tgz",
      "integrity": "sha512-pjzuKtY64GYfWizNAJ0fr9VqttZkNiK2iS430LtIHzjBEr6bX8Am2zm4sW4Ro5wjWW5cAlRL1qAMTcXbjNAO2Q==",
      "dev": true,
      "license": "MIT",
      "engines": {
        "node": ">=8.0.0"
      }
    },
    "node_modules/get-stream": {
      "version": "6.0.1",
      "resolved": "https://registry.npmjs.org/get-stream/-/get-stream-6.0.1.tgz",
      "integrity": "sha512-ts6Wi+2j3jQjqi70w5AlN8DFnkSwC+MqmxEzdEALB2qXZYV3X/b1CTfgPLGJNMeAWxdPfU8FO1ms3NUfaHCPYg==",
      "dev": true,
      "license": "MIT",
      "engines": {
        "node": ">=10"
      },
      "funding": {
        "url": "https://github.com/sponsors/sindresorhus"
      }
    },
    "node_modules/glob": {
      "version": "7.2.3",
      "resolved": "https://registry.npmjs.org/glob/-/glob-7.2.3.tgz",
      "integrity": "sha512-nFR0zLpU2YCaRxwoCJvL6UvCH2JFyFVIvwTLsIf21AuHlMskA1hhTdk+LlYJtOlYt9v6dvszD2BGRqBL+iQK9Q==",
      "deprecated": "Glob versions prior to v9 are no longer supported",
      "dev": true,
      "license": "ISC",
      "dependencies": {
        "fs.realpath": "^1.0.0",
        "inflight": "^1.0.4",
        "inherits": "2",
        "minimatch": "^3.1.1",
        "once": "^1.3.0",
        "path-is-absolute": "^1.0.0"
      },
      "engines": {
        "node": "*"
      },
      "funding": {
        "url": "https://github.com/sponsors/isaacs"
      }
    },
    "node_modules/graceful-fs": {
      "version": "4.2.11",
      "resolved": "https://registry.npmjs.org/graceful-fs/-/graceful-fs-4.2.11.tgz",
      "integrity": "sha512-RbJ5/jmFcNNCcDV5o9eTnBLJ/HszWV0P73bc+Ff4nS/rJj+YaS6IGyiOL0VoBYX+l1Wrl3k63h/KrH+nhJ0XvQ==",
      "dev": true,
      "license": "ISC"
    },
    "node_modules/has-flag": {
      "version": "4.0.0",
      "resolved": "https://registry.npmjs.org/has-flag/-/has-flag-4.0.0.tgz",
      "integrity": "sha512-EykJT/Q1KjTWctppgIAgfSO0tKVuZUjhgMr17kqTumMl6Afv3EISleU7qZUzoXDFTAHTDC4NOoG/ZxU3EvlMPQ==",
      "dev": true,
      "license": "MIT",
      "engines": {
        "node": ">=8"
      }
    },
    "node_modules/hasown": {
      "version": "2.0.2",
      "resolved": "https://registry.npmjs.org/hasown/-/hasown-2.0.2.tgz",
      "integrity": "sha512-0hJU9SCPvmMzIBdZFqNPXWa6dqh7WdH0cII9y+CyS8rG3nL48Bclra9HmKhVVUHyPWNH5Y7xDwAB7bfgSjkUMQ==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "function-bind": "^1.1.2"
      },
      "engines": {
        "node": ">= 0.4"
      }
    },
    "node_modules/html-escaper": {
      "version": "2.0.2",
      "resolved": "https://registry.npmjs.org/html-escaper/-/html-escaper-2.0.2.tgz",
      "integrity": "sha512-H2iMtd0I4Mt5eYiapRdIDjp+XzelXQ0tFE4JS7YFwFevXXMmOp9myNrUvCg0D6ws8iqkRPBfKHgbwig1SmlLfg==",
      "dev": true,
      "license": "MIT"
    },
    "node_modules/human-signals": {
      "version": "2.1.0",
      "resolved": "https://registry.npmjs.org/human-signals/-/human-signals-2.1.0.tgz",
      "integrity": "sha512-B4FFZ6q/T2jhhksgkbEW3HBvWIfDW85snkQgawt07S7J5QXTk6BkNV+0yAeZrM5QpMAdYlocGoljn0sJ/WQkFw==",
      "dev": true,
      "license": "Apache-2.0",
      "engines": {
        "node": ">=10.17.0"
      }
    },
    "node_modules/import-local": {
      "version": "3.2.0",
      "resolved": "https://registry.npmjs.org/import-local/-/import-local-3.2.0.tgz",
      "integrity": "sha512-2SPlun1JUPWoM6t3F0dw0FkCF/jWY8kttcY4f599GLTSjh2OCuuhdTkJQsEcZzBqbXZGKMK2OqW1oZsjtf/gQA==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "pkg-dir": "^4.2.0",
        "resolve-cwd": "^3.0.0"
      },
      "bin": {
        "import-local-fixture": "fixtures/cli.js"
      },
      "engines": {
        "node": ">=8"
      },
      "funding": {
        "url": "https://github.com/sponsors/sindresorhus"
      }
    },
    "node_modules/imurmurhash": {
      "version": "0.1.4",
      "resolved": "https://registry.npmjs.org/imurmurhash/-/imurmurhash-0.1.4.tgz",
      "integrity": "sha512-JmXMZ6wuvDmLiHEml9ykzqO6lwFbof0GG4IkcGaENdCRDDmMVnny7s5HsIgHCbaq0w2MyPhDqkhTUgS2LU2PHA==",
      "dev": true,
      "license": "MIT",
      "engines": {
        "node": ">=0.8.19"
      }
    },
    "node_modules/inflight": {
      "version": "1.0.6",
      "resolved": "https://registry.npmjs.org/inflight/-/inflight-1.0.6.tgz",
      "integrity": "sha512-k92I/b08q4wvFscXCLvqfsHCrjrF7yiXsQuIVvVE7N82W3+aqpzuUdBbfhWcy/FZR3/4IgflMgKLOsvPDrGCJA==",
      "deprecated": "This module is not supported, and leaks memory. Do not use it. Check out lru-cache if you want a good and tested way to coalesce async requests by a key value, which is much more comprehensive and powerful.",
      "dev": true,
      "license": "ISC",
      "dependencies": {
        "once": "^1.3.0",
        "wrappy": "1"
      }
    },
    "node_modules/inherits": {
      "version": "2.0.4",
      "resolved": "https://registry.npmjs.org/inherits/-/inherits-2.0.4.tgz",
      "integrity": "sha512-k/vGaX4/Yla3WzyMCvTQOXYeIHvqOKtnqBduzTHpzpQZzAskKMhZ2K+EnBiSM9zGSoIFeMpXKxa4dYeZIQqewQ==",
      "dev": true,
      "license": "ISC"
    },
    "node_modules/is-arrayish": {
      "version": "0.2.1",
      "resolved": "https://registry.npmjs.org/is-arrayish/-/is-arrayish-0.2.1.tgz",
      "integrity": "sha512-zz06S8t0ozoDXMG+ube26zeCTNXcKIPJZJi8hBrF4idCLms4CG9QtK7qBl1boi5ODzFpjswb5JPmHCbMpjaYzg==",
      "dev": true,
      "license": "MIT"
    },
    "node_modules/is-core-module": {
      "version": "2.16.1",
      "resolved": "https://registry.npmjs.org/is-core-module/-/is-core-module-2.16.1.tgz",
      "integrity": "sha512-UfoeMA6fIJ8wTYFEUjelnaGI67v6+N7qXJEvQuIGa99l4xsCruSYOVSQ0uPANn4dAzm8lkYPaKLrrijLq7x23w==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "hasown": "^2.0.2"
      },
      "engines": {
        "node": ">= 0.4"
      },
      "funding": {
        "url": "https://github.com/sponsors/ljharb"
      }
    },
    "node_modules/is-fullwidth-code-point": {
      "version": "3.0.0",
      "resolved": "https://registry.npmjs.org/is-fullwidth-code-point/-/is-fullwidth-code-point-3.0.0.tgz",
      "integrity": "sha512-zymm5+u+sCsSWyD9qNaejV3DFvhCKclKdizYaJUuHA83RLjb7nSuGnddCHGv0hk+KY7BMAlsWeK4Ueg6EV6XQg==",
      "dev": true,
      "license": "MIT",
      "engines": {
        "node": ">=8"
      }
    },
    "node_modules/is-generator-fn": {
      "version": "2.1.0",
      "resolved": "https://registry.npmjs.org/is-generator-fn/-/is-generator-fn-2.1.0.tgz",
      "integrity": "sha512-cTIB4yPYL/Grw0EaSzASzg6bBy9gqCofvWN8okThAYIxKJZC+udlRAmGbM0XLeniEJSs8uEgHPGuHSe1XsOLSQ==",
      "dev": true,
      "license": "MIT",
      "engines": {
        "node": ">=6"
      }
    },
    "node_modules/is-number": {
      "version": "7.0.0",
      "resolved": "https://registry.npmjs.org/is-number/-/is-number-7.0.0.tgz",
      "integrity": "sha512-41Cifkg6e8TylSpdtTpeLVMqvSBEVzTttHvERD741+pnZ8ANv0004MRL43QKPDlK9cGvNp6NZWZUBlbGXYxxng==",
      "dev": true,
      "license": "MIT",
      "engines": {
        "node": ">=0.12.0"
      }
    },
    "node_modules/is-stream": {
      "version": "2.0.1",
      "resolved": "https://registry.npmjs.org/is-stream/-/is-stream-2.0.1.tgz",
      "integrity": "sha512-hFoiJiTl63nn+kstHGBtewWSKnQLpyb155KHheA1l39uvtO9nWIop1p3udqPcUd/xbF1VLMO4n7OI6p7RbngDg==",
      "dev": true,
      "license": "MIT",
      "engines": {
        "node": ">=8"
      },
      "funding": {
        "url": "https://github.com/sponsors/sindresorhus"
      }
    },
    "node_modules/isexe": {
      "version": "2.0.0",
      "resolved": "https://registry.npmjs.org/isexe/-/isexe-2.0.0.tgz",
      "integrity": "sha512-RHxMLp9lnKHGHRng9QFhRCMbYAcVpn69smSGcq3f36xjgVVWThj4qqLbTLlq7Ssj8B+fIQ1EuCEGI2lKsyQeIw==",
      "dev": true,
      "license": "ISC"
    },
    "node_modules/istanbul-lib-coverage": {
      "version": "3.2.2",
      "resolved": "https://registry.npmjs.org/istanbul-lib-coverage/-/istanbul-lib-coverage-3.2.2.tgz",
      "integrity": "sha512-O8dpsF+r0WV/8MNRKfnmrtCWhuKjxrq2w+jpzBL5UZKTi2LeVWnWOmWRxFlesJONmc+wLAGvKQZEOanko0LFTg==",
      "dev": true,
      "license": "BSD-3-Clause",
      "engines": {
        "node": ">=8"
      }
    },
    "node_modules/istanbul-lib-instrument": {
      "version": "6.0.3",
      "resolved": "https://registry.npmjs.org/istanbul-lib-instrument/-/istanbul-lib-instrument-6.0.3.tgz",
      "integrity": "sha512-Vtgk7L/R2JHyyGW07spoFlB8/lpjiOLTjMdms6AFMraYt3BaJauod/NGrfnVG/y4Ix1JEuMRPDPEj2ua+zz1/Q==",
      "dev": true,
      "license": "BSD-3-Clause",
      "dependencies": {
        "@babel/core": "^7.23.9",
        "@babel/parser": "^7.23.9",
        "@istanbuljs/schema": "^0.1.3",
        "istanbul-lib-coverage": "^3.2.0",
        "semver": "^7.5.4"
      },
      "engines": {
        "node": ">=10"
      }
    },
    "node_modules/istanbul-lib-instrument/node_modules/semver": {
      "version": "7.7.2",
      "resolved": "https://registry.npmjs.org/semver/-/semver-7.7.2.tgz",
      "integrity": "sha512-RF0Fw+rO5AMf9MAyaRXI4AV0Ulj5lMHqVxxdSgiVbixSCXoEmmX/jk0CuJw4+3SqroYO9VoUh+HcuJivvtJemA==",
      "dev": true,
      "license": "ISC",
      "bin": {
        "semver": "bin/semver.js"
      },
      "engines": {
        "node": ">=10"
      }
    },
    "node_modules/istanbul-lib-report": {
      "version": "3.0.1",
      "resolved": "https://registry.npmjs.org/istanbul-lib-report/-/istanbul-lib-report-3.0.1.tgz",
      "integrity": "sha512-GCfE1mtsHGOELCU8e/Z7YWzpmybrx/+dSTfLrvY8qRmaY6zXTKWn6WQIjaAFw069icm6GVMNkgu0NzI4iPZUNw==",
      "dev": true,
      "license": "BSD-3-Clause",
      "dependencies": {
        "istanbul-lib-coverage": "^3.0.0",
        "make-dir": "^4.0.0",
        "supports-color": "^7.1.0"
      },
      "engines": {
        "node": ">=10"
      }
    },
    "node_modules/istanbul-lib-source-maps": {
      "version": "4.0.1",
      "resolved": "https://registry.npmjs.org/istanbul-lib-source-maps/-/istanbul-lib-source-maps-4.0.1.tgz",
      "integrity": "sha512-n3s8EwkdFIJCG3BPKBYvskgXGoy88ARzvegkitk60NxRdwltLOTaH7CUiMRXvwYorl0Q712iEjcWB+fK/MrWVw==",
      "dev": true,
      "license": "BSD-3-Clause",
      "dependencies": {
        "debug": "^4.1.1",
        "istanbul-lib-coverage": "^3.0.0",
        "source-map": "^0.6.1"
      },
      "engines": {
        "node": ">=10"
      }
    },
    "node_modules/istanbul-reports": {
      "version": "3.2.0",
      "resolved": "https://registry.npmjs.org/istanbul-reports/-/istanbul-reports-3.2.0.tgz",
      "integrity": "sha512-HGYWWS/ehqTV3xN10i23tkPkpH46MLCIMFNCaaKNavAXTF1RkqxawEPtnjnGZ6XKSInBKkiOA5BKS+aZiY3AvA==",
      "dev": true,
      "license": "BSD-3-Clause",
      "dependencies": {
        "html-escaper": "^2.0.0",
        "istanbul-lib-report": "^3.0.0"
      },
      "engines": {
        "node": ">=8"
      }
    },
    "node_modules/jest": {
      "version": "29.7.0",
      "resolved": "https://registry.npmjs.org/jest/-/jest-29.7.0.tgz",
      "integrity": "sha512-NIy3oAFp9shda19hy4HK0HRTWKtPJmGdnvywu01nOqNC2vZg+Z+fvJDxpMQA88eb2I9EcafcdjYgsDthnYTvGw==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "@jest/core": "^29.7.0",
        "@jest/types": "^29.6.3",
        "import-local": "^3.0.2",
        "jest-cli": "^29.7.0"
      },
      "bin": {
        "jest": "bin/jest.js"
      },
      "engines": {
        "node": "^14.15.0 || ^16.10.0 || >=18.0.0"
      },
      "peerDependencies": {
        "node-notifier": "^8.0.1 || ^9.0.0 || ^10.0.0"
      },
      "peerDependenciesMeta": {
        "node-notifier": {
          "optional": true
        }
      }
    },
    "node_modules/jest-changed-files": {
      "version": "29.7.0",
      "resolved": "https://registry.npmjs.org/jest-changed-files/-/jest-changed-files-29.7.0.tgz",
      "integrity": "sha512-fEArFiwf1BpQ+4bXSprcDc3/x4HSzL4al2tozwVpDFpsxALjLYdyiIK4e5Vz66GQJIbXJ82+35PtysofptNX2w==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "execa": "^5.0.0",
        "jest-util": "^29.7.0",
        "p-limit": "^3.1.0"
      },
      "engines": {
        "node": "^14.15.0 || ^16.10.0 || >=18.0.0"
      }
    },
    "node_modules/jest-circus": {
      "version": "29.7.0",
      "resolved": "https://registry.npmjs.org/jest-circus/-/jest-circus-29.7.0.tgz",
      "integrity": "sha512-3E1nCMgipcTkCocFwM90XXQab9bS+GMsjdpmPrlelaxwD93Ad8iVEjX/vvHPdLPnFf+L40u+5+iutRdA1N9myw==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "@jest/environment": "^29.7.0",
        "@jest/expect": "^29.7.0",
        "@jest/test-result": "^29.7.0",
        "@jest/types": "^29.6.3",
        "@types/node": "*",
        "chalk": "^4.0.0",
        "co": "^4.6.0",
        "dedent": "^1.0.0",
        "is-generator-fn": "^2.0.0",
        "jest-each": "^29.7.0",
        "jest-matcher-utils": "^29.7.0",
        "jest-message-util": "^29.7.0",
        "jest-runtime": "^29.7.0",
        "jest-snapshot": "^29.7.0",
        "jest-util": "^29.7.0",
        "p-limit": "^3.1.0",
        "pretty-format": "^29.7.0",
        "pure-rand": "^6.0.0",
        "slash": "^3.0.0",
        "stack-utils": "^2.0.3"
      },
      "engines": {
        "node": "^14.15.0 || ^16.10.0 || >=18.0.0"
      }
    },
    "node_modules/jest-cli": {
      "version": "29.7.0",
      "resolved": "https://registry.npmjs.org/jest-cli/-/jest-cli-29.7.0.tgz",
      "integrity": "sha512-OVVobw2IubN/GSYsxETi+gOe7Ka59EFMR/twOU3Jb2GnKKeMGJB5SGUUrEz3SFVmJASUdZUzy83sLNNQ2gZslg==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "@jest/core": "^29.7.0",
        "@jest/test-result": "^29.7.0",
        "@jest/types": "^29.6.3",
        "chalk": "^4.0.0",
        "create-jest": "^29.7.0",
        "exit": "^0.1.2",
        "import-local": "^3.0.2",
        "jest-config": "^29.7.0",
        "jest-util": "^29.7.0",
        "jest-validate": "^29.7.0",
        "yargs": "^17.3.1"
      },
      "bin": {
        "jest": "bin/jest.js"
      },
      "engines": {
        "node": "^14.15.0 || ^16.10.0 || >=18.0.0"
      },
      "peerDependencies": {
        "node-notifier": "^8.0.1 || ^9.0.0 || ^10.0.0"
      },
      "peerDependenciesMeta": {
        "node-notifier": {
          "optional": true
        }
      }
    },
    "node_modules/jest-config": {
      "version": "29.7.0",
      "resolved": "https://registry.npmjs.org/jest-config/-/jest-config-29.7.0.tgz",
      "integrity": "sha512-uXbpfeQ7R6TZBqI3/TxCU4q4ttk3u0PJeC+E0zbfSoSjq6bJ7buBPxzQPL0ifrkY4DNu4JUdk0ImlBUYi840eQ==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "@babel/core": "^7.11.6",
        "@jest/test-sequencer": "^29.7.0",
        "@jest/types": "^29.6.3",
        "babel-jest": "^29.7.0",
        "chalk": "^4.0.0",
        "ci-info": "^3.2.0",
        "deepmerge": "^4.2.2",
        "glob": "^7.1.3",
        "graceful-fs": "^4.2.9",
        "jest-circus": "^29.7.0",
        "jest-environment-node": "^29.7.0",
        "jest-get-type": "^29.6.3",
        "jest-regex-util": "^29.6.3",
        "jest-resolve": "^29.7.0",
        "jest-runner": "^29.7.0",
        "jest-util": "^29.7.0",
        "jest-validate": "^29.7.0",
        "micromatch": "^4.0.4",
        "parse-json": "^5.2.0",
        "pretty-format": "^29.7.0",
        "slash": "^3.0.0",
        "strip-json-comments": "^3.1.1"
      },
      "engines": {
        "node": "^14.15.0 || ^16.10.0 || >=18.0.0"
      },
      "peerDependencies": {
        "@types/node": "*",
        "ts-node": ">=9.0.0"
      },
      "peerDependenciesMeta": {
        "@types/node": {
          "optional": true
        },
        "ts-node": {
          "optional": true
        }
      }
    },
    "node_modules/jest-diff": {
      "version": "29.7.0",
      "resolved": "https://registry.npmjs.org/jest-diff/-/jest-diff-29.7.0.tgz",
      "integrity": "sha512-LMIgiIrhigmPrs03JHpxUh2yISK3vLFPkAodPeo0+BuF7wA2FoQbkEg1u8gBYBThncu7e1oEDUfIXVuTqLRUjw==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "chalk": "^4.0.0",
        "diff-sequences": "^29.6.3",
        "jest-get-type": "^29.6.3",
        "pretty-format": "^29.7.0"
      },
      "engines": {
        "node": "^14.15.0 || ^16.10.0 || >=18.0.0"
      }
    },
    "node_modules/jest-docblock": {
      "version": "29.7.0",
      "resolved": "https://registry.npmjs.org/jest-docblock/-/jest-docblock-29.7.0.tgz",
      "integrity": "sha512-q617Auw3A612guyaFgsbFeYpNP5t2aoUNLwBUbc/0kD1R4t9ixDbyFTHd1nok4epoVFpr7PmeWHrhvuV3XaJ4g==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "detect-newline": "^3.0.0"
      },
      "engines": {
        "node": "^14.15.0 || ^16.10.0 || >=18.0.0"
      }
    },
    "node_modules/jest-each": {
      "version": "29.7.0",
      "resolved": "https://registry.npmjs.org/jest-each/-/jest-each-29.7.0.tgz",
      "integrity": "sha512-gns+Er14+ZrEoC5fhOfYCY1LOHHr0TI+rQUHZS8Ttw2l7gl+80eHc/gFf2Ktkw0+SIACDTeWvpFcv3B04VembQ==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "@jest/types": "^29.6.3",
        "chalk": "^4.0.0",
        "jest-get-type": "^29.6.3",
        "jest-util": "^29.7.0",
        "pretty-format": "^29.7.0"
      },
      "engines": {
        "node": "^14.15.0 || ^16.10.0 || >=18.0.0"
      }
    },
    "node_modules/jest-environment-node": {
      "version": "29.7.0",
      "resolved": "https://registry.npmjs.org/jest-environment-node/-/jest-environment-node-29.7.0.tgz",
      "integrity": "sha512-DOSwCRqXirTOyheM+4d5YZOrWcdu0LNZ87ewUoywbcb2XR4wKgqiG8vNeYwhjFMbEkfju7wx2GYH0P2gevGvFw==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "@jest/environment": "^29.7.0",
        "@jest/fake-timers": "^29.7.0",
        "@jest/types": "^29.6.3",
        "@types/node": "*",
        "jest-mock": "^29.7.0",
        "jest-util": "^29.7.0"
      },
      "engines": {
        "node": "^14.15.0 || ^16.10.0 || >=18.0.0"
      }
    },
    "node_modules/jest-get-type": {
      "version": "29.6.3",
      "resolved": "https://registry.npmjs.org/jest-get-type/-/jest-get-type-29.6.3.tgz",
      "integrity": "sha512-zrteXnqYxfQh7l5FHyL38jL39di8H8rHoecLH3JNxH3BwOrBsNeabdap5e0I23lD4HHI8W5VFBZqG4Eaq5LNcw==",
      "dev": true,
      "license": "MIT",
      "engines": {
        "node": "^14.15.0 || ^16.10.0 || >=18.0.0"
      }
    },
    "node_modules/jest-haste-map": {
      "version": "29.7.0",
      "resolved": "https://registry.npmjs.org/jest-haste-map/-/jest-haste-map-29.7.0.tgz",
      "integrity": "sha512-fP8u2pyfqx0K1rGn1R9pyE0/KTn+G7PxktWidOBTqFPLYX0b9ksaMFkhK5vrS3DVun09pckLdlx90QthlW7AmA==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "@jest/types": "^29.6.3",
        "@types/graceful-fs": "^4.1.3",
        "@types/node": "*",
        "anymatch": "^3.0.3",
        "fb-watchman": "^2.0.0",
        "graceful-fs": "^4.2.9",
        "jest-regex-util": "^29.6.3",
        "jest-util": "^29.7.0",
        "jest-worker": "^29.7.0",
        "micromatch": "^4.0.4",
        "walker": "^1.0.8"
      },
      "engines": {
        "node": "^14.15.0 || ^16.10.0 || >=18.0.0"
      },
      "optionalDependencies": {
        "fsevents": "^2.3.2"
      }
    },
    "node_modules/jest-leak-detector": {
      "version": "29.7.0",
      "resolved": "https://registry.npmjs.org/jest-leak-detector/-/jest-leak-detector-29.7.0.tgz",
      "integrity": "sha512-kYA8IJcSYtST2BY9I+SMC32nDpBT3J2NvWJx8+JCuCdl/CR1I4EKUJROiP8XtCcxqgTTBGJNdbB1A8XRKbTetw==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "jest-get-type": "^29.6.3",
        "pretty-format": "^29.7.0"
      },
      "engines": {
        "node": "^14.15.0 || ^16.10.0 || >=18.0.0"
      }
    },
    "node_modules/jest-matcher-utils": {
      "version": "29.7.0",
      "resolved": "https://registry.npmjs.org/jest-matcher-utils/-/jest-matcher-utils-29.7.0.tgz",
      "integrity": "sha512-sBkD+Xi9DtcChsI3L3u0+N0opgPYnCRPtGcQYrgXmR+hmt/fYfWAL0xRXYU8eWOdfuLgBe0YCW3AFtnRLagq/g==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "chalk": "^4.0.0",
        "jest-diff": "^29.7.0",
        "jest-get-type": "^29.6.3",
        "pretty-format": "^29.7.0"
      },
      "engines": {
        "node": "^14.15.0 || ^16.10.0 || >=18.0.0"
      }
    },
    "node_modules/jest-message-util": {
      "version": "29.7.0",
      "resolved": "https://registry.npmjs.org/jest-message-util/-/jest-message-util-29.7.0.tgz",
      "integrity": "sha512-GBEV4GRADeP+qtB2+6u61stea8mGcOT4mCtrYISZwfu9/ISHFJ/5zOMXYbpBE9RsS5+Gb63DW4FgmnKJ79Kf6w==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "@babel/code-frame": "^7.12.13",
        "@jest/types": "^29.6.3",
        "@types/stack-utils": "^2.0.0",
        "chalk": "^4.0.0",
        "graceful-fs": "^4.2.9",
        "micromatch": "^4.0.4",
        "pretty-format": "^29.7.0",
        "slash": "^3.0.0",
        "stack-utils": "^2.0.3"
      },
      "engines": {
        "node": "^14.15.0 || ^16.10.0 || >=18.0.0"
      }
    },
    "node_modules/jest-mock": {
      "version": "29.7.0",
      "resolved": "https://registry.npmjs.org/jest-mock/-/jest-mock-29.7.0.tgz",
      "integrity": "sha512-ITOMZn+UkYS4ZFh83xYAOzWStloNzJFO2s8DWrE4lhtGD+AorgnbkiKERe4wQVBydIGPx059g6riW5Btp6Llnw==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "@jest/types": "^29.6.3",
        "@types/node": "*",
        "jest-util": "^29.7.0"
      },
      "engines": {
        "node": "^14.15.0 || ^16.10.0 || >=18.0.0"
      }
    },
    "node_modules/jest-pnp-resolver": {
      "version": "1.2.3",
      "resolved": "https://registry.npmjs.org/jest-pnp-resolver/-/jest-pnp-resolver-1.2.3.tgz",
      "integrity": "sha512-+3NpwQEnRoIBtx4fyhblQDPgJI0H1IEIkX7ShLUjPGA7TtUTvI1oiKi3SR4oBR0hQhQR80l4WAe5RrXBwWMA8w==",
      "dev": true,
      "license": "MIT",
      "engines": {
        "node": ">=6"
      },
      "peerDependencies": {
        "jest-resolve": "*"
      },
      "peerDependenciesMeta": {
        "jest-resolve": {
          "optional": true
        }
      }
    },
    "node_modules/jest-regex-util": {
      "version": "29.6.3",
      "resolved": "https://registry.npmjs.org/jest-regex-util/-/jest-regex-util-29.6.3.tgz",
      "integrity": "sha512-KJJBsRCyyLNWCNBOvZyRDnAIfUiRJ8v+hOBQYGn8gDyF3UegwiP4gwRR3/SDa42g1YbVycTidUF3rKjyLFDWbg==",
      "dev": true,
      "license": "MIT",
      "engines": {
        "node": "^14.15.0 || ^16.10.0 || >=18.0.0"
      }
    },
    "node_modules/jest-resolve": {
      "version": "29.7.0",
      "resolved": "https://registry.npmjs.org/jest-resolve/-/jest-resolve-29.7.0.tgz",
      "integrity": "sha512-IOVhZSrg+UvVAshDSDtHyFCCBUl/Q3AAJv8iZ6ZjnZ74xzvwuzLXid9IIIPgTnY62SJjfuupMKZsZQRsCvxEgA==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "chalk": "^4.0.0",
        "graceful-fs": "^4.2.9",
        "jest-haste-map": "^29.7.0",
        "jest-pnp-resolver": "^1.2.2",
        "jest-util": "^29.7.0",
        "jest-validate": "^29.7.0",
        "resolve": "^1.20.0",
        "resolve.exports": "^2.0.0",
        "slash": "^3.0.0"
      },
      "engines": {
        "node": "^14.15.0 || ^16.10.0 || >=18.0.0"
      }
    },
    "node_modules/jest-resolve-dependencies": {
      "version": "29.7.0",
      "resolved": "https://registry.npmjs.org/jest-resolve-dependencies/-/jest-resolve-dependencies-29.7.0.tgz",
      "integrity": "sha512-un0zD/6qxJ+S0et7WxeI3H5XSe9lTBBR7bOHCHXkKR6luG5mwDDlIzVQ0V5cZCuoTgEdcdwzTghYkTWfubi+nA==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "jest-regex-util": "^29.6.3",
        "jest-snapshot": "^29.7.0"
      },
      "engines": {
        "node": "^14.15.0 || ^16.10.0 || >=18.0.0"
      }
    },
    "node_modules/jest-runner": {
      "version": "29.7.0",
      "resolved": "https://registry.npmjs.org/jest-runner/-/jest-runner-29.7.0.tgz",
      "integrity": "sha512-fsc4N6cPCAahybGBfTRcq5wFR6fpLznMg47sY5aDpsoejOcVYFb07AHuSnR0liMcPTgBsA3ZJL6kFOjPdoNipQ==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "@jest/console": "^29.7.0",
        "@jest/environment": "^29.7.0",
        "@jest/test-result": "^29.7.0",
        "@jest/transform": "^29.7.0",
        "@jest/types": "^29.6.3",
        "@types/node": "*",
        "chalk": "^4.0.0",
        "emittery": "^0.13.1",
        "graceful-fs": "^4.2.9",
        "jest-docblock": "^29.7.0",
        "jest-environment-node": "^29.7.0",
        "jest-haste-map": "^29.7.0",
        "jest-leak-detector": "^29.7.0",
        "jest-message-util": "^29.7.0",
        "jest-resolve": "^29.7.0",
        "jest-runtime": "^29.7.0",
        "jest-util": "^29.7.0",
        "jest-watcher": "^29.7.0",
        "jest-worker": "^29.7.0",
        "p-limit": "^3.1.0",
        "source-map-support": "0.5.13"
      },
      "engines": {
        "node": "^14.15.0 || ^16.10.0 || >=18.0.0"
      }
    },
    "node_modules/jest-runtime": {
      "version": "29.7.0",
      "resolved": "https://registry.npmjs.org/jest-runtime/-/jest-runtime-29.7.0.tgz",
      "integrity": "sha512-gUnLjgwdGqW7B4LvOIkbKs9WGbn+QLqRQQ9juC6HndeDiezIwhDP+mhMwHWCEcfQ5RUXa6OPnFF8BJh5xegwwQ==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "@jest/environment": "^29.7.0",
        "@jest/fake-timers": "^29.7.0",
        "@jest/globals": "^29.7.0",
        "@jest/source-map": "^29.6.3",
        "@jest/test-result": "^29.7.0",
        "@jest/transform": "^29.7.0",
        "@jest/types": "^29.6.3",
        "@types/node": "*",
        "chalk": "^4.0.0",
        "cjs-module-lexer": "^1.0.0",
        "collect-v8-coverage": "^1.0.0",
        "glob": "^7.1.3",
        "graceful-fs": "^4.2.9",
        "jest-haste-map": "^29.7.0",
        "jest-message-util": "^29.7.0",
        "jest-mock": "^29.7.0",
        "jest-regex-util": "^29.6.3",
        "jest-resolve": "^29.7.0",
        "jest-snapshot": "^29.7.0",
        "jest-util": "^29.7.0",
        "slash": "^3.0.0",
        "strip-bom": "^4.0.0"
      },
      "engines": {
        "node": "^14.15.0 || ^16.10.0 || >=18.0.0"
      }
    },
    "node_modules/jest-snapshot": {
      "version": "29.7.0",
      "resolved": "https://registry.npmjs.org/jest-snapshot/-/jest-snapshot-29.7.0.tgz",
      "integrity": "sha512-Rm0BMWtxBcioHr1/OX5YCP8Uov4riHvKPknOGs804Zg9JGZgmIBkbtlxJC/7Z4msKYVbIJtfU+tKb8xlYNfdkw==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "@babel/core": "^7.11.6",
        "@babel/generator": "^7.7.2",
        "@babel/plugin-syntax-jsx": "^7.7.2",
        "@babel/plugin-syntax-typescript": "^7.7.2",
        "@babel/types": "^7.3.3",
        "@jest/expect-utils": "^29.7.0",
        "@jest/transform": "^29.7.0",
        "@jest/types": "^29.6.3",
        "babel-preset-current-node-syntax": "^1.0.0",
        "chalk": "^4.0.0",
        "expect": "^29.7.0",
        "graceful-fs": "^4.2.9",
        "jest-diff": "^29.7.0",
        "jest-get-type": "^29.6.3",
        "jest-matcher-utils": "^29.7.0",
        "jest-message-util": "^29.7.0",
        "jest-util": "^29.7.0",
        "natural-compare": "^1.4.0",
        "pretty-format": "^29.7.0",
        "semver": "^7.5.3"
      },
      "engines": {
        "node": "^14.15.0 || ^16.10.0 || >=18.0.0"
      }
    },
    "node_modules/jest-snapshot/node_modules/semver": {
      "version": "7.7.2",
      "resolved": "https://registry.npmjs.org/semver/-/semver-7.7.2.tgz",
      "integrity": "sha512-RF0Fw+rO5AMf9MAyaRXI4AV0Ulj5lMHqVxxdSgiVbixSCXoEmmX/jk0CuJw4+3SqroYO9VoUh+HcuJivvtJemA==",
      "dev": true,
      "license": "ISC",
      "bin": {
        "semver": "bin/semver.js"
      },
      "engines": {
        "node": ">=10"
      }
    },
    "node_modules/jest-util": {
      "version": "29.7.0",
      "resolved": "https://registry.npmjs.org/jest-util/-/jest-util-29.7.0.tgz",
      "integrity": "sha512-z6EbKajIpqGKU56y5KBUgy1dt1ihhQJgWzUlZHArA/+X2ad7Cb5iF+AK1EWVL/Bo7Rz9uurpqw6SiBCefUbCGA==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "@jest/types": "^29.6.3",
        "@types/node": "*",
        "chalk": "^4.0.0",
        "ci-info": "^3.2.0",
        "graceful-fs": "^4.2.9",
        "picomatch": "^2.2.3"
      },
      "engines": {
        "node": "^14.15.0 || ^16.10.0 || >=18.0.0"
      }
    },
    "node_modules/jest-validate": {
      "version": "29.7.0",
      "resolved": "https://registry.npmjs.org/jest-validate/-/jest-validate-29.7.0.tgz",
      "integrity": "sha512-ZB7wHqaRGVw/9hST/OuFUReG7M8vKeq0/J2egIGLdvjHCmYqGARhzXmtgi+gVeZ5uXFF219aOc3Ls2yLg27tkw==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "@jest/types": "^29.6.3",
        "camelcase": "^6.2.0",
        "chalk": "^4.0.0",
        "jest-get-type": "^29.6.3",
        "leven": "^3.1.0",
        "pretty-format": "^29.7.0"
      },
      "engines": {
        "node": "^14.15.0 || ^16.10.0 || >=18.0.0"
      }
    },
    "node_modules/jest-validate/node_modules/camelcase": {
      "version": "6.3.0",
      "resolved": "https://registry.npmjs.org/camelcase/-/camelcase-6.3.0.tgz",
      "integrity": "sha512-Gmy6FhYlCY7uOElZUSbxo2UCDH8owEk996gkbrpsgGtrJLM3J7jGxl9Ic7Qwwj4ivOE5AWZWRMecDdF7hqGjFA==",
      "dev": true,
      "license": "MIT",
      "engines": {
        "node": ">=10"
      },
      "funding": {
        "url": "https://github.com/sponsors/sindresorhus"
      }
    },
    "node_modules/jest-watcher": {
      "version": "29.7.0",
      "resolved": "https://registry.npmjs.org/jest-watcher/-/jest-watcher-29.7.0.tgz",
      "integrity": "sha512-49Fg7WXkU3Vl2h6LbLtMQ/HyB6rXSIX7SqvBLQmssRBGN9I0PNvPmAmCWSOY6SOvrjhI/F7/bGAv9RtnsPA03g==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "@jest/test-result": "^29.7.0",
        "@jest/types": "^29.6.3",
        "@types/node": "*",
        "ansi-escapes": "^4.2.1",
        "chalk": "^4.0.0",
        "emittery": "^0.13.1",
        "jest-util": "^29.7.0",
        "string-length": "^4.0.1"
      },
      "engines": {
        "node": "^14.15.0 || ^16.10.0 || >=18.0.0"
      }
    },
    "node_modules/jest-worker": {
      "version": "29.7.0",
      "resolved": "https://registry.npmjs.org/jest-worker/-/jest-worker-29.7.0.tgz",
      "integrity": "sha512-eIz2msL/EzL9UFTFFx7jBTkeZfku0yUAyZZZmJ93H2TYEiroIx2PQjEXcwYtYl8zXCxb+PAmA2hLIt/6ZEkPHw==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "@types/node": "*",
        "jest-util": "^29.7.0",
        "merge-stream": "^2.0.0",
        "supports-color": "^8.0.0"
      },
      "engines": {
        "node": "^14.15.0 || ^16.10.0 || >=18.0.0"
      }
    },
    "node_modules/jest-worker/node_modules/supports-color": {
      "version": "8.1.1",
      "resolved": "https://registry.npmjs.org/supports-color/-/supports-color-8.1.1.tgz",
      "integrity": "sha512-MpUEN2OodtUzxvKQl72cUF7RQ5EiHsGvSsVG0ia9c5RbWGL2CI4C7EpPS8UTBIplnlzZiNuV56w+FuNxy3ty2Q==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "has-flag": "^4.0.0"
      },
      "engines": {
        "node": ">=10"
      },
      "funding": {
        "url": "https://github.com/chalk/supports-color?sponsor=1"
      }
    },
    "node_modules/js-tokens": {
      "version": "4.0.0",
      "resolved": "https://registry.npmjs.org/js-tokens/-/js-tokens-4.0.0.tgz",
      "integrity": "sha512-RdJUflcE3cUzKiMqQgsCu06FPu9UdIJO0beYbPhHN4k6apgJtifcoCtT9bcxOpYBtpD2kCM6Sbzg4CausW/PKQ==",
      "dev": true,
      "license": "MIT"
    },
    "node_modules/js-yaml": {
      "version": "3.14.1",
      "resolved": "https://registry.npmjs.org/js-yaml/-/js-yaml-3.14.1.tgz",
      "integrity": "sha512-okMH7OXXJ7YrN9Ok3/SXrnu4iX9yOk+25nqX4imS2npuvTYDmo/QEZoqwZkYaIDk3jVvBOTOIEgEhaLOynBS9g==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "argparse": "^1.0.7",
        "esprima": "^4.0.0"
      },
      "bin": {
        "js-yaml": "bin/js-yaml.js"
      }
    },
    "node_modules/jsesc": {
      "version": "3.1.0",
      "resolved": "https://registry.npmjs.org/jsesc/-/jsesc-3.1.0.tgz",
      "integrity": "sha512-/sM3dO2FOzXjKQhJuo0Q173wf2KOo8t4I8vHy6lF9poUp7bKT0/NHE8fPX23PwfhnykfqnC2xRxOnVw5XuGIaA==",
      "dev": true,
      "license": "MIT",
      "bin": {
        "jsesc": "bin/jsesc"
      },
      "engines": {
        "node": ">=6"
      }
    },
    "node_modules/json-parse-even-better-errors": {
      "version": "2.3.1",
      "resolved": "https://registry.npmjs.org/json-parse-even-better-errors/-/json-parse-even-better-errors-2.3.1.tgz",
      "integrity": "sha512-xyFwyhro/JEof6Ghe2iz2NcXoj2sloNsWr/XsERDK/oiPCfaNhl5ONfp+jQdAZRQQ0IJWNzH9zIZF7li91kh2w==",
      "dev": true,
      "license": "MIT"
    },
    "node_modules/json5": {
      "version": "2.2.3",
      "resolved": "https://registry.npmjs.org/json5/-/json5-2.2.3.tgz",
      "integrity": "sha512-XmOWe7eyHYH14cLdVPoyg+GOH3rYX++KpzrylJwSW98t3Nk+U8XOl8FWKOgwtzdb8lXGf6zYwDUzeHMWfxasyg==",
      "dev": true,
      "license": "MIT",
      "bin": {
        "json5": "lib/cli.js"
      },
      "engines": {
        "node": ">=6"
      }
    },
    "node_modules/kleur": {
      "version": "3.0.3",
      "resolved": "https://registry.npmjs.org/kleur/-/kleur-3.0.3.tgz",
      "integrity": "sha512-eTIzlVOSUR+JxdDFepEYcBMtZ9Qqdef+rnzWdRZuMbOywu5tO2w2N7rqjoANZ5k9vywhL6Br1VRjUIgTQx4E8w==",
      "dev": true,
      "license": "MIT",
      "engines": {
        "node": ">=6"
      }
    },
    "node_modules/leven": {
      "version": "3.1.0",
      "resolved": "https://registry.npmjs.org/leven/-/leven-3.1.0.tgz",
      "integrity": "sha512-qsda+H8jTaUaN/x5vzW2rzc+8Rw4TAQ/4KjB46IwK5VH+IlVeeeje/EoZRpiXvIqjFgK84QffqPztGI3VBLG1A==",
      "dev": true,
      "license": "MIT",
      "engines": {
        "node": ">=6"
      }
    },
    "node_modules/lines-and-columns": {
      "version": "1.2.4",
      "resolved": "https://registry.npmjs.org/lines-and-columns/-/lines-and-columns-1.2.4.tgz",
      "integrity": "sha512-7ylylesZQ/PV29jhEDl3Ufjo6ZX7gCqJr5F7PKrqc93v7fzSymt1BpwEU8nAUXs8qzzvqhbjhK5QZg6Mt/HkBg==",
      "dev": true,
      "license": "MIT"
    },
    "node_modules/locate-path": {
      "version": "5.0.0",
      "resolved": "https://registry.npmjs.org/locate-path/-/locate-path-5.0.0.tgz",
      "integrity": "sha512-t7hw9pI+WvuwNJXwk5zVHpyhIqzg2qTlklJOf0mVxGSbe3Fp2VieZcduNYjaLDoy6p9uGpQEGWG87WpMKlNq8g==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "p-locate": "^4.1.0"
      },
      "engines": {
        "node": ">=8"
      }
    },
    "node_modules/lodash": {
      "version": "4.17.21",
      "resolved": "https://registry.npmjs.org/lodash/-/lodash-4.17.21.tgz",
      "integrity": "sha512-v2kDEe57lecTulaDIuNTPy3Ry4gLGJ6Z1O3vE1krgXZNrsQ+LFTGHVxVjcXPs17LhbZVGedAJv8XZ1tvj5FvSg==",
      "license": "MIT"
    },
    "node_modules/lodash.snakecase": {
      "version": "4.1.1",
      "resolved": "https://registry.npmjs.org/lodash.snakecase/-/lodash.snakecase-4.1.1.tgz",
      "integrity": "sha512-QZ1d4xoBHYUeuouhEq3lk3Uq7ldgyFXGBhg04+oRLnIz8o9T65Eh+8YdroUwn846zchkA9yDsDl5CVVaV2nqYw==",
      "license": "MIT"
    },
    "node_modules/lru-cache": {
      "version": "5.1.1",
      "resolved": "https://registry.npmjs.org/lru-cache/-/lru-cache-5.1.1.tgz",
      "integrity": "sha512-KpNARQA3Iwv+jTA0utUVVbrh+Jlrr1Fv0e56GGzAFOXN7dk/FviaDW8LHmK52DlcH4WP2n6gI8vN1aesBFgo9w==",
      "dev": true,
      "license": "ISC",
      "dependencies": {
        "yallist": "^3.0.2"
      }
    },
    "node_modules/magic-bytes.js": {
      "version": "1.12.1",
      "resolved": "https://registry.npmjs.org/magic-bytes.js/-/magic-bytes.js-1.12.1.tgz",
      "integrity": "sha512-ThQLOhN86ZkJ7qemtVRGYM+gRgR8GEXNli9H/PMvpnZsE44Xfh3wx9kGJaldg314v85m+bFW6WBMaVHJc/c3zA==",
      "license": "MIT"
    },
    "node_modules/make-dir": {
      "version": "4.0.0",
      "resolved": "https://registry.npmjs.org/make-dir/-/make-dir-4.0.0.tgz",
      "integrity": "sha512-hXdUTZYIVOt1Ex//jAQi+wTZZpUpwBj/0QsOzqegb3rGMMeJiSEu5xLHnYfBrRV4RH2+OCSOO95Is/7x1WJ4bw==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "semver": "^7.5.3"
      },
      "engines": {
        "node": ">=10"
      },
      "funding": {
        "url": "https://github.com/sponsors/sindresorhus"
      }
    },
    "node_modules/make-dir/node_modules/semver": {
      "version": "7.7.2",
      "resolved": "https://registry.npmjs.org/semver/-/semver-7.7.2.tgz",
      "integrity": "sha512-RF0Fw+rO5AMf9MAyaRXI4AV0Ulj5lMHqVxxdSgiVbixSCXoEmmX/jk0CuJw4+3SqroYO9VoUh+HcuJivvtJemA==",
      "dev": true,
      "license": "ISC",
      "bin": {
        "semver": "bin/semver.js"
      },
      "engines": {
        "node": ">=10"
      }
    },
    "node_modules/makeerror": {
      "version": "1.0.12",
      "resolved": "https://registry.npmjs.org/makeerror/-/makeerror-1.0.12.tgz",
      "integrity": "sha512-JmqCvUhmt43madlpFzG4BQzG2Z3m6tvQDNKdClZnO3VbIudJYmxsT0FNJMeiB2+JTSlTQTSbU8QdesVmwJcmLg==",
      "dev": true,
      "license": "BSD-3-Clause",
      "dependencies": {
        "tmpl": "1.0.5"
      }
    },
    "node_modules/merge-stream": {
      "version": "2.0.0",
      "resolved": "https://registry.npmjs.org/merge-stream/-/merge-stream-2.0.0.tgz",
      "integrity": "sha512-abv/qOcuPfk3URPfDzmZU1LKmuw8kT+0nIHvKrKgFrwifol/doWcdA4ZqsWQ8ENrFKkd67Mfpo/LovbIUsbt3w==",
      "dev": true,
      "license": "MIT"
    },
    "node_modules/micromatch": {
      "version": "4.0.8",
      "resolved": "https://registry.npmjs.org/micromatch/-/micromatch-4.0.8.tgz",
      "integrity": "sha512-PXwfBhYu0hBCPw8Dn0E+WDYb7af3dSLVWKi3HGv84IdF4TyFoC0ysxFd0Goxw7nSv4T/PzEJQxsYsEiFCKo2BA==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "braces": "^3.0.3",
        "picomatch": "^2.3.1"
      },
      "engines": {
        "node": ">=8.6"
      }
    },
    "node_modules/mimic-fn": {
      "version": "2.1.0",
      "resolved": "https://registry.npmjs.org/mimic-fn/-/mimic-fn-2.1.0.tgz",
      "integrity": "sha512-OqbOk5oEQeAZ8WXWydlu9HJjz9WVdEIvamMCcXmuqUYjTknH/sqsWvhQ3vgwKFRR1HpjvNBKQ37nbJgYzGqGcg==",
      "dev": true,
      "license": "MIT",
      "engines": {
        "node": ">=6"
      }
    },
    "node_modules/minimatch": {
      "version": "3.1.2",
      "resolved": "https://registry.npmjs.org/minimatch/-/minimatch-3.1.2.tgz",
      "integrity": "sha512-J7p63hRiAjw1NDEww1W7i37+ByIrOWO5XQQAzZ3VOcL0PNybwpfmV/N05zFAzwQ9USyEcX6t3UO+K5aqBQOIHw==",
      "dev": true,
      "license": "ISC",
      "dependencies": {
        "brace-expansion": "^1.1.7"
      },
      "engines": {
        "node": "*"
      }
    },
    "node_modules/ms": {
      "version": "2.1.3",
      "resolved": "https://registry.npmjs.org/ms/-/ms-2.1.3.tgz",
      "integrity": "sha512-6FlzubTLZG3J2a/NVCAleEhjzq5oxgHyaCU9yYXvcLsvoVaHJq/s5xXI6/XXP6tz7R9xAOtHnSO/tXtF3WRTlA==",
      "license": "MIT"
    },
    "node_modules/natural-compare": {
      "version": "1.4.0",
      "resolved": "https://registry.npmjs.org/natural-compare/-/natural-compare-1.4.0.tgz",
      "integrity": "sha512-OWND8ei3VtNC9h7V60qff3SVobHr996CTwgxubgyQYEpg290h9J0buyECNNJexkFm5sOajh5G116RYA1c8ZMSw==",
      "dev": true,
      "license": "MIT"
    },
    "node_modules/node-int64": {
      "version": "0.4.0",
      "resolved": "https://registry.npmjs.org/node-int64/-/node-int64-0.4.0.tgz",
      "integrity": "sha512-O5lz91xSOeoXP6DulyHfllpq+Eg00MWitZIbtPfoSEvqIHdl5gfcY6hYzDWnj0qD5tz52PI08u9qUvSVeUBeHw==",
      "dev": true,
      "license": "MIT"
    },
    "node_modules/node-releases": {
      "version": "2.0.20",
      "resolved": "https://registry.npmjs.org/node-releases/-/node-releases-2.0.20.tgz",
      "integrity": "sha512-7gK6zSXEH6neM212JgfYFXe+GmZQM+fia5SsusuBIUgnPheLFBmIPhtFoAQRj8/7wASYQnbDlHPVwY0BefoFgA==",
      "dev": true,
      "license": "MIT"
    },
    "node_modules/normalize-path": {
      "version": "3.0.0",
      "resolved": "https://registry.npmjs.org/normalize-path/-/normalize-path-3.0.0.tgz",
      "integrity": "sha512-6eZs5Ls3WtCisHWp9S2GUy8dqkpGi4BVSz3GaqiE6ezub0512ESztXUwUB6C6IKbQkY2Pnb/mD4WYojCRwcwLA==",
      "dev": true,
      "license": "MIT",
      "engines": {
        "node": ">=0.10.0"
      }
    },
    "node_modules/npm-run-path": {
      "version": "4.0.1",
      "resolved": "https://registry.npmjs.org/npm-run-path/-/npm-run-path-4.0.1.tgz",
      "integrity": "sha512-S48WzZW777zhNIrn7gxOlISNAqi9ZC/uQFnRdbeIHhZhCA6UqpkOT8T1G7BvfdgP4Er8gF4sUbaS0i7QvIfCWw==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "path-key": "^3.0.0"
      },
      "engines": {
        "node": ">=8"
      }
    },
    "node_modules/once": {
      "version": "1.4.0",
      "resolved": "https://registry.npmjs.org/once/-/once-1.4.0.tgz",
      "integrity": "sha512-lNaJgI+2Q5URQBkccEKHTQOPaXdUxnZZElQTZY0MFUAuaEqe1E+Nyvgdz/aIyNi6Z9MzO5dv1H8n58/GELp3+w==",
      "dev": true,
      "license": "ISC",
      "dependencies": {
        "wrappy": "1"
      }
    },
    "node_modules/onetime": {
      "version": "5.1.2",
      "resolved": "https://registry.npmjs.org/onetime/-/onetime-5.1.2.tgz",
      "integrity": "sha512-kbpaSSGJTWdAY5KPVeMOKXSrPtr8C8C7wodJbcsd51jRnmD+GZu8Y0VoU6Dm5Z4vWr0Ig/1NKuWRKf7j5aaYSg==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "mimic-fn": "^2.1.0"
      },
      "engines": {
        "node": ">=6"
      },
      "funding": {
        "url": "https://github.com/sponsors/sindresorhus"
      }
    },
    "node_modules/p-limit": {
      "version": "3.1.0",
      "resolved": "https://registry.npmjs.org/p-limit/-/p-limit-3.1.0.tgz",
      "integrity": "sha512-TYOanM3wGwNGsZN2cVTYPArw454xnXj5qmWF1bEoAc4+cU/ol7GVh7odevjp1FNHduHc3KZMcFduxU5Xc6uJRQ==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "yocto-queue": "^0.1.0"
      },
      "engines": {
        "node": ">=10"
      },
      "funding": {
        "url": "https://github.com/sponsors/sindresorhus"
      }
    },
    "node_modules/p-locate": {
      "version": "4.1.0",
      "resolved": "https://registry.npmjs.org/p-locate/-/p-locate-4.1.0.tgz",
      "integrity": "sha512-R79ZZ/0wAxKGu3oYMlz8jy/kbhsNrS7SKZ7PxEHBgJ5+F2mtFW2fK2cOtBh1cHYkQsbzFV7I+EoRKe6Yt0oK7A==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "p-limit": "^2.2.0"
      },
      "engines": {
        "node": ">=8"
      }
    },
    "node_modules/p-locate/node_modules/p-limit": {
      "version": "2.3.0",
      "resolved": "https://registry.npmjs.org/p-limit/-/p-limit-2.3.0.tgz",
      "integrity": "sha512-//88mFWSJx8lxCzwdAABTJL2MyWB12+eIY7MDL2SqLmAkeKU9qxRvWuSyTjm3FUmpBEMuFfckAIqEaVGUDxb6w==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "p-try": "^2.0.0"
      },
      "engines": {
        "node": ">=6"
      },
      "funding": {
        "url": "https://github.com/sponsors/sindresorhus"
      }
    },
    "node_modules/p-try": {
      "version": "2.2.0",
      "resolved": "https://registry.npmjs.org/p-try/-/p-try-2.2.0.tgz",
      "integrity": "sha512-R4nPAVTAU0B9D35/Gk3uJf/7XYbQcyohSKdvAxIRSNghFl4e71hVoGnBNQz9cWaXxO2I10KTC+3jMdvvoKw6dQ==",
      "dev": true,
      "license": "MIT",
      "engines": {
        "node": ">=6"
      }
    },
    "node_modules/parse-json": {
      "version": "5.2.0",
      "resolved": "https://registry.npmjs.org/parse-json/-/parse-json-5.2.0.tgz",
      "integrity": "sha512-ayCKvm/phCGxOkYRSCM82iDwct8/EonSEgCSxWxD7ve6jHggsFl4fZVQBPRNgQoKiuV/odhFrGzQXZwbifC8Rg==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "@babel/code-frame": "^7.0.0",
        "error-ex": "^1.3.1",
        "json-parse-even-better-errors": "^2.3.0",
        "lines-and-columns": "^1.1.6"
      },
      "engines": {
        "node": ">=8"
      },
      "funding": {
        "url": "https://github.com/sponsors/sindresorhus"
      }
    },
    "node_modules/path-exists": {
      "version": "4.0.0",
      "resolved": "https://registry.npmjs.org/path-exists/-/path-exists-4.0.0.tgz",
      "integrity": "sha512-ak9Qy5Q7jYb2Wwcey5Fpvg2KoAc/ZIhLSLOSBmRmygPsGwkVVt0fZa0qrtMz+m6tJTAHfZQ8FnmB4MG4LWy7/w==",
      "dev": true,
      "license": "MIT",
      "engines": {
        "node": ">=8"
      }
    },
    "node_modules/path-is-absolute": {
      "version": "1.0.1",
      "resolved": "https://registry.npmjs.org/path-is-absolute/-/path-is-absolute-1.0.1.tgz",
      "integrity": "sha512-AVbw3UJ2e9bq64vSaS9Am0fje1Pa8pbGqTTsmXfaIiMpnr5DlDhfJOuLj9Sf95ZPVDAUerDfEk88MPmPe7UCQg==",
      "dev": true,
      "license": "MIT",
      "engines": {
        "node": ">=0.10.0"
      }
    },
    "node_modules/path-key": {
      "version": "3.1.1",
      "resolved": "https://registry.npmjs.org/path-key/-/path-key-3.1.1.tgz",
      "integrity": "sha512-ojmeN0qd+y0jszEtoY48r0Peq5dwMEkIlCOu6Q5f41lfkswXuKtYrhgoTpLnyIcHm24Uhqx+5Tqm2InSwLhE6Q==",
      "dev": true,
      "license": "MIT",
      "engines": {
        "node": ">=8"
      }
    },
    "node_modules/path-parse": {
      "version": "1.0.7",
      "resolved": "https://registry.npmjs.org/path-parse/-/path-parse-1.0.7.tgz",
      "integrity": "sha512-LDJzPVEEEPR+y48z93A0Ed0yXb8pAByGWo/k5YYdYgpY2/2EsOsksJrq7lOHxryrVOn1ejG6oAp8ahvOIQD8sw==",
      "dev": true,
      "license": "MIT"
    },
    "node_modules/picocolors": {
      "version": "1.1.1",
      "resolved": "https://registry.npmjs.org/picocolors/-/picocolors-1.1.1.tgz",
      "integrity": "sha512-xceH2snhtb5M9liqDsmEw56le376mTZkEX/jEb/RxNFyegNul7eNslCXP9FDj/Lcu0X8KEyMceP2ntpaHrDEVA==",
      "dev": true,
      "license": "ISC"
    },
    "node_modules/picomatch": {
      "version": "2.3.1",
      "resolved": "https://registry.npmjs.org/picomatch/-/picomatch-2.3.1.tgz",
      "integrity": "sha512-JU3teHTNjmE2VCGFzuY8EXzCDVwEqB2a8fsIvwaStHhAWJEeVd1o1QD80CU6+ZdEXXSLbSsuLwJjkCBWqRQUVA==",
      "dev": true,
      "license": "MIT",
      "engines": {
        "node": ">=8.6"
      },
      "funding": {
        "url": "https://github.com/sponsors/jonschlinkert"
      }
    },
    "node_modules/pirates": {
      "version": "4.0.7",
      "resolved": "https://registry.npmjs.org/pirates/-/pirates-4.0.7.tgz",
      "integrity": "sha512-TfySrs/5nm8fQJDcBDuUng3VOUKsd7S+zqvbOTiGXHfxX4wK31ard+hoNuvkicM/2YFzlpDgABOevKSsB4G/FA==",
      "dev": true,
      "license": "MIT",
      "engines": {
        "node": ">= 6"
      }
    },
    "node_modules/pkg-dir": {
      "version": "4.2.0",
      "resolved": "https://registry.npmjs.org/pkg-dir/-/pkg-dir-4.2.0.tgz",
      "integrity": "sha512-HRDzbaKjC+AOWVXxAU/x54COGeIv9eb+6CkDSQoNTt4XyWoIJvuPsXizxu/Fr23EiekbtZwmh1IcIG/l/a10GQ==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "find-up": "^4.0.0"
      },
      "engines": {
        "node": ">=8"
      }
    },
    "node_modules/pretty-format": {
      "version": "29.7.0",
      "resolved": "https://registry.npmjs.org/pretty-format/-/pretty-format-29.7.0.tgz",
      "integrity": "sha512-Pdlw/oPxN+aXdmM9R00JVC9WVFoCLTKJvDVLgmJ+qAffBMxsV85l/Lu7sNx4zSzPyoL2euImuEwHhOXdEgNFZQ==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "@jest/schemas": "^29.6.3",
        "ansi-styles": "^5.0.0",
        "react-is": "^18.0.0"
      },
      "engines": {
        "node": "^14.15.0 || ^16.10.0 || >=18.0.0"
      }
    },
    "node_modules/pretty-format/node_modules/ansi-styles": {
      "version": "5.2.0",
      "resolved": "https://registry.npmjs.org/ansi-styles/-/ansi-styles-5.2.0.tgz",
      "integrity": "sha512-Cxwpt2SfTzTtXcfOlzGEee8O+c+MmUgGrNiBcXnuWxuFJHe6a5Hz7qwhwe5OgaSYI0IJvkLqWX1ASG+cJOkEiA==",
      "dev": true,
      "license": "MIT",
      "engines": {
        "node": ">=10"
      },
      "funding": {
        "url": "https://github.com/chalk/ansi-styles?sponsor=1"
      }
    },
    "node_modules/prompts": {
      "version": "2.4.2",
      "resolved": "https://registry.npmjs.org/prompts/-/prompts-2.4.2.tgz",
      "integrity": "sha512-NxNv/kLguCA7p3jE8oL2aEBsrJWgAakBpgmgK6lpPWV+WuOmY6r2/zbAVnP+T8bQlA0nzHXSJSJW0Hq7ylaD2Q==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "kleur": "^3.0.3",
        "sisteransi": "^1.0.5"
      },
      "engines": {
        "node": ">= 6"
      }
    },
    "node_modules/pure-rand": {
      "version": "6.1.0",
      "resolved": "https://registry.npmjs.org/pure-rand/-/pure-rand-6.1.0.tgz",
      "integrity": "sha512-bVWawvoZoBYpp6yIoQtQXHZjmz35RSVHnUOTefl8Vcjr8snTPY1wnpSPMWekcFwbxI6gtmT7rSYPFvz71ldiOA==",
      "dev": true,
      "funding": [
        {
          "type": "individual",
          "url": "https://github.com/sponsors/dubzzz"
        },
        {
          "type": "opencollective",
          "url": "https://opencollective.com/fast-check"
        }
      ],
      "license": "MIT"
    },
    "node_modules/react-is": {
      "version": "18.3.1",
      "resolved": "https://registry.npmjs.org/react-is/-/react-is-18.3.1.tgz",
      "integrity": "sha512-/LLMVyas0ljjAtoYiPqYiL8VWXzUUdThrmU5+n20DZv+a+ClRoevUzw5JxU+Ieh5/c87ytoTBV9G1FiKfNJdmg==",
      "dev": true,
      "license": "MIT"
    },
    "node_modules/require-directory": {
      "version": "2.1.1",
      "resolved": "https://registry.npmjs.org/require-directory/-/require-directory-2.1.1.tgz",
      "integrity": "sha512-fGxEI7+wsG9xrvdjsrlmL22OMTTiHRwAMroiEeMgq8gzoLC/PQr7RsRDSTLUg/bZAZtF+TVIkHc6/4RIKrui+Q==",
      "dev": true,
      "license": "MIT",
      "engines": {
        "node": ">=0.10.0"
      }
    },
    "node_modules/resolve": {
      "version": "1.22.10",
      "resolved": "https://registry.npmjs.org/resolve/-/resolve-1.22.10.tgz",
      "integrity": "sha512-NPRy+/ncIMeDlTAsuqwKIiferiawhefFJtkNSW0qZJEqMEb+qBt/77B/jGeeek+F0uOeN05CDa6HXbbIgtVX4w==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "is-core-module": "^2.16.0",
        "path-parse": "^1.0.7",
        "supports-preserve-symlinks-flag": "^1.0.0"
      },
      "bin": {
        "resolve": "bin/resolve"
      },
      "engines": {
        "node": ">= 0.4"
      },
      "funding": {
        "url": "https://github.com/sponsors/ljharb"
      }
    },
    "node_modules/resolve-cwd": {
      "version": "3.0.0",
      "resolved": "https://registry.npmjs.org/resolve-cwd/-/resolve-cwd-3.0.0.tgz",
      "integrity": "sha512-OrZaX2Mb+rJCpH/6CpSqt9xFVpN++x01XnN2ie9g6P5/3xelLAkXWVADpdz1IHD/KFfEXyE6V0U01OQ3UO2rEg==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "resolve-from": "^5.0.0"
      },
      "engines": {
        "node": ">=8"
      }
    },
    "node_modules/resolve-from": {
      "version": "5.0.0",
      "resolved": "https://registry.npmjs.org/resolve-from/-/resolve-from-5.0.0.tgz",
      "integrity": "sha512-qYg9KP24dD5qka9J47d0aVky0N+b4fTU89LN9iDnjB5waksiC49rvMB0PrUJQGoTmH50XPiqOvAjDfaijGxYZw==",
      "dev": true,
      "license": "MIT",
      "engines": {
        "node": ">=8"
      }
    },
    "node_modules/resolve.exports": {
      "version": "2.0.3",
      "resolved": "https://registry.npmjs.org/resolve.exports/-/resolve.exports-2.0.3.tgz",
      "integrity": "sha512-OcXjMsGdhL4XnbShKpAcSqPMzQoYkYyhbEaeSko47MjRP9NfEQMhZkXL1DoFlt9LWQn4YttrdnV6X2OiyzBi+A==",
      "dev": true,
      "license": "MIT",
      "engines": {
        "node": ">=10"
      }
    },
    "node_modules/semver": {
      "version": "6.3.1",
      "resolved": "https://registry.npmjs.org/semver/-/semver-6.3.1.tgz",
      "integrity": "sha512-BR7VvDCVHO+q2xBEWskxS6DJE1qRnb7DxzUrogb71CWoSficBxYsiAGd+Kl0mmq/MprG9yArRkyrQxTO6XjMzA==",
      "dev": true,
      "license": "ISC",
      "bin": {
        "semver": "bin/semver.js"
      }
    },
    "node_modules/shebang-command": {
      "version": "2.0.0",
      "resolved": "https://registry.npmjs.org/shebang-command/-/shebang-command-2.0.0.tgz",
      "integrity": "sha512-kHxr2zZpYtdmrN1qDjrrX/Z1rR1kG8Dx+gkpK1G4eXmvXswmcE1hTWBWYUzlraYw1/yZp6YuDY77YtvbN0dmDA==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "shebang-regex": "^3.0.0"
      },
      "engines": {
        "node": ">=8"
      }
    },
    "node_modules/shebang-regex": {
      "version": "3.0.0",
      "resolved": "https://registry.npmjs.org/shebang-regex/-/shebang-regex-3.0.0.tgz",
      "integrity": "sha512-7++dFhtcx3353uBaq8DDR4NuxBetBzC7ZQOhmTQInHEd6bSrXdiEyzCvG07Z44UYdLShWUyXt5M/yhz8ekcb1A==",
      "dev": true,
      "license": "MIT",
      "engines": {
        "node": ">=8"
      }
    },
    "node_modules/signal-exit": {
      "version": "3.0.7",
      "resolved": "https://registry.npmjs.org/signal-exit/-/signal-exit-3.0.7.tgz",
      "integrity": "sha512-wnD2ZE+l+SPC/uoS0vXeE9L1+0wuaMqKlfz9AMUo38JsyLSBWSFcHR1Rri62LZc12vLr1gb3jl7iwQhgwpAbGQ==",
      "dev": true,
      "license": "ISC"
    },
    "node_modules/sisteransi": {
      "version": "1.0.5",
      "resolved": "https://registry.npmjs.org/sisteransi/-/sisteransi-1.0.5.tgz",
      "integrity": "sha512-bLGGlR1QxBcynn2d5YmDX4MGjlZvy2MRBDRNHLJ8VI6l6+9FUiyTFNJ0IveOSP0bcXgVDPRcfGqA0pjaqUpfVg==",
      "dev": true,
      "license": "MIT"
    },
    "node_modules/slash": {
      "version": "3.0.0",
      "resolved": "https://registry.npmjs.org/slash/-/slash-3.0.0.tgz",
      "integrity": "sha512-g9Q1haeby36OSStwb4ntCGGGaKsaVSjQ68fBxoQcutl5fS1vuY18H3wSt3jFyFtrkx+Kz0V1G85A4MyAdDMi2Q==",
      "dev": true,
      "license": "MIT",
      "engines": {
        "node": ">=8"
      }
    },
    "node_modules/source-map": {
      "version": "0.6.1",
      "resolved": "https://registry.npmjs.org/source-map/-/source-map-0.6.1.tgz",
      "integrity": "sha512-UjgapumWlbMhkBgzT7Ykc5YXUT46F0iKu8SGXq0bcwP5dz/h0Plj6enJqjz1Zbq2l5WaqYnrVbwWOWMyF3F47g==",
      "dev": true,
      "license": "BSD-3-Clause",
      "engines": {
        "node": ">=0.10.0"
      }
    },
    "node_modules/source-map-support": {
      "version": "0.5.13",
      "resolved": "https://registry.npmjs.org/source-map-support/-/source-map-support-0.5.13.tgz",
      "integrity": "sha512-SHSKFHadjVA5oR4PPqhtAVdcBWwRYVd6g6cAXnIbRiIwc2EhPrTuKUBdSLvlEKyIP3GCf89fltvcZiP9MMFA1w==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "buffer-from": "^1.0.0",
        "source-map": "^0.6.0"
      }
    },
    "node_modules/sprintf-js": {
      "version": "1.0.3",
      "resolved": "https://registry.npmjs.org/sprintf-js/-/sprintf-js-1.0.3.tgz",
      "integrity": "sha512-D9cPgkvLlV3t3IzL0D0YLvGA9Ahk4PcvVwUbN0dSGr1aP0Nrt4AEnTUbuGvquEC0mA64Gqt1fzirlRs5ibXx8g==",
      "dev": true,
      "license": "BSD-3-Clause"
    },
    "node_modules/stack-utils": {
      "version": "2.0.6",
      "resolved": "https://registry.npmjs.org/stack-utils/-/stack-utils-2.0.6.tgz",
      "integrity": "sha512-XlkWvfIm6RmsWtNJx+uqtKLS8eqFbxUg0ZzLXqY0caEy9l7hruX8IpiDnjsLavoBgqCCR71TqWO8MaXYheJ3RQ==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "escape-string-regexp": "^2.0.0"
      },
      "engines": {
        "node": ">=10"
      }
    },
    "node_modules/string-length": {
      "version": "4.0.2",
      "resolved": "https://registry.npmjs.org/string-length/-/string-length-4.0.2.tgz",
      "integrity": "sha512-+l6rNN5fYHNhZZy41RXsYptCjA2Igmq4EG7kZAYFQI1E1VTXarr6ZPXBg6eq7Y6eK4FEhY6AJlyuFIb/v/S0VQ==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "char-regex": "^1.0.2",
        "strip-ansi": "^6.0.0"
      },
      "engines": {
        "node": ">=10"
      }
    },
    "node_modules/string-width": {
      "version": "4.2.3",
      "resolved": "https://registry.npmjs.org/string-width/-/string-width-4.2.3.tgz",
      "integrity": "sha512-wKyQRQpjJ0sIp62ErSZdGsjMJWsap5oRNihHhu6G7JVO/9jIB6UyevL+tXuOqrng8j/cxKTWyWUwvSTriiZz/g==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "emoji-regex": "^8.0.0",
        "is-fullwidth-code-point": "^3.0.0",
        "strip-ansi": "^6.0.1"
      },
      "engines": {
        "node": ">=8"
      }
    },
    "node_modules/strip-ansi": {
      "version": "6.0.1",
      "resolved": "https://registry.npmjs.org/strip-ansi/-/strip-ansi-6.0.1.tgz",
      "integrity": "sha512-Y38VPSHcqkFrCpFnQ9vuSXmquuv5oXOKpGeT6aGrr3o3Gc9AlVa6JBfUSOCnbxGGZF+/0ooI7KrPuUSztUdU5A==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "ansi-regex": "^5.0.1"
      },
      "engines": {
        "node": ">=8"
      }
    },
    "node_modules/strip-bom": {
      "version": "4.0.0",
      "resolved": "https://registry.npmjs.org/strip-bom/-/strip-bom-4.0.0.tgz",
      "integrity": "sha512-3xurFv5tEgii33Zi8Jtp55wEIILR9eh34FAW00PZf+JnSsTmV/ioewSgQl97JHvgjoRGwPShsWm+IdrxB35d0w==",
      "dev": true,
      "license": "MIT",
      "engines": {
        "node": ">=8"
      }
    },
    "node_modules/strip-final-newline": {
      "version": "2.0.0",
      "resolved": "https://registry.npmjs.org/strip-final-newline/-/strip-final-newline-2.0.0.tgz",
      "integrity": "sha512-BrpvfNAE3dcvq7ll3xVumzjKjZQ5tI1sEUIKr3Uoks0XUl45St3FlatVqef9prk4jRDzhW6WZg+3bk93y6pLjA==",
      "dev": true,
      "license": "MIT",
      "engines": {
        "node": ">=6"
      }
    },
    "node_modules/strip-json-comments": {
      "version": "3.1.1",
      "resolved": "https://registry.npmjs.org/strip-json-comments/-/strip-json-comments-3.1.1.tgz",
      "integrity": "sha512-6fPc+R4ihwqP6N/aIv2f1gMH8lOVtWQHoqC4yK6oSDVVocumAsfCqjkXnqiYMhmMwS/mEHLp7Vehlt3ql6lEig==",
      "dev": true,
      "license": "MIT",
      "engines": {
        "node": ">=8"
      },
      "funding": {
        "url": "https://github.com/sponsors/sindresorhus"
      }
    },
    "node_modules/supports-color": {
      "version": "7.2.0",
      "resolved": "https://registry.npmjs.org/supports-color/-/supports-color-7.2.0.tgz",
      "integrity": "sha512-qpCAvRl9stuOHveKsn7HncJRvv501qIacKzQlO/+Lwxc9+0q2wLyv4Dfvt80/DPn2pqOBsJdDiogXGR9+OvwRw==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "has-flag": "^4.0.0"
      },
      "engines": {
        "node": ">=8"
      }
    },
    "node_modules/supports-preserve-symlinks-flag": {
      "version": "1.0.0",
      "resolved": "https://registry.npmjs.org/supports-preserve-symlinks-flag/-/supports-preserve-symlinks-flag-1.0.0.tgz",
      "integrity": "sha512-ot0WnXS9fgdkgIcePe6RHNk1WA8+muPa6cSjeR3V8K27q9BB1rTE3R1p7Hv0z1ZyAc8s6Vvv8DIyWf681MAt0w==",
      "dev": true,
      "license": "MIT",
      "engines": {
        "node": ">= 0.4"
      },
      "funding": {
        "url": "https://github.com/sponsors/ljharb"
      }
    },
    "node_modules/test-exclude": {
      "version": "6.0.0",
      "resolved": "https://registry.npmjs.org/test-exclude/-/test-exclude-6.0.0.tgz",
      "integrity": "sha512-cAGWPIyOHU6zlmg88jwm7VRyXnMN7iV68OGAbYDk/Mh/xC/pzVPlQtY6ngoIH/5/tciuhGfvESU8GrHrcxD56w==",
      "dev": true,
      "license": "ISC",
      "dependencies": {
        "@istanbuljs/schema": "^0.1.2",
        "glob": "^7.1.4",
        "minimatch": "^3.0.4"
      },
      "engines": {
        "node": ">=8"
      }
    },
    "node_modules/tmpl": {
      "version": "1.0.5",
      "resolved": "https://registry.npmjs.org/tmpl/-/tmpl-1.0.5.tgz",
      "integrity": "sha512-3f0uOEAQwIqGuWW2MVzYg8fV/QNnc/IpuJNG837rLuczAaLVHslWHZQj4IGiEl5Hs3kkbhwL9Ab7Hrsmuj+Smw==",
      "dev": true,
      "license": "BSD-3-Clause"
    },
    "node_modules/to-regex-range": {
      "version": "5.0.1",
      "resolved": "https://registry.npmjs.org/to-regex-range/-/to-regex-range-5.0.1.tgz",
      "integrity": "sha512-65P7iz6X5yEr1cwcgvQxbbIw7Uk3gOy5dIdtZ4rDveLqhrdJP+Li/Hx6tyK0NEb+2GCyneCMJiGqrADCSNk8sQ==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "is-number": "^7.0.0"
      },
      "engines": {
        "node": ">=8.0"
      }
    },
    "node_modules/ts-mixer": {
      "version": "6.0.4",
      "resolved": "https://registry.npmjs.org/ts-mixer/-/ts-mixer-6.0.4.tgz",
      "integrity": "sha512-ufKpbmrugz5Aou4wcr5Wc1UUFWOLhq+Fm6qa6P0w0K5Qw2yhaUoiWszhCVuNQyNwrlGiscHOmqYoAox1PtvgjA==",
      "license": "MIT"
    },
    "node_modules/tslib": {
      "version": "2.8.1",
      "resolved": "https://registry.npmjs.org/tslib/-/tslib-2.8.1.tgz",
      "integrity": "sha512-oJFu94HQb+KVduSUQL7wnpmqnfmLsOA/nAh6b6EH0wCEoK0/mPeXU6c3wKDV83MkOuHPRHtSXKKU99IBazS/2w==",
      "license": "0BSD"
    },
    "node_modules/type-detect": {
      "version": "4.0.8",
      "resolved": "https://registry.npmjs.org/type-detect/-/type-detect-4.0.8.tgz",
      "integrity": "sha512-0fr/mIH1dlO+x7TlcMy+bIDqKPsw/70tVyeHW787goQjhmqaZe10uwLujubK9q9Lg6Fiho1KUKDYz0Z7k7g5/g==",
      "dev": true,
      "license": "MIT",
      "engines": {
        "node": ">=4"
      }
    },
    "node_modules/type-fest": {
      "version": "0.21.3",
      "resolved": "https://registry.npmjs.org/type-fest/-/type-fest-0.21.3.tgz",
      "integrity": "sha512-t0rzBq87m3fVcduHDUFhKmyyX+9eo6WQjZvf51Ea/M0Q7+T374Jp1aUiyUl0GKxp8M/OETVHSDvmkyPgvX+X2w==",
      "dev": true,
      "license": "(MIT OR CC0-1.0)",
      "engines": {
        "node": ">=10"
      },
      "funding": {
        "url": "https://github.com/sponsors/sindresorhus"
      }
    },
    "node_modules/undici": {
      "version": "6.21.3",
      "resolved": "https://registry.npmjs.org/undici/-/undici-6.21.3.tgz",
      "integrity": "sha512-gBLkYIlEnSp8pFbT64yFgGE6UIB9tAkhukC23PmMDCe5Nd+cRqKxSjw5y54MK2AZMgZfJWMaNE4nYUHgi1XEOw==",
      "license": "MIT",
      "engines": {
        "node": ">=18.17"
      }
    },
    "node_modules/undici-types": {
      "version": "7.10.0",
      "resolved": "https://registry.npmjs.org/undici-types/-/undici-types-7.10.0.tgz",
      "integrity": "sha512-t5Fy/nfn+14LuOc2KNYg75vZqClpAiqscVvMygNnlsHBFpSXdJaYtXMcdNLpl/Qvc3P2cB3s6lOV51nqsFq4ag==",
      "license": "MIT"
    },
    "node_modules/update-browserslist-db": {
      "version": "1.1.3",
      "resolved": "https://registry.npmjs.org/update-browserslist-db/-/update-browserslist-db-1.1.3.tgz",
      "integrity": "sha512-UxhIZQ+QInVdunkDAaiazvvT/+fXL5Osr0JZlJulepYu6Jd7qJtDZjlur0emRlT71EN3ScPoE7gvsuIKKNavKw==",
      "dev": true,
      "funding": [
        {
          "type": "opencollective",
          "url": "https://opencollective.com/browserslist"
        },
        {
          "type": "tidelift",
          "url": "https://tidelift.com/funding/github/npm/browserslist"
        },
        {
          "type": "github",
          "url": "https://github.com/sponsors/ai"
        }
      ],
      "license": "MIT",
      "dependencies": {
        "escalade": "^3.2.0",
        "picocolors": "^1.1.1"
      },
      "bin": {
        "update-browserslist-db": "cli.js"
      },
      "peerDependencies": {
        "browserslist": ">= 4.21.0"
      }
    },
    "node_modules/v8-to-istanbul": {
      "version": "9.3.0",
      "resolved": "https://registry.npmjs.org/v8-to-istanbul/-/v8-to-istanbul-9.3.0.tgz",
      "integrity": "sha512-kiGUalWN+rgBJ/1OHZsBtU4rXZOfj/7rKQxULKlIzwzQSvMJUUNgPwJEEh7gU6xEVxC0ahoOBvN2YI8GH6FNgA==",
      "dev": true,
      "license": "ISC",
      "dependencies": {
        "@jridgewell/trace-mapping": "^0.3.12",
        "@types/istanbul-lib-coverage": "^2.0.1",
        "convert-source-map": "^2.0.0"
      },
      "engines": {
        "node": ">=10.12.0"
      }
    },
    "node_modules/walker": {
      "version": "1.0.8",
      "resolved": "https://registry.npmjs.org/walker/-/walker-1.0.8.tgz",
      "integrity": "sha512-ts/8E8l5b7kY0vlWLewOkDXMmPdLcVV4GmOQLyxuSswIJsweeFZtAsMF7k1Nszz+TYBQrlYRmzOnr398y1JemQ==",
      "dev": true,
      "license": "Apache-2.0",
      "dependencies": {
        "makeerror": "1.0.12"
      }
    },
    "node_modules/which": {
      "version": "2.0.2",
      "resolved": "https://registry.npmjs.org/which/-/which-2.0.2.tgz",
      "integrity": "sha512-BLI3Tl1TW3Pvl70l3yq3Y64i+awpwXqsGBYWkkqMtnbXgrMD+yj7rhW0kuEDxzJaYXGjEW5ogapKNMEKNMjibA==",
      "dev": true,
      "license": "ISC",
      "dependencies": {
        "isexe": "^2.0.0"
      },
      "bin": {
        "node-which": "bin/node-which"
      },
      "engines": {
        "node": ">= 8"
      }
    },
    "node_modules/wrap-ansi": {
      "version": "7.0.0",
      "resolved": "https://registry.npmjs.org/wrap-ansi/-/wrap-ansi-7.0.0.tgz",
      "integrity": "sha512-YVGIj2kamLSTxw6NsZjoBxfSwsn0ycdesmc4p+Q21c5zPuZ1pl+NfxVdxPtdHvmNVOQ6XSYG4AUtyt/Fi7D16Q==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "ansi-styles": "^4.0.0",
        "string-width": "^4.1.0",
        "strip-ansi": "^6.0.0"
      },
      "engines": {
        "node": ">=10"
      },
      "funding": {
        "url": "https://github.com/chalk/wrap-ansi?sponsor=1"
      }
    },
    "node_modules/wrappy": {
      "version": "1.0.2",
      "resolved": "https://registry.npmjs.org/wrappy/-/wrappy-1.0.2.tgz",
      "integrity": "sha512-l4Sp/DRseor9wL6EvV2+TuQn63dMkPjZ/sp9XkghTEbV9KlPS1xUsZ3u7/IQO4wxtcFB4bgpQPRcR3QCvezPcQ==",
      "dev": true,
      "license": "ISC"
    },
    "node_modules/write-file-atomic": {
      "version": "4.0.2",
      "resolved": "https://registry.npmjs.org/write-file-atomic/-/write-file-atomic-4.0.2.tgz",
      "integrity": "sha512-7KxauUdBmSdWnmpaGFg+ppNjKF8uNLry8LyzjauQDOVONfFLNKrKvQOxZ/VuTIcS/gge/YNahf5RIIQWTSarlg==",
      "dev": true,
      "license": "ISC",
      "dependencies": {
        "imurmurhash": "^0.1.4",
        "signal-exit": "^3.0.7"
      },
      "engines": {
        "node": "^12.13.0 || ^14.15.0 || >=16.0.0"
      }
    },
    "node_modules/ws": {
      "version": "8.18.3",
      "resolved": "https://registry.npmjs.org/ws/-/ws-8.18.3.tgz",
      "integrity": "sha512-PEIGCY5tSlUt50cqyMXfCzX+oOPqN0vuGqWzbcJ2xvnkzkq46oOpz7dQaTDBdfICb4N14+GARUDw2XV2N4tvzg==",
      "license": "MIT",
      "engines": {
        "node": ">=10.0.0"
      },
      "peerDependencies": {
        "bufferutil": "^4.0.1",
        "utf-8-validate": ">=5.0.2"
      },
      "peerDependenciesMeta": {
        "bufferutil": {
          "optional": true
        },
        "utf-8-validate": {
          "optional": true
        }
      }
    },
    "node_modules/y18n": {
      "version": "5.0.8",
      "resolved": "https://registry.npmjs.org/y18n/-/y18n-5.0.8.tgz",
      "integrity": "sha512-0pfFzegeDWJHJIAmTLRP2DwHjdF5s7jo9tuztdQxAhINCdvS+3nGINqPd00AphqJR/0LhANUS6/+7SCb98YOfA==",
      "dev": true,
      "license": "ISC",
      "engines": {
        "node": ">=10"
      }
    },
    "node_modules/yallist": {
      "version": "3.1.1",
      "resolved": "https://registry.npmjs.org/yallist/-/yallist-3.1.1.tgz",
      "integrity": "sha512-a4UGQaWPH59mOXUYnAG2ewncQS4i4F43Tv3JoAM+s2VDAmS9NsK8GpDMLrCHPksFT7h3K6TOoUNn2pb7RoXx4g==",
      "dev": true,
      "license": "ISC"
    },
    "node_modules/yargs": {
      "version": "17.7.2",
      "resolved": "https://registry.npmjs.org/yargs/-/yargs-17.7.2.tgz",
      "integrity": "sha512-7dSzzRQ++CKnNI/krKnYRV7JKKPUXMEh61soaHKg9mrWEhzFWhFnxPxGl+69cD1Ou63C13NUPCnmIcrvqCuM6w==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "cliui": "^8.0.1",
        "escalade": "^3.1.1",
        "get-caller-file": "^2.0.5",
        "require-directory": "^2.1.1",
        "string-width": "^4.2.3",
        "y18n": "^5.0.5",
        "yargs-parser": "^21.1.1"
      },
      "engines": {
        "node": ">=12"
      }
    },
    "node_modules/yargs-parser": {
      "version": "21.1.1",
      "resolved": "https://registry.npmjs.org/yargs-parser/-/yargs-parser-21.1.1.tgz",
      "integrity": "sha512-tVpsJW7DdjecAiFpbIB1e3qxIQsE6NoPc5/eTdrbbIC4h0LVsWhnoa3g+m2HclBIujHzsxZ4VJVA+GUuc2/LBw==",
      "dev": true,
      "license": "ISC",
      "engines": {
        "node": ">=12"
      }
    },
    "node_modules/yocto-queue": {
      "version": "0.1.0",
      "resolved": "https://registry.npmjs.org/yocto-queue/-/yocto-queue-0.1.0.tgz",
      "integrity": "sha512-rVksvsnNCdJ/ohGc6xgPwyN8eheCxsiLM8mxuE/t/mOVqJewPuO1miLpTHQiRgTKCLexL4MeAFVagts7HmNZ2Q==",
      "dev": true,
      "license": "MIT",
      "engines": {
        "node": ">=10"
      },
      "funding": {
        "url": "https://github.com/sponsors/sindresorhus"
      }
    }
  }
}

```

===== FILE: package.json =====
```json
{
  "scripts": {
    "smoke": "node ./scripts/smoke-load.js",
    "start": "node index.js",
    "start:bg": "node ./scripts/startBot.js",
    "stop": "node ./scripts/stopBot.js",
    "import-levels": "node ./scripts/import-levels.js",
  "export:text": "node ./scripts/export-text.js",
  "export:summary": "node ./scripts/export-summary.js",
  "export:watch": "node ./scripts/export-watch.js",
  "export:schedule": "node ./scripts/export-schedule-summary.js",
    "test": "jest --runInBand",
    "migrate:clockin": "node ./scripts/migrate-clockin.js"
  },
  "dependencies": {
    "discord.js": "^14.22.1",
    "dotenv": "^17.2.2",
    "ms": "^2.1.3"
  },
  "devDependencies": {
    "jest": "^29.7.0"
  }
}

```

===== FILE: scripts/check-ephemeral.js =====
```javascript
#!/usr/bin/env node
// Fails if any source file still contains deprecated ephemeral:true usage.
const { execSync } = require('child_process');
const fs = require('fs');
const path = require('path');

function listTracked() {
  const out = execSync('git ls-files "*.js"', { encoding: 'utf8' }).split(/\r?\n/).filter(Boolean);
  return out;
}

function scan() {
  const bad = [];
  for (const file of listTracked()) {
    const content = fs.readFileSync(path.resolve(file), 'utf8');
    if (content.includes('ephemeral:true') || content.includes('ephemeral: true')) bad.push(file);
  }
  return bad;
}

const bad = scan();
if (bad.length) {
  console.error('\nDeprecated ephemeral:true found in:');
  for (const f of bad) console.error(' -', f);
  console.error('\nUse { flags: 1<<6 } (EPHEMERAL) instead.');
  process.exit(1);
}
console.log('Ephemeral usage check passed.');
```

===== FILE: scripts/export-schedule-summary.js =====
```javascript
// Emit a quick schedule summary (counts and next runs) into schedule_summary.txt
const fs = require('fs');
const path = require('path');
const { cfgPath } = require('../utils/paths');

function formatTs(ms) {
  if (!ms || !Number.isFinite(ms)) return 'n/a';
  const s = Math.floor(ms / 1000);
  return `<t:${s}:F> (<t:${s}:R>)`;
}

function main() {
  const eventsFile = cfgPath('events.json');
  const schedulesFile = cfgPath('schedules.json');
  let events = [];
  let schedules = [];
  try {
    const ej = JSON.parse(fs.readFileSync(eventsFile, 'utf8'));
    events = Array.isArray(ej) ? ej : (Array.isArray(ej?.events) ? ej.events : []);
  } catch {}
  try {
    const sj = JSON.parse(fs.readFileSync(schedulesFile, 'utf8'));
    schedules = Array.isArray(sj) ? sj : (Array.isArray(sj?.schedules) ? sj.schedules : []);
  } catch {}

  const lines = [];
  lines.push('===== AUTO MESSAGES (events.json) =====');
  lines.push(`Total events: ${events.length}`);
  for (const ev of events) {
    const next = ev.__nextRunAt || ev.nextRunAt || null;
    const ch = ev.channelId || 'unknown';
    lines.push(`- ${ev.name || ev.id || '(unnamed)'} -> #${ch} next: ${formatTs(next)}`);
  }
  lines.push('');

  lines.push('===== SCHEDULES (schedules.json) =====');
  lines.push(`Total schedules: ${schedules.length}`);
  for (const sc of schedules) {
    const next = sc.__nextRunAt || sc.nextRunAt || null;
    const ch = sc.channelId || 'unknown';
    lines.push(`- ${sc.name || sc.id || '(unnamed)'} -> #${ch} next: ${formatTs(next)}`);
  }
  lines.push('');

  const out = path.join(path.dirname(eventsFile), '..', 'schedule_summary.txt');
  fs.writeFileSync(out, lines.join('\n'), 'utf8');
  console.log(`[export-schedule-summary] wrote ${out}`);
}

if (require.main === module) main();

```

===== FILE: scripts/export-summary.js =====
```javascript
// Generate a compact, paste-friendly project summary with folder tree and important snippets
// Output: PROJECT_SUMMARY.txt at repo root

const fs = require('fs');
const path = require('path');

const root = path.join(__dirname, '..');
const outFile = path.join(root, 'PROJECT_SUMMARY.txt');

const excludeDirs = new Set(['node_modules', '.git', '.vscode', 'logs']);
const excludeFiles = new Set([
  '.env', '.bot.pid', '.miyako.lock', 'logs_runner.txt',
  'FULL_CONTEXT.txt', 'PROJECT_SUMMARY.txt', 'schedule_summary.txt',
  // dynamic config/state files
  'activeMenus.json', 'bank.json', 'botStatus.json', 'buttonSessions.json',
  'cash.json', 'changelogSnapshot.json', 'crash-latest.json', 'depositProgress.json',
  'errorLog.json', 'levels.json', 'process-heartbeat.json', 'snipes.json',
  'testingBank.json', 'testingCash.json', 'vcLevels.json'
]);
const allowedExt = new Set(['.js', '.json', '.md']);

function listAll(relDir = '.') {
  const abs = path.join(root, relDir);
  const entries = fs.readdirSync(abs, { withFileTypes: true });
  const result = [];
  for (const e of entries) {
    if (e.isDirectory()) {
      if (excludeDirs.has(e.name)) continue;
      result.push({ type: 'dir', rel: path.join(relDir, e.name) });
      result.push(...listAll(path.join(relDir, e.name)));
    } else if (e.isFile()) {
      if (excludeFiles.has(e.name)) continue;
      const ext = path.extname(e.name).toLowerCase();
      if (!allowedExt.has(ext)) continue;
      result.push({ type: 'file', rel: path.join(relDir, e.name) });
    }
  }
  return result;
}

function makeTree(lines) {
  // Build nested tree text using indentation and sorted paths
  const sorted = [...lines].sort((a, b) => a.rel.localeCompare(b.rel));
  const out = [];
  out.push('// Project Structure');
  const prefix = '';
  out.push(prefix + path.basename(root) + '/');
  for (const { rel, type } of sorted) {
    const parts = rel.split(path.sep);
    let indent = '  ';
    for (let i = 0; i < parts.length - 1; i++) indent += '  ';
    out.push(`${'  '.repeat(parts.length)}${type === 'dir' ? parts[parts.length - 1] + '/' : parts[parts.length - 1]}`);
  }
  return out.join('\n');
}

function extractObjectKeysFromBlock(src, startIdx) {
  // Naive brace scanner to get shallow keys from an object literal starting at or after startIdx
  let i = startIdx;
  const n = src.length;
  let depth = 0;
  let started = false;
  const keys = new Set();
  while (i < n) {
    const ch = src[i];
    if (ch === '{') { depth++; started = true; i++; continue; }
    if (ch === '}') { depth--; i++; if (started && depth === 0) break; continue; }
    if (started && depth === 1) {
      // capture key before colon (simple case)
      const m = src.slice(i).match(/\s*([A-Za-z0-9_\-"']+)\s*:/);
      if (m) {
        let key = m[1];
        key = key.replace(/^['"]|['"]$/g, '');
        if (key) keys.add(key);
        i += m.index + m[0].length;
        continue;
      }
    }
    i++;
  }
  return Array.from(keys);
}

function summarizeJS(filePath) {
  const src = fs.readFileSync(filePath, 'utf8');
  const lines = src.split(/\r?\n/);
  const out = [];
  const push = (s) => out.push(s);
  push('// ...');
  // Scan line-by-line for key constructs
  lines.forEach((line, idx) => {
    const l = line.trim();
    if (/^class\s+\w+/.test(l)) push(l);
    else if (/^async\s+function\s+\w+\(/.test(l)) push(l.replace(/\s+\{\s*$/, '')); 
    else if (/^function\s+\w+\(/.test(l)) push(l.replace(/\s+\{\s*$/, ''));
    else if (/^const\s+\w+\s*=\s*async\s*\(/.test(l)) push(l.replace(/\{\s*$/, '')); 
    else if (/^const\s+\w+\s*=\s*\(/.test(l) && l.includes('=>')) push(l.replace(/\{\s*$/, ''));
    else if (/\.on\(\s*['"][^'"]+['"]/.test(l)) push(l);
    else if (/ActiveMenus\.registerHandler\(/.test(l)) push(l);
    else if (/module\.exports\s*=\s*\{/.test(l)) {
      // collect export keys
      const start = lines.slice(0, idx + 1).join('\n').length;
      const keys = extractObjectKeysFromBlock(src, start);
      push('module.exports = { ' + keys.join(', ') + ' }');
    } else if (/module\.exports\./.test(l) || /^exports\./.test(l)) {
      push(l);
    } else if (/^const\s+defaultConfig\s*=\s*\{/.test(l)) {
      const start = lines.slice(0, idx + 1).join('\n').length;
      const keys = extractObjectKeysFromBlock(src, start);
      push('const defaultConfig = { ' + keys.join(', ') + ' }');
    }
  });
  push('// ...');
  return out.join('\n');
}

function summarizeJSON(filePath) {
  try {
    const txt = fs.readFileSync(filePath, 'utf8');
    const json = JSON.parse(txt);
    if (Array.isArray(json)) {
      return `// JSON Array (length=${json.length})`;
    }
    const keys = Object.keys(json || {});
    return '/* JSON keys: ' + keys.join(', ') + ' */';
  } catch {
    // Fallback to first ~20 lines
    const first = fs.readFileSync(filePath, 'utf8').split(/\r?\n/).slice(0, 20).join('\n');
    return first + '\n// ...';
  }
}

function summarizeMD(filePath) {
  const lines = fs.readFileSync(filePath, 'utf8').split(/\r?\n/);
  const heads = lines.filter(l => /^#\s/.test(l)).slice(0, 10);
  return (heads.join('\n') || '// markdown');
}

function main() {
  const items = listAll();
  const treeText = makeTree(items);
  const parts = [];
  parts.push('===== COMPACT PROJECT SUMMARY =====');
  parts.push(`Project: ${path.basename(root)}  (generated: ${new Date().toISOString()})`);
  parts.push('');
  parts.push(treeText);
  parts.push('');
  parts.push('// Important Snippets (condensed)');

  for (const it of items) {
    if (it.type !== 'file') continue;
    const rel = it.rel.replace(/\\/g, '/');
    const ext = path.extname(rel).toLowerCase();
    parts.push('');
    parts.push(`// FILE: ${rel}`);
    try {
      if (ext === '.js') parts.push(summarizeJS(path.join(root, rel)));
      else if (ext === '.json') parts.push(summarizeJSON(path.join(root, rel)));
      else if (ext === '.md') parts.push(summarizeMD(path.join(root, rel)));
    } catch (e) {
      parts.push(`// (failed to summarize: ${e.message})`);
    }
  }

  parts.push('');
  parts.push('===== END SUMMARY =====');

  fs.writeFileSync(outFile, parts.join('\n'), 'utf8');
  console.log(`[export-summary] Wrote ${outFile}`);
}

if (require.main === module) main();

```

===== FILE: scripts/export-text.js =====
```javascript
// Concatenate repository source files into a single text file for copy-paste context
// Output: FULL_CONTEXT.txt at repo root
// Includes: .js, .json, .md
// Excludes: node_modules, .git, .vscode, .env, pid/lock/log artifacts

const fs = require('fs');
const path = require('path');

const root = path.join(__dirname, '..');
const outFile = path.join(root, 'FULL_CONTEXT.txt');

const excludeDirs = new Set(['node_modules', '.git', '.vscode', 'logs']);
const excludeFiles = new Set([
  '.env', '.bot.pid', '.miyako.lock', 'logs_runner.txt', 'FULL_CONTEXT.txt',
  'PROJECT_SUMMARY.txt', 'schedule_summary.txt',
  // dynamic config/state files
  'activeMenus.json', 'bank.json', 'botStatus.json', 'buttonSessions.json',
  'cash.json', 'changelogSnapshot.json', 'crash-latest.json', 'depositProgress.json',
  'errorLog.json', 'levels.json', 'process-heartbeat.json', 'snipes.json',
  'testingBank.json', 'testingCash.json', 'vcLevels.json'
]);
const allowedExt = new Set(['.js', '.json', '.md']);

function langForExt(ext) {
  switch (ext) {
    case '.js':
      return 'javascript';
    case '.json':
      return 'json';
    case '.md':
      return 'markdown';
    default:
      return '';
  }
}

function listFiles(dir) {
  const items = [];
  for (const name of fs.readdirSync(dir)) {
    const full = path.join(dir, name);
    const rel = path.relative(root, full);
    const stat = fs.statSync(full);
    if (stat.isDirectory()) {
      if (excludeDirs.has(name)) continue;
      items.push(...listFiles(full));
    } else {
      if (excludeFiles.has(name)) continue;
      const ext = path.extname(name).toLowerCase();
      if (!allowedExt.has(ext)) continue;
      // Skip binary-ish big files (none expected for these ext) and the output file
      if (rel.replace(/\\/g, '/') === 'FULL_CONTEXT.txt') continue;
      items.push(full);
    }
  }
  return items;
}

function main() {
  const files = listFiles(root).sort();
  const ws = fs.createWriteStream(outFile, { encoding: 'utf8' });
  const header = [
    '===== BEGIN REPO CONTEXT =====',
    `Repo: ${path.basename(root)}  (generated: ${new Date().toISOString()})`,
    'Notes:',
    '- Sensitive runtime files are excluded (e.g., .env, pid/lock).',
    '- Sections are delimited by FILE markers and fenced code blocks.',
    '',
  ].join('\n');
  ws.write(header + '\n');

  for (const full of files) {
    const rel = path.relative(root, full).replace(/\\/g, '/');
    const ext = path.extname(full).toLowerCase();
    const lang = langForExt(ext);
    ws.write(`\n===== FILE: ${rel} =====\n`);
    ws.write('```' + lang + '\n');
    try {
      const content = fs.readFileSync(full, 'utf8');
      ws.write(content.replace(/```/g, '\u0060\u0060\u0060'));
    } catch (e) {
      ws.write(`/* Failed to read file: ${e.message} */\n`);
    }
    ws.write('\n```\n');
  }

  ws.write('\n===== END REPO CONTEXT =====\n');
  ws.end();
  ws.on('close', () => {
    console.log(`[export-text] Wrote ${files.length} files into ${outFile}`);
  });
}

if (require.main === module) main();

```

===== FILE: scripts/export-watch.js =====
```javascript
// Watch the repo and auto-regenerate paste-friendly summaries for ChatGPT
// - Regenerates: PROJECT_SUMMARY.txt and FULL_CONTEXT.txt
// - Debounced to avoid thrashing; ignores its own output files

const fs = require('fs');
const path = require('path');
const { spawn } = require('child_process');

const root = path.join(__dirname, '..');
const OUT_SUMMARY = path.join(root, 'PROJECT_SUMMARY.txt');
const OUT_FULL = path.join(root, 'FULL_CONTEXT.txt');

const excludeDirs = new Set(['node_modules', '.git', '.vscode', 'logs']);
const excludeFiles = new Set([
  '.env', '.bot.pid', '.miyako.lock', 'logs_runner.txt',
  'PROJECT_SUMMARY.txt', 'FULL_CONTEXT.txt', 'schedule_summary.txt'
]);
const allowedExt = new Set(['.js', '.json', '.md']);

function isExcluded(file) {
  const base = path.basename(file);
  if (excludeFiles.has(base)) return true;
  // inside excluded dirs?
  const rel = path.relative(root, file).replace(/\\/g, '/');
  const parts = rel.split('/');
  if (parts.some(p => excludeDirs.has(p))) return true;
  const ext = path.extname(file).toLowerCase();
  return !allowedExt.has(ext);
}

let pending = false;
let timer = null;
let running = false;

function run(cmd, args) {
  return new Promise((resolve) => {
    const p = spawn(process.execPath, [path.join(root, ...args)], { cwd: root, stdio: 'ignore' });
    p.on('exit', () => resolve());
  });
}

async function regenerate() {
  if (running) return; // coalesce
  running = true;
  try {
    await run('node', ['scripts', 'export-summary.js']);
    await run('node', ['scripts', 'export-text.js']);
    // Optional: if a schedule summary exporter exists, run it here
    const schedExporter = path.join(root, 'scripts', 'export-schedule-summary.js');
    try { if (fs.existsSync(schedExporter)) await run('node', ['scripts', 'export-schedule-summary.js']); } catch {}
    console.log(`[export-watch] Updated summaries at ${new Date().toISOString()}`);
  } catch (e) {
    console.error('[export-watch] regenerate error', e);
  } finally {
    running = false;
  }
}

function scheduleRegen(reason) {
  if (timer) clearTimeout(timer);
  timer = setTimeout(() => { timer = null; regenerate(); }, 600);
}

function startWatch() {
  // Initial build
  regenerate();
  // fs.watch recursive works on Windows/macOS; good for this project context
  try {
    const watcher = fs.watch(root, { recursive: true }, (event, filename) => {
      if (!filename) return;
      const full = path.join(root, filename);
      if (isExcluded(full)) return;
      scheduleRegen(`${event}:${filename}`);
    });
    watcher.on('error', () => {});
    console.log('[export-watch] Watching for changes...');
  } catch (e) {
    console.error('[export-watch] fs.watch failed; falling back to interval scan');
    let lastTick = 0;
    setInterval(() => {
      const now = Date.now();
      if (now - lastTick < 2000) return;
      lastTick = now;
      scheduleRegen('interval');
    }, 2500).unref?.();
  }
}

if (require.main === module) startWatch();

```

===== FILE: scripts/import-levels.js =====
```javascript
require('dotenv/config');
const { Client, GatewayIntentBits, Partials } = require('discord.js');
const fs = require('fs');
const path = require('path');
const { cfgPath } = require('../utils/paths');

const CHANNEL_ID = '1232701768832516100';
const LEVELS_FILE = cfgPath('levels.json');

function xpForLevel(level) {
  const BASE_XP = 150;
  return Math.floor(BASE_XP * Math.pow(level, 1 / 0.7));
}

function loadLevels() {
  try {
    if (fs.existsSync(LEVELS_FILE)) {
      const raw = fs.readFileSync(LEVELS_FILE, 'utf8');
      return JSON.parse(raw || '{}') || {};
    }
  } catch {}
  return {};
}

function saveLevels(levels) {
  try {
    const dir = path.dirname(LEVELS_FILE);
    if (!fs.existsSync(dir)) fs.mkdirSync(dir, { recursive: true });
    fs.writeFileSync(LEVELS_FILE, JSON.stringify(levels, null, 2));
  } catch (e) {
    console.error('Failed to save levels.json:', e);
  }
}

function extractTextFromMessage(msg) {
  let text = msg.content || '';
  if (Array.isArray(msg.embeds) && msg.embeds.length) {
    for (const emb of msg.embeds) {
      if (emb.title) text += `\n${emb.title}`;
      if (emb.description) text += `\n${emb.description}`;
      if (Array.isArray(emb.fields)) {
        for (const f of emb.fields) {
          if (f && f.name) text += `\n${f.name}`;
          if (f && f.value) text += `\n${f.value}`;
        }
      }
      if (emb.footer && emb.footer.text) text += `\n${emb.footer.text}`;
    }
  }
  return text.trim();
}

// Try to extract a plain "@Name" (no true mention markup) from text
function extractAtName(text) {
  if (!text) return null;
  // Capture the first @... token up to a common delimiter; allow spaces inside up to 24 chars (display names can have spaces)
  // Prefer a conservative token (letters/numbers/_), then fall back to a looser one if nothing found
  const tight = text.match(/@([A-Za-z0-9_]{2,32})\b/);
  if (tight) return tight[1];
  const loose = text.match(/@\s*([^\n,!.?:]{2,32})/);
  if (loose) return loose[1].trim();
  return null;
}

function parseLevelEvent(text, msg) {
  if (!text) return null;
  // Try to find a mentioned user ID
  const mentionMatch = text.match(/<@!?(\d+)>/);
  const userId = mentionMatch ? mentionMatch[1] : (msg.mentions?.users?.first()?.id || null);
  // Also try to capture a plain @Name string for later resolution
  const userName = userId ? null : extractAtName(text);

  // Find a level number near common keywords
  // Patterns:
  //  - reached level 12
  //  - leveled up to 12
  //  - is now level 12
  //  - climbed from level 29 to 30
  //  - level 12 (generic fallback)
  // Normalize formatting (remove markdown symbols like **, __, `, ~) so digits are contiguous
  const normText = String(text).replace(/[\*`_~]/g, '');
  const patterns = [
    /reached\s+(?:level|lvl)\s*(\d+)/i,
    /leveled?\s+up\s+(?:to\s*)?(\d+)/i,
    /is\s+now\s+(?:level|lvl)\s*(\d+)/i,
    /climbed\s+from\s+(?:level|lvl)\s*\d+\s+to\s+(\d+)/i,
    /(?:level|lvl)\s*(\d+)/i,
  ];
  let level = null;
  for (const re of patterns) {
    const m = normText.match(re);
    if (m && m[1]) { level = parseInt(m[1], 10); break; }
  }
  if (!level || level <= 0) return null;

  return { userId, userName, level };
}

async function fetchAllMessages(channel) {
  const out = [];
  let before;
  while (true) {
    const batch = await channel.messages.fetch({ limit: 100, before }).catch(() => null);
    if (!batch || batch.size === 0) break;
    const arr = Array.from(batch.values());
    out.push(...arr);
    before = arr[arr.length - 1].id;
    // small delay to be gentle
    await new Promise(r => setTimeout(r, 350));
  }
  return out;
}

async function main() {
  const token = process.env.DISCORD_TOKEN;
  if (!token) {
    console.error('DISCORD_TOKEN missing in environment');
    process.exitCode = 1;
    return;
  }

  const client = new Client({
    intents: [
      GatewayIntentBits.Guilds,
      GatewayIntentBits.GuildMessages,
      GatewayIntentBits.MessageContent,
      // Needed to resolve plain "@Name" to a user ID by scanning members
      GatewayIntentBits.GuildMembers
    ],
    partials: [Partials.Channel, Partials.Message]
  });

  client.once('ready', async () => {
    console.log(`[import-levels] Logged in as ${client.user?.tag || client.user?.id}`);
    try {
  console.log('[import-levels] LEVELS_FILE path:', LEVELS_FILE);
      const channel = await client.channels.fetch(CHANNEL_ID).catch(() => null);
      if (!channel || !channel.isTextBased()) {
        console.error(`[import-levels] Channel ${CHANNEL_ID} not found or not text-based.`);
        process.exitCode = 1;
        return client.destroy();
      }

      console.log('[import-levels] Fetching messages...');
      const messages = await fetchAllMessages(channel);
      console.log(`[import-levels] Fetched ${messages.length} messages.`);

      // Prepare member resolvers if needed
      const guild = channel.guild;
      let resolvedFromNames = 0;
      let unresolvedNames = new Map(); // name -> count
      // Build lookup maps once
      let memberRecords = null; // Array<{id, u, d, nu, nd}>
      const norm = (s) => String(s || '')
        .toLowerCase()
        .normalize('NFKD')
        .replace(/[^a-z0-9]+/g, '');
      async function ensureMemberIndex() {
        if (memberRecords) return;
        try {
          // Fetch all members into cache; requires Server Members Intent enabled for the bot
          await guild.members.fetch();
        } catch (e) {
          console.warn('[import-levels] Warning: Failed to fetch all members. Name resolution may be incomplete.', e?.message || e);
        }
        memberRecords = [];
        guild.members.cache.forEach(m => {
          const u = m.user?.username || '';
          const d = m.displayName || m.nickname || '';
          memberRecords.push({ id: String(m.id), u, d, nu: norm(u), nd: norm(d) });
        });
        console.log(`[import-levels] Member index built for ${memberRecords.length} members.`);
      }

      function resolveNameToId(name) {
        if (!name || !memberRecords) return null;
        // Try raw then normalized
        const raw = String(name).trim();
        const nraw = norm(raw);
        if (!nraw) return null;
        const exact = memberRecords.filter(m => m.u.toLowerCase() === raw.toLowerCase() || m.d.toLowerCase() === raw.toLowerCase() || m.nu === nraw || m.nd === nraw);
        if (exact.length === 1) return exact[0].id;
        if (exact.length > 1) return null; // ambiguous
        // startsWith on normalized
        const starts = memberRecords.filter(m => m.nu.startsWith(nraw) || m.nd.startsWith(nraw));
        if (starts.length === 1) return starts[0].id;
        if (starts.length > 1) return null;
        // includes on normalized (may be ambiguous)
        const incl = memberRecords.filter(m => m.nu.includes(nraw) || m.nd.includes(nraw));
        if (incl.length === 1) return incl[0].id;
        return null;
      }

      const highest = new Map(); // userId -> level
      let nonEmptyText = 0;
      let containsCongrats = 0;
      let containsLevelWord = 0;
      let sampleLogged = 0;
      for (const msg of messages) {
        const text = extractTextFromMessage(msg);
        if (text && text.length) {
          nonEmptyText++;
          const ltext = text.toLowerCase();
          if (ltext.includes('congrat')) containsCongrats++;
          if (/(?:\blevel\b|\blvl\b)/i.test(text)) containsLevelWord++;
          if (sampleLogged < 3 && (ltext.includes('congrat') || /\bclimbed\b/i.test(text))) {
            console.log('[sample]', text.substring(0, 200).replace(/\n/g, ' '));
            sampleLogged++;
          }
        }
        const parsed = parseLevelEvent(text, msg);
        if (!parsed) continue;
        let uid = parsed.userId;
        if (!uid && parsed.userName) {
          await ensureMemberIndex();
          uid = resolveNameToId(parsed.userName);
          if (uid) resolvedFromNames++;
          else unresolvedNames.set(parsed.userName, (unresolvedNames.get(parsed.userName) || 0) + 1);
        }
        if (!uid) continue;
        const prev = highest.get(uid) || 0;
        if (parsed.level > prev) highest.set(uid, parsed.level);
      }

      console.log(`[import-levels] Parsed ${highest.size} users with levels.`);
  console.log(`[import-levels] Text stats: nonEmpty=${nonEmptyText}, containsCongrats=${containsCongrats}, containsLevelWord=${containsLevelWord}`);
      if (resolvedFromNames) {
        console.log(`[import-levels] Resolved ${resolvedFromNames} users from plain @Name.`);
      }
      if (unresolvedNames.size) {
        // Show top 10 unresolved names by frequency
        const top = Array.from(unresolvedNames.entries()).sort((a,b)=>b[1]-a[1]).slice(0,10);
        console.log(`[import-levels] Unresolved @Name samples (top ${top.length}):`, top.map(([n,c])=>`${n} x${c}`).join(', '));
      }

      const current = loadLevels();
      const beforeCount = Object.keys(current).length;
      console.log(`[import-levels] Entries before update: ${beforeCount}`);
      let updated = 0;
      for (const [userId, level] of highest.entries()) {
        const existing = current[userId] || { xp: 0, level: 0 };
        if ((existing.level || 0) >= level) continue; // keep higher existing
        current[userId] = {
          xp: xpForLevel(level),
          level
        };
        updated++;
      }

      saveLevels(current);
      const afterCount = Object.keys(current).length;
      console.log(`[import-levels] Updated ${updated} users. Entries after update (in-memory): ${afterCount}`);
      try {
        const verify = JSON.parse(fs.readFileSync(LEVELS_FILE, 'utf8') || '{}');
        console.log(`[import-levels] Verify on-disk entry count: ${Object.keys(verify).length}`);
      } catch (e) {
        console.warn('[import-levels] Post-save verification failed:', e?.message || e);
      }
    } catch (e) {
      console.error('[import-levels] Error:', e);
      process.exitCode = 1;
    } finally {
      setTimeout(() => client.destroy(), 250);
    }
  });

  client.login(token).catch(err => {
    console.error('Login failed:', err);
    process.exitCode = 1;
  });
}

main();

```

===== FILE: scripts/migrate-clockin.js =====
```javascript
#!/usr/bin/env node
// Migration CLI wrapper
const { getEvents, updateEvent } = require('../utils/eventsStorage');
const { migrateClockIn } = require('./migrateClockInCore');

function run() {
  const events = getEvents();
  const updated = migrateClockIn(events);
  for (const ev of updated) updateEvent(ev.id, { __clockIn: ev.__clockIn });
  console.log(`Clock-in migration complete. Updated ${updated.length} event(s).`);
}

if (require.main === module) run();
module.exports = { run };


```

===== FILE: scripts/migrateClockInCore.js =====
```javascript
// Core migration logic extracted for testability.
function migrateClockIn(events) {
  const updated = [];
  for (const ev of events) {
    let changed = false;
    if (!ev.__clockIn || typeof ev.__clockIn !== 'object') { ev.__clockIn = { positions:{}, messageIds:[], lastSentTs:null }; changed = true; }
    const ck = ev.__clockIn;
    if (!ck.positions || typeof ck.positions !== 'object') { ck.positions = {}; changed = true; }
    if (!Array.isArray(ck.messageIds)) { ck.messageIds = []; changed = true; }
    if (!('lastSentTs' in ck)) { ck.lastSentTs = null; changed = true; }
    const KEYS = ['instance_manager','manager','bouncer','bartender','backup','maybe'];
    for (const k of KEYS) { if (!Array.isArray(ck.positions[k])) { ck.positions[k] = []; changed = true; } }
    if (changed) updated.push(ev);
  }
  return updated;
}
module.exports = { migrateClockIn };

```

===== FILE: scripts/restartHelper.js =====
```javascript
// Wait for singleton lock to clear, then start index.js (prevents race on Windows)
const fs = require('fs');
const path = require('path');
const { spawn } = require('child_process');

const root = path.join(__dirname, '..');
const lockFile = path.join(root, '.miyako.lock');

const timeoutMs = 15000; // max wait for lock to clear
const intervalMs = 200;  // poll interval

function start() {
  const child = spawn(process.execPath, ['index.js'], {
    cwd: root,
    env: process.env,
    detached: true,
    stdio: 'ignore',
    windowsHide: true
  });
  try { child.unref(); } catch {}
}

const startTs = Date.now();
const timer = setInterval(() => {
  const exists = fs.existsSync(lockFile);
  if (!exists) {
    clearInterval(timer);
    start();
    process.exit(0);
  }
  if (Date.now() - startTs > timeoutMs) {
    // Lock persisted too long; assume stale and try starting anyway
    try { fs.unlinkSync(lockFile); } catch {}
    clearInterval(timer);
    start();
    process.exit(0);
  }
}, intervalMs);

```

===== FILE: scripts/runner.js =====
```javascript
// Auto-restart runner for Miyako
// - Restarts on crash (non-zero exit) with backoff
// - Monitors heartbeat and restarts if stale (hung)
// - Cleans up child on runner exit
const { spawn } = require('child_process');
const fs = require('fs');
const path = require('path');

const root = path.join(__dirname, '..');
const hbFile = path.join(root, 'config', 'process-heartbeat.json');
const logFile = path.join(root, 'logs_runner.txt');

function log(line) {
  const s = `[${new Date().toISOString()}] ${line}\n`;
  try { fs.appendFileSync(logFile, s); } catch {}
}

function readHeartbeatTs() {
  try { const j = JSON.parse(fs.readFileSync(hbFile, 'utf8')); return j.ts || 0; } catch { return 0; }
}

let child = null;
let stopping = false;
let backoffMs = 2000;
const backoffMax = 30000;
const hbStaleMs = 3 * 60 * 1000; // 3 minutes
let lastStart = 0;

function startChild() {
  lastStart = Date.now();
  child = spawn(process.execPath, ['index.js'], {
    cwd: root,
    detached: false,
    stdio: 'ignore'
  });
  log(`child started pid=${child.pid}`);
  child.on('exit', (code, signal) => {
    const dur = Date.now() - lastStart;
    log(`child exit code=${code} signal=${signal} uptimeMs=${dur}`);
    if (stopping) return; // runner is shutting down deliberately
    // Reset backoff if it ran long enough (10m)
    if (dur > 10 * 60 * 1000) backoffMs = 2000;
    setTimeout(() => {
      backoffMs = Math.min(backoffMax, backoffMs * 2);
      startChild();
    }, backoffMs);
  });
}

function killChildTree(cb) {
  if (!child || child.killed) return cb?.();
  try { child.kill('SIGTERM'); } catch {}
  setTimeout(() => {
    // On Windows, ensure the tree is killed
    if (process.platform === 'win32') {
      const { spawnSync } = require('child_process');
      spawnSync('taskkill', ['/PID', String(child.pid), '/T', '/F'], { stdio: 'ignore' });
    } else {
      try { process.kill(child.pid, 'SIGKILL'); } catch {}
    }
    cb?.();
  }, 700);
}

// Heartbeat monitor
setInterval(() => {
  if (!child) return;
  const now = Date.now();
  const hb = readHeartbeatTs();
  if (!hb) return; // not yet initialized
  const stale = now - hb;
  if (stale > hbStaleMs) {
    log(`heartbeat stale (${stale}ms) -> restarting child`);
    killChildTree(() => {
      // child exit handler will schedule restart with backoff
    });
  }
}, 60000).unref?.();

process.on('SIGINT', () => { stopping = true; log('runner SIGINT'); killChildTree(() => process.exit(0)); });
process.on('SIGTERM', () => { stopping = true; log('runner SIGTERM'); killChildTree(() => process.exit(0)); });
process.on('exit', () => { stopping = true; killChildTree(); });

startChild();

```

===== FILE: scripts/smoke-load.js =====
```javascript
// Minimal smoke test: load modules and exit to avoid lingering timers/intervals
try {
  [
    '../commands/profile.js',
    '../commands/leaderboard.js',
    '../commands/help.js',
    '../commands/schedule.js',
    '../commands/test.js',
    '../commands/scripts.js',
    '../events/messages.js',
    '../events/interactionEvents.js',
    '../utils/activeMenus.js',
    '../utils/leveling.js',
    '../utils/cashDrops.js'
  ].forEach(m => require(m));
  console.log('[smoke] modules loaded');
} catch (e) {
  console.error('[smoke] load error:', e);
  process.exitCode = 1;
}
// Force exit after a short delay in case modules set intervals
setTimeout(() => process.exit(), 50);

```

===== FILE: scripts/startBot.js =====
```javascript
// Background start script: spawns the bot detached and writes a PID file.
const { spawn } = require('child_process');
const fs = require('fs');
const path = require('path');

const root = path.join(__dirname, '..');
const pidFile = path.join(root, '.bot.pid');

if (fs.existsSync(pidFile)) {
  console.error('Refusing to start: .bot.pid already exists. If the bot is not running, delete .bot.pid.');
  process.exit(1);
}

const child = spawn(process.execPath, ['index.js'], {
  cwd: root,
  detached: true,
  stdio: 'ignore',
  windowsHide: true
});

child.unref();
fs.writeFileSync(pidFile, String(child.pid));
console.log('Bot started in background. PID:', child.pid);

```

===== FILE: scripts/stopBot.js =====
```javascript
// Stop script: reads PID file and attempts to terminate the background bot.
const fs = require('fs');
const path = require('path');
const { spawnSync } = require('child_process');

const root = path.join(__dirname, '..');
const pidFile = path.join(root, '.bot.pid');

if (!fs.existsSync(pidFile)) {
  console.error('No .bot.pid file found. Use "npm run start:bg" to start in background.');
  process.exit(1);
}

const pid = parseInt(fs.readFileSync(pidFile, 'utf8').trim(), 10);
if (!pid || Number.isNaN(pid)) {
  console.error('Invalid PID in .bot.pid. Remove the file manually.');
  process.exit(1);
}

function processExists(p) {
  try { process.kill(p, 0); return true; } catch { return false; }
}

if (!processExists(pid)) {
  console.warn('Process not running; cleaning up stale PID file.');
  fs.unlinkSync(pidFile);
  process.exit(0);
}

try {
  process.kill(pid, 'SIGTERM');
} catch (e) {
  console.warn('Primary SIGTERM failed:', e.message);
}

// Windows sometimes needs taskkill for detached trees.
setTimeout(() => {
  if (processExists(pid)) {
    if (process.platform === 'win32') {
      spawnSync('taskkill', ['/PID', String(pid), '/T', '/F'], { stdio: 'ignore' });
    } else {
      try { process.kill(pid, 'SIGKILL'); } catch {}
    }
  }
  if (!processExists(pid)) {
    console.log('Bot process stopped:', pid);
    try { fs.unlinkSync(pidFile); } catch {}
    process.exit(0);
  } else {
    console.error('Failed to terminate PID', pid);
    process.exit(1);
  }
}, 700);

```

===== FILE: services/economyService.js =====
```javascript
// Economy service: centralized access + future caching/batching
const bank = require('../utils/bank');
const cash = require('../utils/cash');

function getUserBalances(userId) {
  return {
    cash: cash.getCash(userId),
    bank: bank.getBank(userId)
  };
}

function deposit(userId, amount, opts) {
  return bank.depositToBank(userId, amount, opts);
}

function withdraw(userId, amount) {
  return bank.withdrawFromBank(userId, amount);
}

module.exports = {
  getUserBalances,
  deposit,
  withdraw,
  // expose underlying for advanced use
  bank,
  cash
};

```

===== FILE: services/leaderboardService.js =====
```javascript
// leaderboardService: caches sorted level leaderboards (text + VC) for short TTL to reduce sort cost
// Provides buildLeaderboardEmbed(guild, viewerId, page, pageSize, mode)
// Mode: 'text' | 'vc'

const { createEmbed } = require('../utils/embeds');
const theme = require('../utils/theme');
const { applyFooterWithPagination } = require('../utils/ui');
const { levels, vcLevels } = require('./levelingService');
const { getTopBank } = require('../utils/bank');

const CACHE_TTL_MS = 5000; // 5s window; can also be explicitly invalidated when XP changes
const caches = { text: { expires: 0, entries: [], dirty: false }, vc: { expires: 0, entries: [], dirty: false } };

function buildEntries(mode) {
  const src = mode === 'vc' ? vcLevels : levels;
  return Object.entries(src || {}).map(([userId, data]) => ({
    userId,
    xp: data?.xp || 0,
    level: data?.level || 0
  })).sort((a,b) => (b.level - a.level) || (b.xp - a.xp));
}

function getEntries(mode = 'text') {
  const key = mode === 'vc' ? 'vc' : 'text';
  const now = Date.now();
  const cache = caches[key];
  if (cache.expires < now || cache.dirty) {
    cache.entries = buildEntries(key === 'vc' ? 'vc' : 'text');
    cache.expires = now + CACHE_TTL_MS;
    cache.dirty = false;
  }
  return cache.entries;
}

function computeRank(mode, viewerId) {
  const entries = getEntries(mode);
  const idx = entries.findIndex(e => String(e.userId) === String(viewerId));
  return idx === -1 ? null : idx + 1;
}

function buildBankSection() {
  const topBank = getTopBank(10) || [];
  const bankLines = topBank.map((e, i) => {
    const n = i + 1;
    const medal = n === 1 ? '🥇' : n === 2 ? '🥈' : n === 3 ? '🥉' : `#${n}`;
    return `${medal} <@${e.userId}> — $${e.amount.toLocaleString()}`;
  });
  return `\n\n${theme.emojis.bank} Bank Leaderboard\n${bankLines.length ? bankLines.join('\n') : 'No balances yet.'}`;
}

function buildLeaderboardEmbed(guild, viewerId, page = 1, pageSize = 10, mode = 'text') {
  const entries = getEntries(mode);
  const totalPages = Math.max(1, Math.ceil(entries.length / pageSize));
  const safePage = Math.min(totalPages, Math.max(1, Math.floor(page)));
  const start = (safePage - 1) * pageSize;
  const pageEntries = entries.slice(start, start + pageSize);
  const lines = pageEntries.map((e, i) => {
    const rankNum = start + i + 1;
    const medal = rankNum === 1 ? '🥇' : rankNum === 2 ? '🥈' : rankNum === 3 ? '🥉' : `#${rankNum}`;
    const isYou = String(e.userId) === String(viewerId);
    const line = `${medal} <@${e.userId}> — Lv. ${e.level}`;
    return isYou ? `**${line} ← You**` : line;
  });
  const rank = computeRank(mode, viewerId);
  const viewerOnPage = pageEntries.some(e => String(e.userId) === String(viewerId));
  const extraLine = !viewerOnPage && rank ? `\n— —\nYou: **#${rank}** <@${viewerId}>` : '';
  const bankSection = buildBankSection();
  const embed = createEmbed({
    title: mode === 'vc' ? `${theme.emojis.vc} VC Leaderboard` : `${theme.emojis.leaderboard} Leaderboard`,
    description: (lines.length ? lines.join('\n') + extraLine : 'No data yet.') + bankSection,
    color: mode === 'vc' ? theme.colors.danger : theme.colors.warning
  });
  const extraFooter = rank ? `Your rank: #${rank}` : null;
  applyFooterWithPagination(embed, guild, { testingMode: false, page: safePage, totalPages, extra: extraFooter });
  return embed;
}

function invalidate(mode = 'both') {
  if (mode === 'both' || mode === 'text') caches.text.dirty = true;
  if (mode === 'both' || mode === 'vc') caches.vc.dirty = true;
}

module.exports = { getEntries, computeRank, buildLeaderboardEmbed, invalidate };
```

===== FILE: services/levelingService.js =====
```javascript
// Leveling service: wraps text + VC xp/level logic for future caching, analytics & aggregation
// Exposes uniform helpers so commands do not pull from raw utils.* modules directly.
const levelsModule = require('../utils/levels'); // exports: { levels, getXP, getLevel, addXP, saveLevels }
const vcLevelsModule = require('../utils/vcLevels'); // exports: { vcLevels, getVCXP, getVCLevel, addVCXP, saveVCLevels }
const leveling = require('../utils/leveling');

function getUserLevelData(userId, mode = 'text') {
  if (mode === 'vc') {
    return { level: vcLevelsModule.getVCLevel(userId), xp: vcLevelsModule.getVCXP(userId), mode };
  }
  return { level: levelsModule.getLevel(userId), xp: levelsModule.getXP(userId), mode };
}

module.exports = {
  // Aggregated accessor
  getUserLevelData,
  // Pass-through leveling event handler & modifier
  handleLeveling: leveling.handleLeveling,
  getUserModifier: leveling.getUserModifier,
  // Text leveling exports (data object + helpers)
  levels: levelsModule.levels,
  getXP: levelsModule.getXP,
  getLevel: levelsModule.getLevel,
  // VC leveling exports
  vcLevels: vcLevelsModule.vcLevels,
  getVCXP: vcLevelsModule.getVCXP,
  getVCLevel: vcLevelsModule.getVCLevel
};

```

===== FILE: services/metricsService.js =====
```javascript
// Lightweight in-memory metrics tracker
const metrics = {
  commands: 0,
  interactions: 0,
  errors: 0,
  lastCommandAt: 0
};
function markCommand() { metrics.commands++; metrics.lastCommandAt = Date.now(); }
function markInteraction() { metrics.interactions++; }
function markError() { metrics.errors++; }
function getMetrics() { return { ...metrics }; }
module.exports = { markCommand, markInteraction, markError, getMetrics };
```

===== FILE: services/scheduleService.js =====
```javascript
// scheduleService: abstraction over scheduler & related storage to decouple commands from raw utils
// Phase 1: thin wrappers; future phases can add caching, validation, conflict detection.

const scheduler = require('../utils/scheduler');
const scheduleStorage = require('../utils/scheduleStorage');
const eventsStorage = require('../utils/eventsStorage');

function start(client, opts) {
  return scheduler.startScheduler(client, opts);
}

function computeNextRun(schedule) {
  return scheduler.computeNextRun(schedule);
}

function computeAfterRun(schedule) {
  return scheduler.computeAfterRun(schedule);
}

// Re-export storage helpers for now (could be narrowed later)
module.exports = {
  start,
  computeNextRun,
  computeAfterRun,
  addSchedule: scheduleStorage.addSchedule,
  updateSchedule: scheduleStorage.updateSchedule,
  getSchedules: scheduleStorage.getSchedules,
  // Events
  getEvents: eventsStorage.getEvents,
  getEvent: eventsStorage.getEvent,
  addEvent: eventsStorage.addEvent,
  updateEvent: eventsStorage.updateEvent,
  removeEvent: eventsStorage.removeEvent
};

```

===== FILE: services/statusService.js =====
```javascript
// Centralized status service consolidating startup/shutdown status logic
// and channel name updates. Future health/report expansions live here.
const fs = require('fs');
const path = require('path');
const { createEmbed } = require('../utils/embeds');
const { getRecentErrors, clearErrorLog } = require('../utils/errorUtil');
const { CONFIG_LOG_CHANNEL } = require('../utils/logChannels');
const { cfgPath } = require('../utils/paths');

const BOT_STATUS_FILE = cfgPath('botStatus.json');

function readLastOnline() {
  try {
    if (fs.existsSync(BOT_STATUS_FILE)) {
      const data = JSON.parse(fs.readFileSync(BOT_STATUS_FILE, 'utf8'));
      return data.lastOnline || 0;
    }
  } catch {}
  return 0;
}

function writeLastOnline(ts = Date.now()) {
  try { fs.writeFileSync(BOT_STATUS_FILE, JSON.stringify({ lastOnline: ts }, null, 2)); } catch {}
}

async function postStartup(client, { channelId = CONFIG_LOG_CHANNEL } = {}) {
  if (!client?.isReady?.()) return;
  const channel = channelId ? await client.channels.fetch(channelId).catch(()=>null) : null;
  const now = Date.now();
  const last = readLastOnline();
  const diff = now - last;
  const restarted = diff >= 5 * 60 * 1000;
  if (channel) {
    // Attach recent error summary (last 5) if any stored
    const recent = getRecentErrors(5);
    const summary = recent.length ? '\n\nRecent Errors:\n' + recent.map(e => `• [${e.scope}] ${e.message.split('\n')[0].slice(0,120)}`).join('\n') : '';
    const embed = createEmbed({
      title: restarted ? '🟢 Restarted' : '🟢 Online',
      description: (restarted ? 'Miyako has restarted and is now online!' : 'Miyako is now online!') + summary,
      color: restarted ? 0x55ff55 : 0x55ff55
    });
    await channel.send({ embeds: [embed] }).catch(()=>{});
    // Clear stored errors unless retention flag file is present (simple env-based toggle in future)
    clearErrorLog();
  }
  writeLastOnline(now);
  return { lastOnline: last, diff };
}

async function postShutdown(client, { channelId = CONFIG_LOG_CHANNEL } = {}) {
  if (!client?.isReady?.()) return;
  const channel = channelId ? await client.channels.fetch(channelId).catch(()=>null) : null;
  if (channel) {
    const embed = createEmbed({
      title: '🔴 Shutting Down',
      description: 'Miyako is shutting down <:dead:1414023466243330108>.',
      color: 0xff0000
    });
    await channel.send({ embeds: [embed] }).catch(()=>{});
  }
}

async function updateStatusChannelName(client, online, { channelId = CONFIG_LOG_CHANNEL } = {}) {
  if (!client?.isReady?.()) return;
  const channel = channelId ? await client.channels.fetch(channelId).catch(()=>null) : null;
  if (!channel || typeof channel.setName !== 'function') return;
  const name = online ? '🟢︱𝙼𝚒𝚢𝚊𝚔𝚘𝚜-𝙲𝚑𝚊𝚖𝚋𝚎𝚛' : '🔴︱𝙼𝚒𝚢𝚊𝚔𝚘𝚜-𝙲𝚑𝚊𝚖𝚋𝚎𝚛';
  await channel.setName(name).catch(()=>{});
}

module.exports = {
  postStartup,
  postShutdown,
  updateStatusChannelName,
  readLastOnline,
  writeLastOnline
};

```

===== FILE: src/commands/balance.js =====
```javascript
module.exports = require('../../commands/balance');

```

===== FILE: src/commands/cash.js =====
```javascript
module.exports = require('../../commands/cash');

```

===== FILE: src/commands/clockin.js =====
```javascript
module.exports = require('../../commands/clockin');

```

===== FILE: src/commands/configMenu.js =====
```javascript
module.exports = require('../../commands/configMenu');

```

===== FILE: src/commands/configMenu/constants.js =====
```javascript
module.exports = require('../../../commands/configMenu/constants');

```

===== FILE: src/commands/configMenu/handlers.js =====
```javascript
module.exports = require('../../../commands/configMenu/handlers');

```

===== FILE: src/commands/configMenu/index.js =====
```javascript
module.exports = require('../../../commands/configMenu');

```

===== FILE: src/commands/configMenu/render.js =====
```javascript
module.exports = require('../../../commands/configMenu/render');

```

===== FILE: src/commands/diagnostics.js =====
```javascript
module.exports = require('../../commands/diagnostics');

```

===== FILE: src/commands/help.js =====
```javascript
module.exports = require('../../commands/help');

```

===== FILE: src/commands/leaderboard.js =====
```javascript
module.exports = require('../../commands/leaderboard');

```

===== FILE: src/commands/level.js =====
```javascript
module.exports = require('../../commands/level');

```

===== FILE: src/commands/metrics.js =====
```javascript
module.exports = require('../../commands/metrics');

```

===== FILE: src/commands/moderation/dm.js =====
```javascript
module.exports = require('../../../commands/moderation/dm');

```

===== FILE: src/commands/moderation/index.js =====
```javascript
module.exports = require('../../../commands/moderation');

```

===== FILE: src/commands/moderation/moderationCommands.js =====
```javascript
module.exports = require('../../../commands/moderation/moderationCommands');

```

===== FILE: src/commands/moderation/permissions.js =====
```javascript
module.exports = require('../../../commands/moderation/permissions');

```

===== FILE: src/commands/moderation/purge.js =====
```javascript
module.exports = require('../../../commands/moderation/purge');

```

===== FILE: src/commands/moderation/replies.js =====
```javascript
module.exports = require('../../../commands/moderation/replies');

```

===== FILE: src/commands/moderation/warnings.js =====
```javascript
module.exports = require('../../../commands/moderation/warnings');

```

===== FILE: src/commands/profile.js =====
```javascript
module.exports = require('../../commands/profile');

```

===== FILE: src/commands/schedule.js =====
```javascript
module.exports = require('../../commands/schedule');

```

===== FILE: src/commands/scripts.js =====
```javascript
module.exports = require('../../commands/scripts');

```

===== FILE: src/commands/snipes.js =====
```javascript
module.exports = require('../../commands/snipes');

```

===== FILE: src/commands/test.js =====
```javascript
module.exports = require('../../commands/test');

```

===== FILE: src/events/guildEvents.js =====
```javascript
module.exports = require('../../events/guildEvents');

```

===== FILE: src/events/interactionEvents.js =====
```javascript
module.exports = require('../../events/interactionEvents');

```

===== FILE: src/events/messages.js =====
```javascript
module.exports = require('../../events/messages');

```

===== FILE: src/index.js =====
```javascript
// Early crash reporter (must be first)
require('./utils/crashReporter').initEarly();
// Prevent multiple concurrent bot instances (esp. if accidentally started twice)
try { require('./utils/singleton').ensureSingleton(); } catch {}
try { process.title = 'MiyakoBot'; } catch {}
require('dotenv/config');
// (ephemeralShim removed; all interactions now use flags:1<<6 directly)
const { Client, GatewayIntentBits, Partials, EmbedBuilder, ActionRowBuilder, ButtonBuilder, ButtonStyle } = require('discord.js');
const { semanticButton, buildNavRow } = require('./utils/ui');
const fs = require('fs');
const path = require('path');
const projectRoot = path.resolve(process.cwd());
const { config, saveConfig } = require('./utils/storage');
const { postStartupChangelog } = require('./utils/changelog');
const { registerErrorListener } = require('./utils/errorUtil');
let lastOfflineDurationMs = null;
try {
  const lastShutdownPath = path.join(projectRoot, 'config', 'lastShutdown.json');
  if (fs.existsSync(lastShutdownPath)) {
    const raw = JSON.parse(fs.readFileSync(lastShutdownPath, 'utf8'));
    if (raw && raw.ts) {
      lastOfflineDurationMs = Date.now() - raw.ts;
      // remove file after reading
      try { fs.unlinkSync(lastShutdownPath); } catch {}
    }
  }
} catch {}
const { attachMessageEvents } = require('./events/messages');
const { attachGuildEvents } = require('./events/guildEvents');
const { attachInteractionEvents } = require('./events/interactionEvents');
// Legacy command handler in events/messageEvents.js caused duplicate replies; ensure not required/attached elsewhere.
try { delete require.cache[require.resolve('../events/messageEvents')]; } catch {}
let CRASH_LOG_CHANNEL_ID = null; // resolved post-config load
const { startScheduler } = require('./utils/scheduler');
const ActiveMenus = require('./utils/activeMenus');
const { startVoiceLeveling } = require('./utils/voiceLeveling');
const { validateConfig } = require('./utils/configValidate');
const { startCashDrops } = require('./utils/cashDrops');
// Load daily deposit progress tracker
try { require('./utils/depositProgress').load(); } catch {}

const BOT_STATUS_FILE = path.join(projectRoot, 'config', 'botStatus.json');

// Real-time error forwarding (compact). Fires after client ready.
registerErrorListener(async (entry) => {
  try {
    if (!client.isReady || !client.isReady()) return; // wait for ready
    if (!CRASH_LOG_CHANNEL_ID) CRASH_LOG_CHANNEL_ID = config.crashLogChannelId || CONFIG_LOG_CHANNEL;
    if (!CRASH_LOG_CHANNEL_ID) return; // nowhere to send
    const channel = await client.channels.fetch(CRASH_LOG_CHANNEL_ID).catch(() => null);
    if (!channel) return;
    // De-duplicate high volume warnings; throttle identical scope+message pairs within 30s
    global.__ERR_CACHE = global.__ERR_CACHE || new Map();
    const key = entry.scope + ':' + entry.message.slice(0, 120);
    const now = Date.now();
    const prev = global.__ERR_CACHE.get(key);
    if (prev && (now - prev) < 30000) return; // skip spam
    global.__ERR_CACHE.set(key, now);
    // Build compact embed
    const em = createEmbed({
      title: `⚠️ ${entry.scope}`,
      description: `\u200B\n\`${(entry.message || '').slice(0, 350).replace(/`/g, '\u200b')}\`\n\u200B`,
      color: entry.scope.startsWith('fatal') ? 0xE74C3C : 0xFFA500,
    });
    em.setFooter({ text: `At <t:${Math.floor(entry.ts / 1000)}:T>` });
    await channel.send({ embeds: [em] }).catch(() => {});
  } catch { /* ignore */ }
});
// After client ready, start voice leveling service
// This file's ready handler likely exists below; if not, attach minimal
if (require.main === module) {
  // Lazy attach to client when created in this module
}
const STATUS_CHANNEL_ID = '1413966369296220233';
const ACTIVE_MENUS_FILE = path.join(projectRoot, 'config', 'activeMenus.json');

const client = new Client({
  intents: [
    GatewayIntentBits.Guilds,
    GatewayIntentBits.GuildMembers,
    GatewayIntentBits.GuildMessages,
    GatewayIntentBits.MessageContent,
    GatewayIntentBits.GuildVoiceStates,
  ],
  partials: [Partials.Message, Partials.Channel, Partials.Reaction],
});

// --- Global error capture layer (non-recursive) ---
try {
  const { recordExternalError, setOriginalConsoleError } = require('./utils/errorUtil');
  const origConsoleError = console.error;
  setOriginalConsoleError(origConsoleError);
  console.error = function (...args) {
    try {
      recordExternalError('console', args.length === 1 ? args[0] : args.map((a) => (a && a.stack) ? a.stack : String(a)).join(' '));
    } catch { /* ignore */ }
    return origConsoleError.apply(this, args);
  };
  process.on('warning', (w) => recordExternalError('warning', w));
} catch { /* ignore capture setup errors */ }

// Attach client to crashReporter for graceful shutdown details
try { require('./utils/crashReporter').attachClient(client); } catch {}

const { runHealthChecks, formatHealthLines } = require('./utils/health');
const { CONFIG_LOG_CHANNEL } = require('./utils/logChannels');
const { createEmbed, safeAddField } = require('./utils/embeds');

async function sendBotStatusMessage() {
  let lastOnline = 0;
  if (fs.existsSync(BOT_STATUS_FILE)) {
    try { lastOnline = JSON.parse(fs.readFileSync(BOT_STATUS_FILE)).lastOnline || 0; } catch {}
  }
  const now = Date.now();
  const diff = now - lastOnline;
  const channel = await client.channels.fetch(STATUS_CHANNEL_ID).catch(() => null);
  if (channel) {
    // Build a single, modern embed with inline smart changelog
    const isColdStart = diff >= 5 * 60 * 1000;
    const title = isColdStart ? '🟢 Miyako is Online' : '🔄 Miyako Restarted';
    const color = isColdStart ? 0x5865F2 : 0xFFD700;

    const embed = createEmbed({
      title,
      description: isColdStart
        ? "All systems are up. Here's what changed since last run:"
        : `Restart complete. ${lastOfflineDurationMs != null ? `Offline for ${Math.max(0, Math.round(lastOfflineDurationMs / 1000))}s.` : ''} Here's what changed since last run:`,
      color,
    });

    // Build changelog overview + store details for button expansion
    let changelogSession = null;
    try {
      const { createSnapshot, compareSnapshots } = require('./utils/changelog');
      const snapshotFile = path.join(projectRoot, 'config', 'changelogSnapshot.json');
      let prev = null;
      try { if (fs.existsSync(snapshotFile)) prev = JSON.parse(fs.readFileSync(snapshotFile, 'utf8')); } catch {}
      const curr = createSnapshot(projectRoot);
      const result = compareSnapshots(prev, curr);
      try { fs.writeFileSync(snapshotFile, JSON.stringify({ createdAt: Date.now(), files: curr }, null, 2)); } catch {}
      const total = result.added.length + result.removed.length + result.modified.length;
      if (total === 0) {
        safeAddField(embed, 'Changelog Overview', 'No changes have been made since last restart.');
      } else {
        const summary = `Files changed: ${total} (➕ ${result.added.length}, ✖️ ${result.removed.length}, 🔧 ${result.modified.length})`;
        safeAddField(embed, 'Changelog Overview', summary);
        // Prepare detailed lines (full lists capped)
        const detailLines = [];
        for (const it of result.added) detailLines.push(`➕ ${it.path}`);
        for (const it of result.removed) detailLines.push(`✖️ ${it.path}`);
        for (const it of result.modified) {
          const ld = it.linesDelta === 0 ? '±0' : (it.linesDelta > 0 ? `+${it.linesDelta}` : `${it.linesDelta}`);
          detailLines.push(`🔧 ${it.path} (${ld} lines)`);
        }
        changelogSession = { summary, detailLines };
      }
    } catch (e) {
      safeAddField(embed, 'Changelog Overview', 'No changes have been made since last restart.');
    }

    // Run health checks (events + staff team) and append compact status block at top of embed
    try {
      const health = await runHealthChecks(client);
      if (health && health.length) {
        const lines = formatHealthLines(health).slice(0, 1024);
        embed.spliceFields(0, 0, { name: 'Health', value: lines });
      }
    } catch (e) {
      safeAddField(embed, 'Health', '✖️ Health checks failed: ' + e.message.slice(0, 200));
    }

    // Components: Details button only if we have detail lines
    let components = [];
    if (changelogSession && changelogSession.detailLines && changelogSession.detailLines.length) {
      components = [
        buildNavRow([
          semanticButton('primary', { id: 'status_show', label: 'Details' }),
        ]),
      ];
    }
    const sent = await channel.send({ embeds: [embed], components }).catch(() => null);
    if (sent && changelogSession) {
      try {
        ActiveMenus.registerMessage(sent, { type: 'status', data: { ...changelogSession, expanded: false } });
      } catch {}
    }
  }
  fs.writeFileSync(BOT_STATUS_FILE, JSON.stringify({ lastOnline: now }, null, 2));
}

async function setStatusChannelName(online) {
  const channel = await client.channels.fetch(STATUS_CHANNEL_ID).catch(() => null);
  if (!channel || !channel.setName) return;
  const name = online
    ? '🟢︎𝙼𝚒𝚢𝚊𝚔𝚘-𝚜𝚝𝚊𝚝𝚞𝚜'
    : '🔴︎𝙼𝚒𝚢𝚊𝚔𝚘-𝚜𝚝𝚊𝚝𝚞𝚜';
  await channel.setName(name).catch(() => {});
}

// (SIGINT/SIGTERM now handled gracefully by crashReporter; no duplicate handlers here)

// Use 'clientReady' instead of deprecated 'ready' (v15 will remove 'ready')
client.once('clientReady', async () => {
  config.testingMode = false; saveConfig();
  console.log(`✅ Logged in as ${client.user.tag}`);
  await sendBotStatusMessage();
  await setStatusChannelName(true);

  // Config validation report (deduplicated per boot)
  try {
    const guild = client.guilds.cache.first();
    const issues = validateConfig(guild);
    if (issues.length) {
      console.warn(`[config] ${issues.length} issue(s):`);
      for (const i of issues) console.warn(' -', i);
      if (CONFIG_LOG_CHANNEL) {
        const channel = await client.channels.fetch(CONFIG_LOG_CHANNEL).catch(() => null);
        if (channel) {
          const hash = require('crypto').createHash('sha1').update(issues.join('|')).digest('hex');
          const stampFile = path.join(projectRoot, 'config', '.lastConfigIssuesHash');
          let prev = null; try { if (fs.existsSync(stampFile)) prev = fs.readFileSync(stampFile, 'utf8').trim(); } catch {}
          if (prev !== hash) {
            channel.send({ content: `⚠️ Config validation found ${issues.length} issue(s):\n` + issues.map(i => `• ${i}`).join('\n') }).catch(() => {});
            try { fs.writeFileSync(stampFile, hash); } catch {}
          } else {
            console.log('[config] issues unchanged since last boot; not re-sent');
          }
        }
      }
    } else {
      console.log('[config] validation passed');
    }
  } catch (err) {
    console.error('[config] validation error', err);
  }
  // Changelog now included inside the status embed above

  // Initialize global button/session manager (restores timers and disables expired UIs)
  try { await ActiveMenus.init(client); } catch (e) { console.error('[ActiveMenus init]', e); }
  // Sweep orphaned (stale) interactive menus (older than 1h) for cleanliness
  try { if (ActiveMenus.sweepOrphans) await ActiveMenus.sweepOrphans(client); } catch {}

  // Start the scheduler loop
  try { startScheduler(client); } catch (e) { console.error('[Scheduler] start error:', e); }

  // Start voice leveling loop
  try { startVoiceLeveling(client); } catch (e) { console.error('[VoiceLeveling] start error:', e); }

  // Start cash drops cleanup loop
  try { startCashDrops(); } catch (e) { console.error('[CashDrops] start error:', e); }

  // Basic permission health check for critical channels
  try {
    const important = [STATUS_CHANNEL_ID, config.modLogChannelId].filter(Boolean);
    for (const id of important) {
      const ch = await client.channels.fetch(id).catch(() => null);
      if (ch && ch.permissionsFor && !ch.permissionsFor(client.user.id)?.has('SendMessages')) {
        console.warn('[perm] Missing SendMessages in channel', id);
      }
    }
  } catch {}

  // After boot, refresh recent auto/clock-in messages to apply latest patches
  try {
    const { getEvents } = require('./utils/eventsStorage');
    const { refreshTrackedAutoMessages } = require('./commands/schedule');
    const evs = getEvents();
    for (const ev of evs) {
      // Light throttle to avoid rate limits on large sets
      try { await refreshTrackedAutoMessages(client, ev); } catch {}
      await new Promise((r) => setTimeout(r, 150));
    }
  } catch (e) { console.error('[Startup Refresh] error', e); }

  // Cleanup lingering menus on restart
  if (fs.existsSync(ACTIVE_MENUS_FILE)) {
    try {
      const menus = JSON.parse(fs.readFileSync(ACTIVE_MENUS_FILE));
      for (const { channelId, messageId, commandId } of menus) {
        const channel = await client.channels.fetch(channelId).catch(() => null);
        if (channel) {
          await channel.messages.delete(messageId).catch(() => {});
          await channel.messages.delete(commandId).catch(() => {});
        }
      }
      fs.writeFileSync(ACTIVE_MENUS_FILE, '[]');
    } catch (err) { console.error('[Startup Menu Cleanup Error]:', err); }
  }
});

// Status (startup) details handler
try {
  ActiveMenus.registerHandler('status', async (interaction, session) => {
    if (!interaction.isButton()) return;
    const data = session.data || {}; // { summary, detailLines, expanded }
    if (interaction.customId === 'status_show') {
      data.expanded = true;
      // Rebuild embed from original message but replace/add Details field
      const embed = EmbedBuilder.from(interaction.message.embeds[0] || {});
      // Remove existing Details field if any
      const fields = embed.data.fields || [];
      const filtered = fields.filter((f) => f.name !== 'Details');
      if (data.detailLines && data.detailLines.length) {
        const chunked = [];
        let current = [];
        let totalLen = 0;
        for (const line of data.detailLines) {
          if ((totalLen + line.length + 1) > 1000 && current.length) {
            chunked.push(current.join('\n'));
            current = [];
            totalLen = 0;
          }
          current.push(line);
          totalLen += line.length + 1;
        }
        if (current.length) chunked.push(current.join('\n'));
        // Discord limit: keep at most 2 detail fields for brevity
        filtered.push({ name: 'Details', value: chunked[0].slice(0, 1024) });
        if (chunked[1]) filtered.push({ name: 'Details (cont.)', value: chunked[1].slice(0, 1024) });
      }
      embed.setFields(filtered);
      const rows = [
        buildNavRow([
          semanticButton('nav', { id: 'status_hide', label: 'Hide' }),
        ]),
      ];
      await interaction.update({ embeds: [embed], components: rows });
      session.data = data;
      return;
    }
    if (interaction.customId === 'status_hide') {
      data.expanded = false;
      const embed = EmbedBuilder.from(interaction.message.embeds[0] || {});
      const fields = (embed.data.fields || []).filter((f) => !f.name.startsWith('Details'));
      // Ensure overview field name is 'Changelog Overview'
      embed.setFields(fields.map((f) => (f.name === 'Changelog' ? { ...f, name: 'Changelog Overview' } : f)));
      const rows = [
        buildNavRow([
          semanticButton('primary', { id: 'status_show', label: 'Details' }),
        ]),
      ];
      await interaction.update({ embeds: [embed], components: rows });
      session.data = data;
      return;
    }
  });
} catch (e) { /* ignore registration errors */ }

// attach modular handlers
attachMessageEvents(client);
attachGuildEvents(client);
attachInteractionEvents(client);

client.login(process.env.DISCORD_TOKEN);

```

===== FILE: src/services/economyService.js =====
```javascript
module.exports = require('../../services/economyService');

```

===== FILE: src/services/leaderboardService.js =====
```javascript
module.exports = require('../../services/leaderboardService');

```

===== FILE: src/services/levelingService.js =====
```javascript
module.exports = require('../../services/levelingService');

```

===== FILE: src/services/metricsService.js =====
```javascript
module.exports = require('../../services/metricsService');

```

===== FILE: src/services/scheduleService.js =====
```javascript
module.exports = require('../../services/scheduleService');

```

===== FILE: src/services/statusService.js =====
```javascript
module.exports = require('../../services/statusService');

```

===== FILE: src/utils/activeMenus.js =====
```javascript
module.exports = require('../../utils/activeMenus');

```

===== FILE: src/utils/bank.js =====
```javascript
module.exports = require('../../utils/bank');

```

===== FILE: src/utils/botStatus.js =====
```javascript
module.exports = require('../../utils/botStatus');

```

===== FILE: src/utils/cash.js =====
```javascript
module.exports = require('../../utils/cash');

```

===== FILE: src/utils/cashDrops.js =====
```javascript
module.exports = require('../../utils/cashDrops');

```

===== FILE: src/utils/changelog.js =====
```javascript
module.exports = require('../../utils/changelog');
module.exports = require('../../utils/changelog');

```

===== FILE: src/utils/clockinEmbed.js =====
```javascript
module.exports = require('../../utils/clockinEmbed');

```

===== FILE: src/utils/commandLogger.js =====
```javascript
module.exports = require('../../utils/commandLogger');

```

===== FILE: src/utils/configLogs.js =====
```javascript
module.exports = require('../../utils/configLogs');

```

===== FILE: src/utils/configValidate.js =====
```javascript
module.exports = require('../../utils/configValidate');

```

===== FILE: src/utils/crashReporter.js =====
```javascript
module.exports = require('../../utils/crashReporter');

```

===== FILE: src/utils/depositProgress.js =====
```javascript
module.exports = require('../../utils/depositProgress');

```

===== FILE: src/utils/embeds.js =====
```javascript
module.exports = require('../../utils/embeds');

```

===== FILE: src/utils/ephemeralShim.js =====
```javascript
module.exports = require('../../utils/ephemeralShim');

```

===== FILE: src/utils/errorUtil.js =====
```javascript
module.exports = require('../../utils/errorUtil');

```

===== FILE: src/utils/eventsStorage.js =====
```javascript
module.exports = require('../../utils/eventsStorage');

```

===== FILE: src/utils/health.js =====
```javascript
module.exports = require('../../utils/health');
module.exports = require('../../utils/health');

```

===== FILE: src/utils/index.js =====
```javascript
// Re-export utils from project root for transitional compatibility
module.exports = new Proxy({}, {
  get(_, prop) {
    // allow require('./utils/<name>') from src to map to root utils
    try { return require(`../../utils/${prop}`); } catch {}
    try { return require(`../../utils/${prop}.js`); } catch {}
    // fallback to index
    try { return require(`../../utils/index.js`)[prop]; } catch {}
    throw new Error(`utils module not found: ${String(prop)}`);
  }
});

```

===== FILE: src/utils/leaderboards.js =====
```javascript
module.exports = require('../../utils/leaderboards');

```

===== FILE: src/utils/leveling.js =====
```javascript
module.exports = require('../../utils/leveling');

```

===== FILE: src/utils/levels.js =====
```javascript
module.exports = require('../../utils/levels');

```

===== FILE: src/utils/logChannels.js =====
```javascript
module.exports = require('../../utils/logChannels');

```

===== FILE: src/utils/memberLogs.js =====
```javascript
module.exports = require('../../utils/memberLogs');

```

===== FILE: src/utils/messageLogs.js =====
```javascript
module.exports = require('../../utils/messageLogs');

```

===== FILE: src/utils/modLogs.js =====
```javascript
module.exports = require('../../utils/modLogs');

```

===== FILE: src/utils/paths.js =====
```javascript
module.exports = require('../../utils/paths');

```

===== FILE: src/utils/permissionsCache.js =====
```javascript
module.exports = require('../../utils/permissionsCache');

```

===== FILE: src/utils/policy.js =====
```javascript
module.exports = require('../../utils/policy');

```

===== FILE: src/utils/processHandlers.js =====
```javascript
module.exports = require('../../utils/processHandlers');

```

===== FILE: src/utils/roleLogs.js =====
```javascript
module.exports = require('../../utils/roleLogs');

```

===== FILE: src/utils/sanitize.js =====
```javascript
module.exports = require('../../utils/sanitize');

```

===== FILE: src/utils/scheduleStorage.js =====
```javascript
module.exports = require('../../utils/scheduleStorage');

```

===== FILE: src/utils/scheduler.js =====
```javascript
module.exports = require('../../utils/scheduler');

```

===== FILE: src/utils/sendOnce.js =====
```javascript
module.exports = require('../../utils/sendOnce');

```

===== FILE: src/utils/shutdownState.js =====
```javascript
module.exports = require('../../utils/shutdownState');

```

===== FILE: src/utils/singleton.js =====
```javascript
module.exports = require('../../utils/singleton');

```

===== FILE: src/utils/staffTeam.js =====
```javascript
module.exports = require('../../utils/staffTeam');

```

===== FILE: src/utils/storage.js =====
```javascript
module.exports = require('../../utils/storage');

```

===== FILE: src/utils/testingBanner.js =====
```javascript
module.exports = require('../../utils/testingBanner');

```

===== FILE: src/utils/text.js =====
```javascript
module.exports = require('../../utils/text');

```

===== FILE: src/utils/theme.js =====
```javascript
module.exports = require('../../utils/theme');

```

===== FILE: src/utils/time.js =====
```javascript
module.exports = require('../../utils/time');

```

===== FILE: src/utils/timestampPlaceholders.js =====
```javascript
module.exports = require('../../utils/timestampPlaceholders');

```

===== FILE: src/utils/ui.js =====
```javascript
module.exports = require('../../utils/ui');

```

===== FILE: src/utils/vcLevels.js =====
```javascript
module.exports = require('../../utils/vcLevels');

```

===== FILE: src/utils/voiceLeveling.js =====
```javascript
module.exports = require('../../utils/voiceLeveling');

```

===== FILE: src/utils/writeQueue.js =====
```javascript
module.exports = require('../../utils/writeQueue');

```

===== FILE: tests/clockinMigration.test.js =====
```javascript
const { migrateClockIn } = require('../scripts/migrateClockInCore');

describe('clock-in migration', () => {
  test('adds missing structure', () => {
    const events = [ { id:'1', name:'Event A' } ];
    const updated = migrateClockIn(events);
    expect(updated.length).toBe(1);
    expect(events[0].__clockIn).toBeDefined();
    expect(events[0].__clockIn.positions.instance_manager).toEqual([]);
    expect(events[0].__clockIn.lastSentTs).toBeNull();
  });

  test('does not mark already-normalized event as changed', () => {
    const events = [ { id:'2', name:'Event B', __clockIn:{ positions:{ instance_manager:[], manager:[], bouncer:[], bartender:[], backup:[], maybe:[] }, messageIds:['x'], lastSentTs:123 } } ];
    const updated = migrateClockIn(events);
    expect(updated.length).toBe(0);
  });
});

```

===== FILE: tests/leaderboardCache.test.js =====
```javascript
const { buildLeaderboardEmbed, getEntries } = require('../services/leaderboardService');
const { levels } = require('../services/levelingService');

describe('leaderboardService cache', () => {
  test('Entries stable within TTL', () => {
    levels['u1'] = { xp: 10, level: 1 };
    levels['u2'] = { xp: 20, level: 2 };
    const first = getEntries('text');
    levels['u3'] = { xp: 30, level: 3 }; // mutate after cache
    const second = getEntries('text');
    expect(second).toBe(first); // same reference due to cache TTL
  });
});

```

===== FILE: tests/leveling.test.js =====
```javascript
const { addXP, getLevel, getXP, saveLevels } = require('../utils/levels');

beforeEach(() => {
  // reset in-memory levels (direct access)
  const levelsModule = require('../utils/levels');
  Object.keys(levelsModule.levels).forEach(k => delete levelsModule.levels[k]);
});

describe('Leveling XP curve', () => {
  test('gains XP and levels up eventually', () => {
    const user = 'u1';
    let level = getLevel(user);
    expect(level).toBe(0);
    let totalXP = 0;
    // Pump XP until at least level 2
    for (let i = 0; i < 50 && level < 2; i++) {
      addXP(user, 50);
      level = getLevel(user);
      totalXP = getXP(user);
    }
    expect(level).toBeGreaterThanOrEqual(1);
    expect(totalXP).toBeGreaterThan(0);
  });
});

```

===== FILE: tests/tax.test.js =====
```javascript
const { computeTaxForDeposit, getBaseLimit } = require('../utils/bank');

// Basic tax progression validation

describe('Progressive tax bands', () => {
  test('no tax below base limit', () => {
    const L = getBaseLimit();
    const tax = computeTaxForDeposit(0, L - 1, L);
    expect(tax).toBe(0);
  });

  test('increasing tax in second band', () => {
    const L = getBaseLimit();
    const mid = Math.floor(L / 2);
    const taxLow = computeTaxForDeposit(L, 1, L);
    const taxHigher = computeTaxForDeposit(L, mid, L);
    expect(taxHigher).toBeGreaterThanOrEqual(taxLow);
  });

  test('heavy tax far above 4L', () => {
    const L = getBaseLimit();
    const start = 5 * L; // already above hard band
    const dep = L; // additional deposit
    const tax = computeTaxForDeposit(start, dep, L);
    // At 400% marginal, approximate floor
    expect(tax).toBeGreaterThanOrEqual(dep * 3); // allow some lower due to averaging across bands
  });
});

```

===== FILE: tests/taxEdges.test.js =====
```javascript
const { computeTaxForDeposit } = require('../utils/bank');
const { getBaseLimit } = require('../utils/bank');

describe('Progressive tax edge bands', () => {
  const L = 10000; // We'll stub base limit logic by monkeypatching if needed
  // Instead of altering getBaseLimit globally, we just use direct formula matching bank.js bands.
  function tax(current, deposit) {
    return computeTaxForDeposit(current, deposit, L);
  }

  test('No tax below base limit', () => {
    expect(tax(0, L - 1)).toBe(0);
  });

  test('First dollar over base limit taxed minimally (~0)', () => {
    const t = tax(L - 1, 1); // crossing into band 2
    expect(t).toBeGreaterThanOrEqual(0);
    expect(t).toBeLessThanOrEqual(1); // should be tiny at boundary
  });

  test('Halfway through second band ~0.25 effective', () => {
    const deposit = Math.floor(L / 2); // from L to 1.5L
    const t = tax(L, deposit);
    const eff = t / deposit; // average rate
    expect(eff).toBeGreaterThan(0.05);
    expect(eff).toBeLessThan(0.5);
  });

  test('End of second band ~0.5 marginal', () => {
    const deposit = L; // L to 2L
    const t = tax(L, deposit);
    const eff = t / deposit;
    expect(eff).toBeGreaterThan(0.2);
    expect(eff).toBeLessThanOrEqual(0.5);
  });

  test('Cross into 3rd band shows higher effective than early band 2', () => {
    const deposit = Math.floor(1.1 * L); // from L to 2.1L
    const t = tax(L, deposit);
    const eff = t / deposit;
    // Just assert it's above a minimal threshold ( > 0.2 ) reflecting progression
    expect(eff).toBeGreaterThan(0.2);
  });

  test('End of 3rd band approaches ~1.0 eff marginal start of 4th high', () => {
    const deposit = 2 * L; // L to 3L
    const t = tax(L, deposit);
    const eff = t / deposit;
    expect(eff).toBeGreaterThan(0.4);
    expect(eff).toBeLessThan(1.2);
  });

  test('Fourth band extreme growth then clamp 400%', () => {
    const deposit = 5 * L; // from L to 6L includes into 5th region >4L
    const t = tax(L, deposit);
    const eff = t / deposit;
    expect(eff).toBeGreaterThan(0.5);
  });
});

```

===== FILE: tests/vcLeveling.test.js =====
```javascript
const { getVCXP, getVCLevel, vcLevels } = require('../services/levelingService');
const { addVCXP } = require('../utils/vcLevels');

describe('VC Leveling basic progression', () => {
  const user = 'u_vc';

  test('Initial level 0', () => {
    expect(getVCLevel(user)).toBe(0);
    expect(getVCXP(user)).toBe(0);
  });

  test('Add XP increments', () => {
    const target = 5000; // arbitrary XP to push several levels
    addVCXP(user, target);
    expect(getVCXP(user)).toBeGreaterThanOrEqual(target);
    expect(getVCLevel(user)).toBeGreaterThan(0);
  });
});

```

===== FILE: tests/xpModifier.test.js =====
```javascript
const { handleLeveling, getUserModifier } = require('../services/levelingService');
const levelingUtils = require('../utils/leveling');

// We'll simulate messages to test modifier streak growth & cap.
function mockMessage(userId, channelId = 'c1') {
  return {
    guild: { members: { fetch: async () => ({ roles: { cache: new Map() } }) } },
    channel: { id: channelId },
    author: { id: userId },
    reply: async () => {}
  };
}

describe('XP Modifier streak behavior', () => {
  const user = 'user_mod';
  const originalRandom = Math.random;
  beforeAll(() => {
    Math.random = () => 0; // deterministic lowest XP
  });
  afterAll(() => { Math.random = originalRandom; });

  test('Modifier starts at 1.0 and increases with rapid messages', async () => {
    // First message
    await levelingUtils.handleLeveling(mockMessage(user));
    expect(getUserModifier(user)).toBeCloseTo(1.0, 2);
    // Fast succession within <65s increments streak
    await levelingUtils.handleLeveling(mockMessage(user));
    // Cooldown prevents second grant if under 60s; simulate time advance
    const now = Date.now;
    let fakeNow = Date.now();
    Date.now = () => fakeNow + 61000; // jump 61s to bypass cooldown but within streak window
    await levelingUtils.handleLeveling(mockMessage(user));
    expect(getUserModifier(user)).toBeGreaterThan(1.0);
    Date.now = now; // restore
  });
});

```

===== FILE: utils/activeMenus.js =====
```javascript
const fs = require("fs");
const path = require("path");
const { cfgPath } = require('./paths');

const SESSIONS_FILE = cfgPath('buttonSessions.json');

// Handlers by session.type
const handlers = new Map();
// Sessions in memory keyed by messageId
const sessions = new Map();
// Timers by messageId
const timers = new Map();

// Build a single disabled "Timed out — use command again" row
function timeoutRow() {
  return [{
    type: 1,
    components: [{
      type: 2,
      custom_id: "timeout",
      label: "Timed out — use command again",
      style: 2,
      disabled: true
    }]
  }];
}

function loadSessions() {
  try {
    if (!fs.existsSync(SESSIONS_FILE)) return {};
    return JSON.parse(fs.readFileSync(SESSIONS_FILE, "utf8")) || {};
  } catch { return {}; }
}

function saveSessions() {
  try {
    const obj = {};
    for (const [messageId, s] of sessions.entries()) {
      obj[messageId] = { ...s, // strip functions/timers
        // keep only serializable data
        client: undefined
      };
    }
    const dir = path.dirname(SESSIONS_FILE);
    if (!fs.existsSync(dir)) fs.mkdirSync(dir, { recursive: true });
    fs.writeFileSync(SESSIONS_FILE, JSON.stringify(obj, null, 2));
  } catch {}
}

function scheduleTimer(client, messageId) {
  const existing = timers.get(messageId);
  if (existing) clearTimeout(existing);
  const s = sessions.get(messageId);
  if (!s) return;

  const delay = Math.max(0, s.expiresAt - Date.now());
  const t = setTimeout(async () => {
    timers.delete(messageId);
    // If still present and expired, disable the UI
    const sess = sessions.get(messageId);
    if (!sess || Date.now() < sess.expiresAt) return;

    try {
      const channel = await client.channels.fetch(sess.channelId).catch(() => null);
      const msg = channel ? await channel.messages.fetch(messageId).catch(() => null) : null;
      if (msg) await msg.edit({ components: timeoutRow() }).catch(() => {});
    } finally {
      sessions.delete(messageId);
      saveSessions();
    }
  }, delay);
  if (typeof t.unref === "function") t.unref();
  timers.set(messageId, t);
}

async function init(client) {
  // Load persisted sessions and disable any already-expired UIs
  const raw = loadSessions();
  for (const [messageId, s] of Object.entries(raw)) {
    const expired = !s.expiresAt || s.expiresAt <= Date.now();
    sessions.set(messageId, { ...s });
    if (expired) {
      // Best-effort disable
      try {
        const channel = await client.channels.fetch(s.channelId).catch(() => null);
        const msg = channel ? await channel.messages.fetch(messageId).catch(() => null) : null;
        if (msg) await msg.edit({ components: timeoutRow() }).catch(() => {});
      } catch {}
      sessions.delete(messageId);
    } else {
      scheduleTimer(client, messageId);
    }
  }
  saveSessions();
}

function registerHandler(type, fn) {
  handlers.set(type, fn);
}

function registerMessage(message, session) {
  const expiresAt = Date.now() + 5 * 60 * 1000;
  sessions.set(message.id, {
    type: session.type,
    userId: session.userId || null,
    guildId: message.guildId || null,
    channelId: message.channelId,
    expiresAt,
    data: session.data || {}
  });
  saveSessions();
  // schedule when client attached via processInteraction
}

function snapshotSessions() {
  const out = [];
  for (const [id, s] of sessions.entries()) {
    out.push({ id, type: s.type, userId: s.userId, channelId: s.channelId, expiresIn: s.expiresAt - Date.now() });
  }
  return out.sort((a,b)=>a.expiresIn - b.expiresIn);
}

// Sweep and disable orphaned sessions older than 1h beyond expiry
async function sweepOrphans(client) {
  try {
    const cutoff = Date.now() - 60 * 60 * 1000;
    for (const [id, sess] of sessions.entries()) {
      if (sess.expiresAt < cutoff) {
        try {
          const channel = await client.channels.fetch(sess.channelId).catch(()=>null);
          const msg = channel ? await channel.messages.fetch(id).catch(()=>null) : null;
          if (msg) await msg.edit({ components: timeoutRow() }).catch(()=>{});
        } catch {}
        sessions.delete(id);
      }
    }
    saveSessions();
  } catch {}
}

async function processInteraction(interaction) {
  const messageId = interaction.message?.id;
  if (!messageId) return { handled: false };

  const sess = sessions.get(messageId);
  if (!sess) {
    // Exemption: allow certain global/permanent buttons to function forever without being force-disabled
    // Currently needed for event notification signup buttons (custom_id starts with 'event_notify_').
    if (interaction.isButton && interaction.isButton() && interaction.customId && interaction.customId.startsWith('event_notify_')) {
      return { handled: false }; // let upstream interaction handler process it; do NOT timeout
    }
    // If message is older than 5 minutes AND was originally a managed session, we would normally disable it.
    // Since we don't have a session record, conservatively leave it alone to avoid breaking long-lived utility buttons.
    // (Previous behavior force-disabled ANY unknown older message.)
    return { handled: false };
  }

  // Expired? disable and stop
  if (Date.now() > sess.expiresAt) {
    try {
      if (interaction.isRepliable() && !interaction.replied && !interaction.deferred) {
        await interaction.update({ components: timeoutRow() });
      } else {
        const channel = await interaction.client.channels.fetch(sess.channelId).catch(() => null);
        const msg = channel ? await channel.messages.fetch(messageId).catch(() => null) : null;
        if (msg) await msg.edit({ components: timeoutRow() }).catch(() => {});
      }
    } catch {}
    sessions.delete(messageId);
    saveSessions();
    return { handled: true };
  }

  // Renew window on every press
  sess.expiresAt = Date.now() + 5 * 60 * 1000;
  sessions.set(messageId, sess);
  saveSessions();
  scheduleTimer(interaction.client, messageId);

  // Route to handler
  const fn = handlers.get(sess.type);
  if (!fn) return { handled: false };
  await fn(interaction, { ...sess, id: messageId });
  return { handled: true };
}

module.exports = {
  init,
  registerHandler,
  registerMessage,
  processInteraction,
  snapshotSessions,
  sweepOrphans,
  // expose standardized timeout row for other ephemeral collectors
  timeoutRow
};

```

===== FILE: utils/bank.js =====
```javascript
const fs = require("fs");
const path = require("path");
const { cfgPath } = require('./paths');
const { getCash, addCash, getTestingCash, addTestingCash } = require("./cash");
const { config } = require("./storage");

const BANK_FILE = cfgPath('bank.json');
const { enqueueWrite } = require('./writeQueue');

// Persistent bank balances
let bank = {};
// Testing overlay (persisted separately) mirrors shape { userId: { amount } }
const TEST_BANK_FILE = cfgPath('testingBank.json');
let testingBank = {};
try {
  if (fs.existsSync(TEST_BANK_FILE)) {
    testingBank = JSON.parse(fs.readFileSync(TEST_BANK_FILE, "utf8") || "{}");
  }
} catch { testingBank = {}; }
try {
  if (fs.existsSync(BANK_FILE)) {
    const raw = fs.readFileSync(BANK_FILE, "utf8");
    bank = JSON.parse(raw || "{}");
  }
} catch {
  bank = {};
}

function scheduleSave() {
  enqueueWrite(BANK_FILE, () => JSON.stringify(bank, null, 2), { delay: 200 });
}

function getBaseLimit() {
  // Base threshold unit for soft caps and taxes
  const v = config?.bank?.baseLimit ?? 10000;
  const n = Math.max(0, Math.floor(Number(v) || 10000));
  return n || 10000;
}

function getBank(userId) {
  userId = String(userId);
  const { config } = require("./storage");
  if (config.testingMode) {
    return Math.max(0, Math.floor(testingBank[userId]?.amount || 0));
  }
  return Math.max(0, Math.floor(bank[userId] || 0));
}

function setBank(userId, amount) {
  userId = String(userId);
  const n = Math.max(0, Math.floor(Number(amount) || 0));
  const { config } = require("./storage");
  if (config.testingMode) {
    testingBank[userId] = { amount: n };
  // Persist testing overlay immediately (separate quick write)
  try { enqueueWrite(TEST_BANK_FILE, () => JSON.stringify(testingBank, null, 2)); } catch {}
    return n;
  }
  bank[userId] = n;
  scheduleSave();
  return n;
}

function addBank(userId, delta) {
  userId = String(userId);
  const cur = getBank(userId);
  return setBank(userId, cur + Math.floor(Number(delta) || 0));
}

// Progressive tax across bands relative to base limit L
// Bands: [0..L): 0%; [L..2L): 0%->50%; [2L..3L): 50%->100%; [3L..4L): 100%->400%; [4L..inf): 400%
function marginalTaxRate(balanceAfter, L) {
  const R = balanceAfter / L; // ratio
  if (R <= 1) return 0;
  if (R <= 2) return 0.5 * (R - 1); // 0 -> 0.5
  if (R <= 3) return 0.5 + 0.5 * (R - 2); // 0.5 -> 1.0
  if (R <= 4) return 1.0 + 3.0 * (R - 3); // 1.0 -> 4.0
  return 4.0; // 400% above 4L
}

function computeTaxForDeposit(currentBank, deposit, L) {
  if (deposit <= 0) return 0;
  let remaining = deposit;
  let cur = currentBank;
  let tax = 0;
  const bandEdges = [0, L, 2 * L, 3 * L, 4 * L];

  // Helper to compute tax over a small segment [cur, cur+seg]
  const segmentTax = (start, segLen) => {
    const end = start + segLen;
    // Average of marginal rate at start and end (linear within bands by our definition)
    const r1 = marginalTaxRate(start, L);
    const r2 = marginalTaxRate(end, L);
    return segLen * (r1 + r2) / 2;
  };

  // Iterate bands up to 4L
  for (let i = 0; i < bandEdges.length - 1 && remaining > 0; i++) {
    const bandEnd = bandEdges[i + 1];
    if (cur >= bandEnd) continue;
    const canFill = Math.max(0, Math.min(remaining, bandEnd - cur));
    if (canFill > 0) {
      tax += segmentTax(cur, canFill);
      cur += canFill;
      remaining -= canFill;
    }
  }
  // If remaining beyond 4L, flat 400% tax
  if (remaining > 0) {
    tax += remaining * 4.0;
  }
  return Math.max(0, Math.floor(tax));
}

function computeNextThreshold(currentBank, L) {
  const k = Math.floor(currentBank / L);
  return (k + 1) * L;
}

// Determine the maximum deposit such that deposit + tax(deposit) <= available cash
function computeMaxAffordableDeposit(userId) {
  const uid = String(userId);
  const L = getBaseLimit();
  const bankBal = getBank(uid);
  const cash = config.testingMode ? getTestingCash(uid) : getCash(uid);
  if (cash <= 0) return { deposit: 0, tax: 0, totalCost: 0 };
  let lo = 0, hi = cash, ans = 0;
  while (lo <= hi) {
    const mid = Math.floor((lo + hi) / 2);
    const tax = computeTaxForDeposit(bankBal, mid, L);
    const total = mid + tax;
    if (total <= cash) { ans = mid; lo = mid + 1; } else { hi = mid - 1; }
  }
  const tax = computeTaxForDeposit(bankBal, ans, L);
  return { deposit: ans, tax, totalCost: ans + tax, bankAfter: bankBal + ans, baseLimit: L };
}

// Quote a deposit: how much tax, total cost, whether confirmation is recommended
function quoteDeposit(userId, amount) {
  const uid = String(userId);
  const L = getBaseLimit();
  const bankBal = getBank(uid);
  const deposit = Math.max(0, Math.floor(Number(amount) || 0));
  const tax = computeTaxForDeposit(bankBal, deposit, L);
  const totalCost = deposit + tax;
  const newBank = bankBal + deposit;
  const nextThreshold = computeNextThreshold(bankBal, L);
  const crossesSoftCap = bankBal < L && newBank > L;
  const alreadyAbove = bankBal >= L;
  const requiresConfirmation = crossesSoftCap || alreadyAbove;
  const activeCash = (config.testingMode ? getTestingCash(uid) : getCash(uid));
  return { ok: deposit > 0, deposit, tax, totalCost, newBank, bank: newBank, cashAfter: activeCash - totalCost, baseLimit: L, nextThreshold, requiresConfirmation };
}

// Compute amount to reach next threshold (no wallet check here)
function amountToNextThreshold(userId) {
  const uid = String(userId);
  const L = getBaseLimit();
  const bankBal = getBank(uid);
  const target = computeNextThreshold(bankBal, L);
  const needed = Math.max(0, target - bankBal);
  return { needed, target, baseLimit: L };
}

// Execute a deposit. If allowAboveLimit=false and confirmation would be needed, return a preview requiring confirmation.
function depositToBank(userId, amount, { allowAboveLimit = false } = {}) {
  const uid = String(userId);
  const cash = config.testingMode ? getTestingCash(uid) : getCash(uid);
  const q = quoteDeposit(uid, amount);
  if (!q.ok) return { ok: false, error: "Enter a valid positive amount." };
  if (!allowAboveLimit && q.requiresConfirmation) {
    return { ok: false, requiresConfirmation: true, quote: q };
  }
  if (cash < q.totalCost) {
    return { ok: false, error: "You don't have enough cash for this deposit and tax." };
  }
  // Apply
  if (config.testingMode) addTestingCash(uid, -q.totalCost); else addCash(uid, -q.totalCost);
  addBank(uid, q.deposit);
  const newCash = config.testingMode ? getTestingCash(uid) : getCash(uid);
  return { ok: true, moved: q.deposit, tax: q.tax, totalCost: q.totalCost, cash: newCash, bank: getBank(uid), baseLimit: q.baseLimit };
}

function withdrawFromBank(userId, amount) {
  const uid = String(userId);
  const amt = Math.max(0, Math.floor(Number(amount) || 0));
  const cur = getBank(uid);
  if (amt <= 0) return { ok: false, error: "Enter a valid positive amount." };
  if (amt > cur) return { ok: false, error: "You don't have that much in the bank." };
  addBank(uid, -amt);
  if (config.testingMode) addTestingCash(uid, amt); else addCash(uid, amt);
  const newCash = config.testingMode ? getTestingCash(uid) : getCash(uid);
  return { ok: true, moved: amt, cash: newCash, bank: getBank(uid), baseLimit: getBaseLimit() };
}

function getTopBank(limit = 10) {
  const entries = Object.entries(bank || {}).map(([userId, amount]) => ({ userId, amount: Math.max(0, Math.floor(Number(amount) || 0)) }));
  entries.sort((a, b) => b.amount - a.amount);
  return entries.slice(0, Math.max(0, Math.floor(limit || 10)));
}

module.exports = {
  getBank,
  setBank,
  addBank,
  getBaseLimit,
  quoteDeposit,
  amountToNextThreshold,
  depositToBank,
  withdrawFromBank,
  getTopBank,
  computeTaxForDeposit,
  computeMaxAffordableDeposit,
};

```

===== FILE: utils/botStatus.js =====
```javascript
// Backwards-compatible thin wrappers over the new status service.
const service = require('../services/statusService');

async function sendBotStatusMessage(client) { return service.postStartup(client); }
async function sendBotShutdownMessage(client) { return service.postShutdown(client); }
async function setStatusChannelName(client, online) { return service.updateStatusChannelName(client, online); }

module.exports = { sendBotStatusMessage, sendBotShutdownMessage, setStatusChannelName };

```

===== FILE: utils/cash.js =====
```javascript
const fs = require("fs");
const path = require("path");
const { cfgPath } = require('./paths');

const CASH_FILE = cfgPath('cash.json');
const { enqueueWrite } = require('./writeQueue');

let cash = {};
try {
  if (fs.existsSync(CASH_FILE)) {
    try { cash = JSON.parse(fs.readFileSync(CASH_FILE, "utf8")); } catch { cash = {}; }
  }
} catch {
  cash = {};
}

// Testing overlay balances (persisted separately)
const TEST_CASH_FILE = cfgPath('testingCash.json');
let testingCash = {};
try {
  if (fs.existsSync(TEST_CASH_FILE)) {
    testingCash = JSON.parse(fs.readFileSync(TEST_CASH_FILE, "utf8") || "{}");
  }
} catch { testingCash = {}; }

function scheduleSave() {
  enqueueWrite(CASH_FILE, () => JSON.stringify(cash, null, 2));
}

function getCash(userId) {
  return Math.max(0, Number(cash[userId]?.amount || 0));
}

function setCash(userId, amount) {
  const amt = Math.max(0, Math.floor(Number(amount) || 0));
  cash[userId] = { amount: amt };
  scheduleSave();
  return amt;
}

function addCash(userId, delta) {
  const cur = getCash(userId);
  const next = Math.max(0, cur + Math.floor(Number(delta) || 0));
  return setCash(userId, next);
}

function getTopCash(limit = 10) {
  const entries = Object.entries(cash).map(([id, v]) => ({ id, amount: Math.max(0, Number(v?.amount || 0)) }));
  entries.sort((a, b) => b.amount - a.amount);
  return entries.slice(0, limit);
}

function formatCash(amount) {
  const n = Math.max(0, Math.floor(Number(amount) || 0));
  return `${n}💵`;
}

// Testing helpers (not persisted)
function getTestingCash(userId) {
  return Math.max(0, Number(testingCash[userId]?.amount || 0));
}

function addTestingCash(userId, delta) {
  const cur = getTestingCash(userId);
  const next = Math.max(0, cur + Math.floor(Number(delta) || 0));
  testingCash[userId] = { amount: next };
  try { enqueueWrite(TEST_CASH_FILE, () => JSON.stringify(testingCash, null, 2)); } catch {}
  return next;
}

function clearTestingCash() {
  testingCash = {};
  try { enqueueWrite(TEST_CASH_FILE, () => JSON.stringify(testingCash, null, 2)); } catch {}
}

module.exports = {
  cash,
  getCash,
  setCash,
  addCash,
  getTopCash,
  formatCash,
  // testing overlay
  getTestingCash,
  addTestingCash,
  clearTestingCash,
};

```

===== FILE: utils/cashDrops.js =====
```javascript
const { addCash, addTestingCash } = require("./cash");
const { config } = require("./storage");
const { TEST_LOG_CHANNEL } = require("./logChannels");

// Simple in-memory drop store per channel
// channelId -> { amount, word, createdAt, expiresAt, claimedBy, testing?: boolean }
const activeDrops = new Map();

// Fun claim words list
const FUN_WORDS = [
  "mochi", "uwu", "sparkle", "vibes", "zoomies", "bonk", "boba", "pudding", "noot", "boop",
  "meow", "purr", "senpai", "neko", "comfy", "snacc", "pog", "yeet", "glow", "shiny",
  "cosmic", "starlit", "sprout", "cozy", "sugar", "sprinkle", "waffle", "pancake", "taco", "nugget",
  "gizmo", "pebble", "bean", "blossom", "bubbles", "crunch", "bling", "zesty", "pep", "swirl",
  "spark", "fizz", "whisk", "minty", "sunny", "honey", "echo", "nova", "ripple", "plush"
];

function pickFunWord() {
  return FUN_WORDS[Math.floor(Math.random() * FUN_WORDS.length)];
}

function randomInt(min, max) {
  return Math.floor(Math.random() * (max - min + 1)) + min;
}

function maybeSpawnDrop(message) {
  // Only in guild text channels; obey leveling channel mode as a reasonable proxy
  if (!message.guild || !message.channel || message.author.bot) return null;
  const channelId = message.channel.id;
  // Respect blacklist/whitelist leveling mode
  const mode = config.levelingMode || "blacklist";
  const list = config.levelingChannelList || [];
  if (mode === "blacklist" && list.includes(channelId)) return null;
  if (mode === "whitelist" && !list.includes(channelId)) return null;

  // Don't spawn if a drop is already active in the channel
  const existing = activeDrops.get(channelId);
  if (existing && !existing.claimedBy && existing.expiresAt > Date.now()) return null;

  const e = config.cashDrops || {};
  const chance = typeof e.dropChance === 'number' ? e.dropChance : 0.02;
  if (Math.random() > chance) return null;

  const min = Math.max(0, Math.floor(e.minAmount ?? 25));
  const max = Math.max(min, Math.floor(e.maxAmount ?? 125));
  const amount = randomInt(min, max);
  const now = Date.now();
  const life = Math.max(5000, Math.floor(e.lifetimeMs ?? 60000));
  const word = pickFunWord();
  const drop = { amount, word, createdAt: now, expiresAt: now + life, claimedBy: null };
  activeDrops.set(channelId, drop);
  return drop;
}

function normalizeContent(s) {
  if (!s) return "";
  return String(s).trim().toLowerCase().replace(/^`+|`+$/g, '').replace(/^"+|"+$/g, '');
}

function tryClaimDrop(message) {
  if (!message.guild || !message.channel || message.author.bot) return null;
  const channelId = message.channel.id;
  const drop = activeDrops.get(channelId);
  if (!drop) return null;
  if (drop.claimedBy) return null;
  if (drop.expiresAt <= Date.now()) {
    activeDrops.delete(channelId);
    return null;
  }
  // Require the user to type the correct fun word to claim
  const content = normalizeContent(message.content);
  if (!content || content !== String(drop.word || "").toLowerCase()) {
    return null; // incorrect message, no claim
  }
  drop.claimedBy = message.author.id;
  activeDrops.set(channelId, drop);
  if (drop.testing) {
    const newBal = addTestingCash(message.author.id, drop.amount);
    return { amount: drop.amount, newBalance: newBal, testing: true };
  }
  const newBal = addCash(message.author.id, drop.amount);
  return { amount: drop.amount, newBalance: newBal };
}

// Explicit test drop spawner for the test channel; does not affect real balances
function spawnTestDrop(amount) {
  const channelId = TEST_LOG_CHANNEL;
  const now = Date.now();
  const e = config.cashDrops || {};
  const life = Math.max(5000, Math.floor(e.lifetimeMs ?? 60000));
  const amt = Math.max(1, Math.floor(Number(amount) || Math.max(0, Math.floor(e.minAmount ?? 25))));
  const word = pickFunWord();
  const drop = { amount: amt, word, createdAt: now, expiresAt: now + life, claimedBy: null, testing: true };
  activeDrops.set(channelId, drop);
  return drop;
}

function cleanupExpiredDrops() {
  const now = Date.now();
  for (const [cid, drop] of activeDrops.entries()) {
    if (drop.expiresAt <= now || drop.claimedBy) {
      activeDrops.delete(cid);
    }
  }
}

let interval = null;
function startCashDrops() {
  if (interval) return;
  interval = setInterval(cleanupExpiredDrops, 30 * 1000);
  if (typeof interval.unref === "function") interval.unref();
}

module.exports = {
  startCashDrops,
  maybeSpawnDrop,
  tryClaimDrop,
  spawnTestDrop,
  activeDrops,
};

```

===== FILE: utils/changelog.js =====
```javascript
const fs = require("fs");
const path = require("path");
const { cfgPath } = require('./paths');
const crypto = require("crypto");
const { createEmbed } = require('./embeds');

const SNAPSHOT_FILE = cfgPath('changelogSnapshot.json');

function sha1(buf) {
  return crypto.createHash("sha1").update(buf).digest("hex");
}

function walkDir(dir, fileList = []) {
  const entries = fs.readdirSync(dir, { withFileTypes: true });
  for (const entry of entries) {
    const full = path.join(dir, entry.name);
    // Ignore noisy or external folders
    if (entry.isDirectory()) {
      if (["node_modules", ".git", ".vscode", "scripts"].includes(entry.name)) continue;
      walkDir(full, fileList);
    } else {
      // Only include code files; skip JSON configs which change frequently
  const rel = path.relative(path.resolve(__dirname, ".."), full).replace(/\\/g, "/");
      const ext = path.extname(entry.name).toLowerCase();
      const isCode = [".js", ".ts", ".mjs", ".cjs"].includes(ext);
      const isConfigJson = rel.startsWith("config/") && ext === ".json";
      if (!isCode || isConfigJson) continue;
      fileList.push(rel);
    }
  }
  return fileList;
}

function createSnapshot(rootDir) {
  const base = path.resolve(rootDir);
  const files = walkDir(base);
  const snap = {};
  for (const rel of files) {
    try {
      const abs = path.join(base, rel);
      const buf = fs.readFileSync(abs);
      const content = buf.toString("utf8");
      snap[rel] = {
        hash: sha1(buf),
        bytes: buf.length,
        lines: content.split(/\r?\n/).length,
      };
    } catch {}
  }
  return snap;
}

function loadSnapshot() {
  try {
    if (fs.existsSync(SNAPSHOT_FILE)) {
      return JSON.parse(fs.readFileSync(SNAPSHOT_FILE, "utf8"));
    }
  } catch {}
  return null;
}

function saveSnapshot(snap) {
  try {
    const dir = path.dirname(SNAPSHOT_FILE);
    if (!fs.existsSync(dir)) fs.mkdirSync(dir, { recursive: true });
    fs.writeFileSync(SNAPSHOT_FILE, JSON.stringify({ createdAt: Date.now(), files: snap }, null, 2));
  } catch {}
}

function compareSnapshots(prev, curr) {
  const added = [];
  const removed = [];
  const modified = [];
  const prevFiles = prev ? prev.files || {} : {};
  const currFiles = curr || {};

  const prevKeys = new Set(Object.keys(prevFiles));
  const currKeys = new Set(Object.keys(currFiles));

  for (const k of currKeys) {
    if (!prevKeys.has(k)) {
      added.push({ path: k, meta: currFiles[k] });
    } else if (prevFiles[k].hash !== currFiles[k].hash) {
      const a = prevFiles[k];
      const b = currFiles[k];
      modified.push({
        path: k,
        linesDelta: (b.lines || 0) - (a.lines || 0),
        bytesDelta: (b.bytes || 0) - (a.bytes || 0),
      });
    }
  }
  for (const k of prevKeys) {
    if (!currKeys.has(k)) removed.push({ path: k, meta: prevFiles[k] });
  }

  return { added, removed, modified };
}

function formatBytes(n) {
  const sign = n < 0 ? "-" : "+";
  const abs = Math.abs(n);
  if (abs < 1024) return `${sign}${abs} B`;
  if (abs < 1024 * 1024) return `${sign}${(abs / 1024).toFixed(1)} KB`;
  return `${sign}${(abs / (1024 * 1024)).toFixed(2)} MB`;
}

function buildChangelogEmbed(result) {
  const { added, removed, modified } = result;
  const total = added.length + removed.length + modified.length;
  const embed = createEmbed({
    title: "📜 Changelog since last start",
    color: 0x00b894
  });

  if (total === 0) {
    embed.setDescription("No code changes detected.");
    return embed;
  }

  embed.setDescription(
    `Files changed: ${total} (➕ ${added.length}, ✖️ ${removed.length}, 🔧 ${modified.length})\n` +
    "Showing up to 15 entries."
  );

  const lines = [];
  for (const it of added.slice(0, 5)) lines.push(`➕ ${it.path}`);
  for (const it of removed.slice(0, 5)) lines.push(`✖️ ${it.path}`);
  for (const it of modified.slice(0, 5)) {
    const ld = it.linesDelta === 0 ? "±0" : (it.linesDelta > 0 ? `+${it.linesDelta}` : `${it.linesDelta}`);
    lines.push(`🔧 ${it.path} (${ld} lines, ${formatBytes(it.bytesDelta)})`);
  }
  if (lines.length > 0) embed.addFields({ name: "Changes", value: lines.join("\n").slice(0, 1024) });

  const more = total - Math.min(5, added.length) - Math.min(5, removed.length) - Math.min(5, modified.length);
  if (more > 0) embed.addFields({ name: "More", value: `…and ${more} more file(s).` });

  return embed;
}

async function postStartupChangelog(client, channelId, rootDir = path.resolve(__dirname, "..")) {
  const prev = loadSnapshot();
  const currentFiles = createSnapshot(rootDir);
  const result = compareSnapshots(prev, currentFiles);

  // Save new snapshot early to avoid duplicate diffs on crash; still post based on 'result'
  saveSnapshot(currentFiles);

  // Skip noise-only changes: none by default
  const total = result.added.length + result.removed.length + result.modified.length;
  if (total === 0) return;

  const channel = await client.channels.fetch(channelId).catch(() => null);
  if (!channel) return;

  const embed = buildChangelogEmbed(result);
  await channel.send({ embeds: [embed] }).catch(() => {});
}

module.exports = {
  postStartupChangelog,
  // Exported for potential testing
  createSnapshot,
  compareSnapshots,
  buildChangelogEmbed,
};

```

===== FILE: utils/clockinEmbed.js =====
```javascript
// Unified "Staff Clock-In" embed renderer to keep styling consistent and compact
// across scheduler auto-messages, manual triggers, and interaction updates.
// Preserves existing logic and IDs; only presentation is improved.

const { createEmbed, safeAddField } = require('./embeds');
const theme = require('./theme');
const { computeNextRange } = require('./timestampPlaceholders');

// Standard role meta used for consistent labeling/emojis
const ROLE_META = {
  instance_manager: { label: 'Instance Manager', emoji: '📝' },
  manager:          { label: 'Manager',          emoji: '🛠️' },
  bouncer:          { label: 'Bouncer',          emoji: '🛡️' },
  bartender:        { label: 'Bartender',        emoji: '🍸' },
  backup:           { label: 'Backup',           emoji: '🎯' },
  maybe:            { label: 'Maybe/Late',       emoji: '⏳' }
};

// Build a tiny capacity bar using simple squares for broad device support
// length=5 cells, using ■ (filled) and □ (empty)
function capacityBar(count, cap, cells = 5) {
  if (!cap || cap <= 0) return null;
  const pct = Math.max(0, Math.min(1, count / cap));
  const filled = Math.max(0, Math.min(cells, Math.round(pct * cells)));
  return '■'.repeat(filled) + '□'.repeat(cells - filled);
}

// Build the embed. arguments:
// - ev: event object (name, times/ranges for footer)
// - positions: { [roleKey]: string[] userIds }
// - capacities: { [roleKey]: number|undefined } optional caps per role
// - options: { compact?: boolean }
function buildClockInEmbed(ev, positions = {}, capacities = {}, options = {}) {
  const name = ev?.name || 'Event';
  const color = theme.colors?.primary || 0x5865F2;
  const title = `🕒 Staff Clock-In — ${name}`;
  const description = 'Select your role from the menu. One slot per staff. Updates apply instantly.';

  const embed = createEmbed({ title, description, color, timestamp: true });

  const order = ['instance_manager','manager','bouncer','bartender','backup','maybe'];
  for (const key of order) {
    const meta = ROLE_META[key] || { label: key, emoji: '' };
    const arr = Array.isArray(positions[key]) ? positions[key] : [];
    const cap = Number.isFinite(capacities[key]) ? Number(capacities[key]) : null;
    const count = arr.length;
    const countText = cap ? `${count}/${cap}` : `${count}`;
    const fieldName = `${meta.emoji ? meta.emoji+ ' ' : ''}${meta.label} (${countText})`;
    const mentions = count ? arr.map(id => `<@${id}>`).join(', ').slice(0, 1024) : '—';
    const bar = cap ? capacityBar(count, cap) : null;
    const fieldValue = bar ? `${bar}\n${mentions}` : mentions;
    safeAddField(embed, fieldName, fieldValue, true);
  }

  // Footer with dynamic timing info (starts/ends) if known
  try {
    const r = computeNextRange(ev);
    const now = Date.now() / 1000;
    if (r && r.startSec && r.endSec) {
      let footer = `Event: ${name}`;
      if (now < r.startSec) footer = `${footer} • Starts <t:${r.startSec}:R>`;
      else if (now >= r.startSec && now < r.endSec) footer = `${footer} • Ends <t:${r.endSec}:t>`;
      embed.setFooter({ text: footer });
    } else {
      embed.setFooter({ text: `Event: ${name}` });
    }
  } catch {
    embed.setFooter({ text: `Event: ${name}` });
  }

  return embed;
}

module.exports = { buildClockInEmbed, ROLE_META };

```

===== FILE: utils/commandLogger.js =====
```javascript
// In-memory + file-based command logger with optional channel reporting and expected vs actual diffing
const { config } = require('./storage');
const { CONFIG_LOG_CHANNEL } = require('./logChannels');
const fs = require('fs');
const path = require('path');

const LOG_DIR = path.join(__dirname, '..', 'logs');
const LOG_FILE = path.join(LOG_DIR, 'command_logs.json');

const state = {
  logs: [],
  lastSendTs: 0,
};

function getLimit() {
  const cfg = config.commandLogging || {};
  const max = Number(cfg.maxEntries); return Number.isFinite(max) && max > 0 ? Math.min(max, 5000) : 500;
}

function enabled() {
  const cfg = config.commandLogging || {};
  // Enabled by default; allow opt-out via config.commandLogging.enabled === false
  return cfg.enabled !== false;
}

function add(log) {
  if (!enabled()) return;
  const limit = getLimit();
  state.logs.push(log);
  if (state.logs.length > limit) state.logs.splice(0, state.logs.length - limit);
}

function start(ctx) {
  if (!enabled()) return null;
  const now = Date.now();
  return {
    id: `${ctx.name}:${ctx.userId}:${now}`,
    t0: now,
    ...ctx,
  };
}

function finish(client, startCtx, result) {
  if (!enabled() || !startCtx) return;
  const dt = Date.now() - (startCtx.t0 || Date.now());
  const entry = {
    ts: Date.now(),
    dt,
    ...startCtx,
    ...result,
  };
  add(entry);
  maybeReport(client, entry);
  persist(entry);
}

function sanitizeString(s) {
  try {
    if (!s || typeof s !== 'string') return s;
    // Redact token-like strings: long base64ish strings
    let out = s.replace(/[A-Za-z0-9_\-]{24,}/g, '[redacted]');
    // Remove common secrets keys if present (defense-in-depth)
    out = out.replace(/(token|apikey|api_key|authorization)\s*[:=]\s*[^\s]+/ig, '$1: [redacted]');
    return out;
  } catch { return s; }
}

function mapEmbeds(embeds) {
  try {
    if (!Array.isArray(embeds)) return [];
    return embeds.map(e => {
      const raw = typeof e?.toJSON === 'function' ? e.toJSON() : e;
      // Shallow sanitize content-like fields
      const safe = {};
      for (const [k, v] of Object.entries(raw || {})) {
        if (typeof v === 'string') safe[k] = sanitizeString(v).slice(0, 4000);
        else safe[k] = v;
      }
      return safe;
    });
  } catch { return []; }
}

function mapComponents(components) {
  try {
    if (!Array.isArray(components)) return [];
    // Keep a summarised but useful shape
    return components.map(row => {
      const comps = Array.isArray(row?.components) ? row.components : (row?.data?.components || []);
      return {
        type: row?.type || row?.data?.type || 'row',
        components: comps.map(c => ({
          type: c?.type || c?.data?.type,
          custom_id: c?.customId || c?.data?.custom_id,
          label: c?.label || c?.data?.label,
          style: c?.style || c?.data?.style,
          disabled: !!(c?.disabled || c?.data?.disabled),
        }))
      };
    });
  } catch { return []; }
}

function normalizeMsgShape(msg) {
  if (!msg) return null;
  const embeds = Array.isArray(msg.embeds) ? msg.embeds : (msg.embeds ? [msg.embeds] : []);
  const comps = Array.isArray(msg.components) ? msg.components : [];
  return {
    id: msg.id,
    type: 'message',
    content: sanitizeString((msg.content || '')).slice(0, 1800),
    embeds: mapEmbeds(embeds),
    components: mapComponents(comps),
    embedsCount: embeds.length,
    componentsCount: comps.length,
  };
}

function diffExpected(actual, expected) {
  if (!expected || !actual) return null;
  try {
    const diffs = [];
    if (typeof expected.content === 'string') {
      const a = (actual.content || '').trim(); const e = expected.content.trim();
      if (e && a !== e) diffs.push(`content mismatch`);
    }
    if (typeof expected.embedsCount === 'number') {
      if ((actual.embedsCount || 0) !== expected.embedsCount) diffs.push(`embedsCount ${actual.embedsCount} != ${expected.embedsCount}`);
    }
    if (typeof expected.componentsCount === 'number') {
      if ((actual.componentsCount || 0) !== expected.componentsCount) diffs.push(`componentsCount ${actual.componentsCount} != ${expected.componentsCount}`);
    }
    return diffs.length ? diffs : null;
  } catch { return null; }
}

async function maybeReport(client, entry) {
  try {
    const cfg = config.commandLogging || {};
    if (!cfg.sendToChannel && !cfg.testingCompare) return;
    // Only send if diff in testing mode, or explicit sendToChannel enabled
    const want = (config.testingMode && cfg.testingCompare && entry.diff) || cfg.sendToChannel;
    if (!want) return;
    const now = Date.now();
    const minGap = Number(cfg.sendIntervalMs) || 5000;
    if (now - state.lastSendTs < minGap) return; // rate-limit
    state.lastSendTs = now;
    const channelId = cfg.logChannelId || CONFIG_LOG_CHANNEL;
    if (!channelId) return;
    const ch = await client.channels.fetch(channelId).catch(()=>null);
    if (!ch || !ch.send) return;
    const parts = [];
    parts.push(`🧪 Cmd: ${entry.name} • by <@${entry.userId}> in <#${entry.channelId}> • ${entry.dt}ms`);
    if (entry.diff && entry.diff.length) parts.push(`Diff: ${entry.diff.join('; ')}`);
    if (entry.params && Object.keys(entry.params).length) parts.push(`Args: ${JSON.stringify(entry.params).slice(0, 300)}`);
    await ch.send({ content: parts.join('\n') }).catch(()=>{});
  } catch {}
}

function getLogs() { return state.logs.slice(-getLimit()); }
function clearLogs() { state.logs = []; }
function ensureLogDir() { try { if (!fs.existsSync(LOG_DIR)) fs.mkdirSync(LOG_DIR, { recursive: true }); } catch {} }
function persist(entry) {
  try {
    ensureLogDir();
    // Build a stable, readable record
    const verbose = !!(config.commandLogging && config.commandLogging.verbose);
    const record = {
      ts: entry.ts,
      name: entry.name,
      userId: entry.userId,
      channelId: entry.channelId,
      guildId: entry.guildId,
      input: entry.input || entry.params || null,
      output: entry.actual || entry.output || null,
      dt: entry.dt,
      meta: entry.meta || null,
      ...(verbose ? { expected: entry.expected || null, diff: entry.diff || null } : {})
    };
    const safe = JSON.stringify(record, null, 2);
    fs.appendFile(LOG_FILE, safe + '\n', () => {}); // async append; ignore errors
  } catch {}
}

// Wrap an interaction's reply/update methods to automatically log outputs
function instrumentInteractionLogging(interaction) {
  if (!enabled()) return;
  if (interaction.__commandLoggingWrapped) return;
  interaction.__commandLoggingWrapped = true;
  const safeInput = () => {
    try {
      const base = {
        type: interaction.type,
        id: interaction.id,
        customId: interaction.customId || null,
        commandName: interaction.commandName || null,
      };
      // Buttons/selects
      try {
        if (typeof interaction.isButton === 'function' && interaction.isButton()) {
          base.kind = 'button';
          base.messageId = interaction.message?.id || null;
        } else if (typeof interaction.isStringSelectMenu === 'function' && interaction.isStringSelectMenu()) {
          base.kind = 'string_select';
          base.messageId = interaction.message?.id || null;
          base.values = Array.isArray(interaction.values) ? interaction.values.slice(0, 25).map(v => sanitizeString(String(v)).slice(0, 200)) : undefined;
        }
      } catch {}
      // Slash/chat input options
      try {
        if (typeof interaction.isChatInputCommand === 'function' && interaction.isChatInputCommand()) {
          const data = interaction.options?.data;
          if (Array.isArray(data)) {
            base.kind = 'chat_input';
            base.options = data.map(d => ({ name: d?.name, value: sanitizeString(String(d?.value ?? '')).slice(0, 500) }));
          }
        }
      } catch {}
      // Modal submit fields
      try {
        if (typeof interaction.isModalSubmit === 'function' && interaction.isModalSubmit()) {
          base.kind = 'modal_submit';
          const fields = [];
          const coll = interaction.fields && interaction.fields.fields ? interaction.fields.fields : null;
          if (coll && typeof coll.forEach === 'function') {
            coll.forEach((comp, key) => {
              let val = null;
              try { if (typeof interaction.fields.getTextInputValue === 'function') val = interaction.fields.getTextInputValue(key); } catch {}
              if (val != null) fields.push({ id: key, value: sanitizeString(String(val)).slice(0, 1000) });
            });
          }
          // Fallback: try common ids if collection not enumerable
          if (!fields.length && typeof interaction.fields?.getTextInputValue === 'function') {
            const common = ['reason','amount','notes','input','value'];
            for (const k of common) {
              try {
                const v = interaction.fields.getTextInputValue(k);
                if (v != null && v !== '') fields.push({ id: k, value: sanitizeString(String(v)).slice(0, 1000) });
              } catch {}
            }
          }
          base.fields = fields;
        }
      } catch {}

      // Verbose: member/user and role names
      try {
        const verbose = !!(config.commandLogging && config.commandLogging.verbose);
        if (verbose) {
          if (interaction.user) {
            const tag = interaction.user.tag || interaction.user.username || null;
            if (tag) base.userTag = sanitizeString(String(tag)).slice(0, 100);
          }
          const dn = interaction.member?.displayName || interaction.member?.nickname || null;
          if (dn) base.memberDisplayName = sanitizeString(String(dn)).slice(0, 100);
          const rolesCache = interaction.member?.roles?.cache;
          if (rolesCache && typeof rolesCache.map === 'function') {
            const arr = rolesCache.map(r => ({ id: r.id, name: sanitizeString(String(r.name || '')).slice(0, 100) }));
            base.memberRoles = Array.isArray(arr) ? arr.slice(0, 25) : undefined;
          }
        }
      } catch {}
      return base;
    } catch { return {}; }
  };
  const meta = {
    userId: interaction.user?.id,
    channelId: interaction.channelId,
    guildId: interaction.guildId,
  };
  const makeStart = (name) => start({ name, userId: meta.userId, channelId: meta.channelId, guildId: meta.guildId, input: safeInput() });
  const wrap = (methodName) => {
    if (typeof interaction[methodName] !== 'function') return;
    const original = interaction[methodName].bind(interaction);
    interaction[methodName] = async function wrapped(options, ...rest) {
      let ctx = null;
      try {
        const baseName = interaction.commandName ? `slash:${interaction.commandName}` : (interaction.customId ? `ui:${interaction.customId}` : `interaction:${methodName}`);
        ctx = makeStart(baseName);
      } catch {}
      let result;
      try { result = await original(options, ...rest); } catch (e) {
        // Log the failure as well
        try { finish(interaction.client, ctx, { output: shapeFromOptions(options), error: String(e && e.message || e) }); } catch {}
        throw e;
      }
      try { finish(interaction.client, ctx, { output: shapeFromOptions(options) }); } catch {}
      return result;
    };
  };
  ['reply','followUp','editReply','update'].forEach(wrap);
}

function shapeFromOptions(options) {
  try {
    if (!options) return null;
    if (typeof options === 'string') return { content: sanitizeString(options) };
    const content = options.content ? sanitizeString(options.content).slice(0, 1800) : undefined;
    const embeds = options.embeds ? mapEmbeds(options.embeds) : undefined;
    const components = options.components ? mapComponents(options.components) : undefined;
    return { content, embeds, components };
  } catch { return null; }
}

module.exports = { start, finish, getLogs, clearLogs, normalizeMsgShape, diffExpected, instrumentInteractionLogging, shapeFromOptions };

```

===== FILE: utils/configLogs.js =====
```javascript
const { CONFIG_LOG_CHANNEL } = require("./logChannels");
const theme = require("./theme");
const { applyStandardFooter } = require("./ui");
const { logError } = require("./errorUtil");
const { createEmbed } = require('./embeds');

/**
 * @param {import('discord.js').Client} client
 * @param {{user:{id:string,tag?:string,displayAvatarURL?:Function}, change:string}} params
 */
async function logConfigChange(client, { user, change, before, after }) {
  const channel = await client.channels.fetch(CONFIG_LOG_CHANNEL).catch(e => { logError('configLogs:fetch', e); return null; });
  if (!channel) return;

  let diffBlock = '';
  try {
    if (before !== undefined || after !== undefined) {
      const bStr = JSON.stringify(before); const aStr = JSON.stringify(after);
      diffBlock = `\n\nBefore: \`${(bStr||'').slice(0,200)}\`\nAfter: \`${(aStr||'').slice(0,200)}\``;
    }
  } catch {}
  const embed = createEmbed({
    title: "Config Changed",
    description: change + diffBlock,
    color: theme.colors.primary
  }).setAuthor({ name: user.tag || user.id, iconURL: user.displayAvatarURL ? user.displayAvatarURL({ dynamic: true }) : undefined });
  applyStandardFooter(embed, channel.guild, { testingMode: false });

  try { await channel.send({ embeds: [embed], allowedMentions: { parse: [] } }); } catch (e) { logError('configLogs:send', e); }
}

module.exports = { logConfigChange };
```

===== FILE: utils/configValidate.js =====
```javascript
// Startup configuration validation utility
// Scans botConfig and reports potential issues (missing channels/roles, invalid modes, thresholds)

const { config } = require('./storage');

function validateConfig(guild) {
  const issues = [];
  if (!guild) {
    issues.push('Guild not available during validation.');
    return issues;
  }
  // Channels
  const channelIds = [config.modLogChannelId, ...(config.levelingChannelList||[]), ...(config.snipingChannelList||[])];
  for (const id of channelIds) {
    if (!id) continue;
    if (!guild.channels.cache.has(id)) issues.push(`Missing channel: ${id}`);
  }
  // Roles sets
  for (const rid of config.moderatorRoles || []) {
    if (!guild.roles.cache.has(rid)) issues.push(`Missing moderator role: ${rid}`);
  }
  // Level rewards shape
  if (config.levelRewards && typeof config.levelRewards === 'object') {
    for (const [lvl, roleIds] of Object.entries(config.levelRewards)) {
      const arr = Array.isArray(roleIds) ? roleIds : (roleIds ? [roleIds] : []);
      for (const rid of arr) {
        if (!guild.roles.cache.has(rid)) issues.push(`Level reward role missing (level ${lvl} -> ${rid})`);
      }
    }
  }
  // Modes
  const snipeModes = ['whitelist','blacklist'];
  if (config.snipeMode && !snipeModes.includes(config.snipeMode)) issues.push(`Invalid snipeMode: ${config.snipeMode}`);
  const levelingModes = ['whitelist','blacklist'];
  if (config.levelingMode && !levelingModes.includes(config.levelingMode)) issues.push(`Invalid levelingMode: ${config.levelingMode}`);
  // Escalation thresholds
  if (config.escalation && config.escalation.kickThreshold && config.escalation.kickThreshold <= 0) {
    issues.push('Escalation kickThreshold must be > 0');
  }
  return issues;
}

module.exports = { validateConfig };

```

===== FILE: utils/crashReporter.js =====
```javascript
// Robust early crash reporter to guarantee logging of fatal conditions.
// Attach this BEFORE other heavy requires so uncaught exceptions during module load are captured.
const fs = require('fs');
const path = require('path');
const { logError } = require('./errorUtil');
const { cfgPath } = require('./paths');

const ERROR_LOG_FILE = cfgPath('errorLog.json');
const CRASH_LATEST_FILE = cfgPath('crash-latest.json');
let attached = false;
let clientRef = null;
let fatalHandled = false;
let heartbeatTimer = null;

function safeWrite(file, data) {
  try { fs.writeFileSync(file, data); } catch { /* ignore */ }
}

function appendEmergency(entry) {
  // Fallback append-only line file if main JSON write somehow fails
  const emergencyFile = cfgPath('error-emergency.log');
  try { fs.appendFileSync(emergencyFile, JSON.stringify(entry) + '\n'); } catch { /* ignore */ }
}

async function gracefulShutdown(reason, err, graceful = false) {
  if (fatalHandled) return; // ensure single execution
  fatalHandled = true;
  let mem = null; let cpu = null; try { const u = process.memoryUsage(); mem = { rss:u.rss, heapTotal:u.heapTotal, heapUsed:u.heapUsed }; } catch {}
  try { const usage = process.cpuUsage(); cpu = usage; } catch {}
  const entry = {
    ts: Date.now(),
    scope: graceful ? 'shutdown' : 'fatal',
    reason,
    message: err && (err.stack || err.message || String(err)),
    memory: mem,
    cpu
  };
  // Write dedicated crash snapshot (overwrites)
  safeWrite(CRASH_LATEST_FILE, JSON.stringify(entry, null, 2));
  // Also ensure it is in the rolling log
  try { logError(graceful ? 'exit' : 'fatal', err || reason); } catch { appendEmergency(entry); }

  // Attempt polite shutdown tasks only if we have a client and it's ready
  try {
    if (clientRef && clientRef.isReady && clientRef.isReady()) {
      const { setStatusChannelName, sendBotShutdownMessage } = require('./botStatus');
      await setStatusChannelName(clientRef, false);
      await sendBotShutdownMessage(clientRef);
    }
  } catch (e) {
    try { logError('fatal:shutdown', e); } catch { appendEmergency({ ts: Date.now(), scope: 'fatal:shutdown', message: String(e) }); }
  }
  // Force exit (skip during Jest tests to avoid interfering with test runner)
  if (!process.env.JEST_WORKER_ID) process.exit(graceful ? 0 : 1);
}

function onUncaught(err) { gracefulShutdown('uncaughtException', err); }
function onUnhandled(reason) { gracefulShutdown('unhandledRejection', reason); }
function onSignal(sig) {
  const graceful = (sig === 'SIGINT' || sig === 'SIGTERM');
  // Never classify SIGINT/SIGTERM as fatal; treat as controlled shutdown
  gracefulShutdown(`signal:${sig}`, null, graceful);
}

function initEarly() {
  if (attached) return;
  attached = true;

  // Placeholder crash snapshot so absence itself is meaningful later
  if (!fs.existsSync(CRASH_LATEST_FILE)) {
    safeWrite(CRASH_LATEST_FILE, JSON.stringify({ ts: Date.now(), status: 'init', note: 'process started' }, null, 2));
  }

  process.on('uncaughtException', onUncaught);
  process.on('unhandledRejection', onUnhandled);
  for (const sig of ['SIGINT','SIGTERM','SIGQUIT']) {
    try { process.on(sig, () => onSignal(sig)); } catch { /* ignore */ }
  }
  process.on('warning', (w) => { try { logError('warning', w); } catch {} });
  process.on('exit', (code) => {
    if (!fatalHandled) {
      if (code !== 0) {
        // treat abnormal exit as fatal without stack
        try { logError('fatal:exit', `abnormal exit code ${code}`); } catch {}
        safeWrite(CRASH_LATEST_FILE, JSON.stringify({ ts: Date.now(), scope: 'fatal', reason: 'abnormal-exit', code }, null, 2));
      } else {
        try { logError('exit', `process exiting with code ${code}`); } catch {}
      }
    }
  });

  // Lightweight heartbeat every 60s so we can detect hung process vs crash by timestamp
  heartbeatTimer = setInterval(() => {
    try {
  const hbFile = cfgPath('process-heartbeat.json');
      safeWrite(hbFile, JSON.stringify({ ts: Date.now() }, null, 2));
    } catch {}
  }, 60000);
  if (heartbeatTimer.unref) heartbeatTimer.unref();
}

function attachClient(client) {
  clientRef = client;
  // Crash replay summary
  try {
    const latest = fs.existsSync(CRASH_LATEST_FILE) ? JSON.parse(fs.readFileSync(CRASH_LATEST_FILE,'utf8')) : null;
    if (latest && latest.scope !== 'init' && client?.channels) {
      const { CONFIG_LOG_CHANNEL } = require('./logChannels');
      client.channels.fetch(CONFIG_LOG_CHANNEL).then(ch => {
        if (!ch) return;
        const when = latest.ts ? `<t:${Math.floor(latest.ts/1000)}:R>` : 'unknown';
        const summary = `🧯 Last Crash Replay: **${latest.reason || latest.scope}** ${when}`;
        ch.send({ content: summary.slice(0,1900) }).catch(()=>{});
      }).catch(()=>{});
    }
  } catch {}
}

module.exports = { initEarly, attachClient };

```

===== FILE: utils/depositProgress.js =====
```javascript
const fs = require("fs");
const path = require("path");
const { cfgPath } = require('./paths');

const FILE = cfgPath('depositProgress.json');
let data = { users: {}, day: null, resetAt: null }; // day = YYYY-MM-DD (UTC)

function load() {
  try {
    if (fs.existsSync(FILE)) {
      const raw = fs.readFileSync(FILE, "utf8");
      const parsed = JSON.parse(raw || "{}");
      if (parsed && typeof parsed === "object") data = { ...data, ...parsed };
    }
  } catch {}
  rolloverIfNeeded();
}

function save() {
  try { fs.writeFileSync(FILE, JSON.stringify(data, null, 2)); } catch {}
}

function todayUTC() {
  const d = new Date();
  return d.toISOString().slice(0,10); // YYYY-MM-DD
}

function nextMidnightUTC() {
  const now = new Date();
  const next = new Date(Date.UTC(now.getUTCFullYear(), now.getUTCMonth(), now.getUTCDate() + 1, 0,0,0,0));
  return next.getTime();
}

function rolloverIfNeeded() {
  const day = todayUTC();
  if (data.day !== day) {
    data.day = day;
    data.resetAt = nextMidnightUTC();
    data.users = {}; // reset all daily progress
    save();
  }
}

function getProgress(userId) {
  rolloverIfNeeded();
  const u = data.users[userId];
  return { amount: u ? u.amount || 0 : 0, resetAt: data.resetAt };
}

function addProgress(userId, delta) {
  rolloverIfNeeded();
  if (!data.users[userId]) data.users[userId] = { amount: 0 };
  const amt = Math.max(0, Math.floor(Number(delta) || 0));
  if (amt > 0) {
    data.users[userId].amount += amt;
    save();
  }
  return getProgress(userId);
}

module.exports = { getProgress, addProgress, load };

```

===== FILE: utils/embeds.js =====
```javascript
// Centralized embed construction utilities to enforce uniform style
// All modules should migrate to using these helpers instead of instantiating
// EmbedBuilder directly (except for highly custom dynamic cases which can still
// start from createEmbed()).
const { EmbedBuilder } = require('discord.js');
const { toTitleCase } = require('./text');
const theme = require('./theme');

// Base factory
function createEmbed({ title = null, description = null, color = 'primary', fields = [], footer = null, timestamp = true } = {}) {
  const embed = new EmbedBuilder();
  if (title) embed.setTitle(toTitleCase(title));
  if (description) embed.setDescription(description);
  // Allow passing numeric color or theme key
  const resolvedColor = typeof color === 'number' ? color : theme.color(color, theme.colors.neutral);
  embed.setColor(resolvedColor);
  if (Array.isArray(fields) && fields.length) embed.addFields(fields.slice(0, 25));
  if (footer) embed.setFooter(typeof footer === 'string' ? { text: footer } : footer);
  if (timestamp) embed.setTimestamp();
  return embed;
}

function infoEmbed(opts = {}) { return createEmbed({ color: 'primary', ...opts }); }
function successEmbed(opts = {}) { return createEmbed({ color: 'success', ...opts }); }
function warnEmbed(opts = {}) { return createEmbed({ color: 'warning', ...opts }); }
function errorEmbed(opts = {}) { return createEmbed({ color: 'danger', ...opts }); }

// Convenience to append fields safely (auto truncation per field 1024 chars)
function safeAddField(embed, name, value, inline = false) {
  try {
    if (!embed || typeof embed.addFields !== 'function') return embed;
    if (!name || !value) return embed;
    const val = String(value).slice(0, 1024);
    embed.addFields({ name: String(name).slice(0, 256), value: val, inline: !!inline });
  } catch {}
  return embed;
}

// Split a long text into multiple embed fields with a shared base name
function addChunkedField(embed, baseName, text, chunkSize = 1000) {
  if (!text) return embed;
  const chunks = [];
  let current = '';
  for (const line of String(text).split(/\n/)) {
    if ((current + line + '\n').length > chunkSize && current.length) {
      chunks.push(current);
      current = '';
    }
    current += line + '\n';
  }
  if (current.trim().length) chunks.push(current.trim());
  chunks.slice(0, 3).forEach((c, i) => safeAddField(embed, i === 0 ? baseName : `${baseName} (${i + 1})`, c));
  return embed;
}

module.exports = {
  createEmbed,
  infoEmbed,
  successEmbed,
  warnEmbed,
  errorEmbed,
  safeAddField,
  addChunkedField
};

```

===== FILE: utils/ephemeralShim.js =====
```javascript
// Legacy placeholder: ephemeralShim removed; kept only to avoid require errors in older modules.
module.exports = { EPHEMERAL_FLAG: 1<<6 };

```

===== FILE: utils/errorUtil.js =====
```javascript
// Centralized error handling helpers with persistence for next-run diagnostics.
const fs = require('fs');
const path = require('path');
const { cfgPath } = require('./paths');

const ERROR_LOG_FILE = cfgPath('errorLog.json');
const MAX_ERRORS = 100; // retention cap
let inMemoryErrors = [];
const errorListeners = [];
let originalConsoleError = null; // set by index.js wrapper

function loadExisting() {
  try {
    if (!fs.existsSync(ERROR_LOG_FILE)) return;
    const raw = fs.readFileSync(ERROR_LOG_FILE, 'utf8');
    const parsed = JSON.parse(raw || '[]');
    if (!Array.isArray(parsed)) return;
    // Drop any historical spam from console scope, retain only last MAX_ERRORS of other scopes
    inMemoryErrors = parsed.filter(e => e && e.scope !== 'console').slice(-MAX_ERRORS);
  } catch { /* ignore */ }
}

loadExisting();

function persist() {
  try {
    fs.writeFileSync(ERROR_LOG_FILE, JSON.stringify(inMemoryErrors.slice(-MAX_ERRORS), null, 2));
  } catch { /* ignore */ }
}

function formatError(err) {
  if (err && err.stack) return err.stack;
  if (typeof err === 'object') {
    try { return JSON.stringify(err); } catch { return String(err); }
  }
  return String(err);
}

function appendEntry(scope, msg) {
  // Skip console scope to prevent runaway growth from console overrides
  if (scope === 'console') return null;
  const entry = { ts: Date.now(), scope, message: msg };
  inMemoryErrors.push(entry);
  if (inMemoryErrors.length > MAX_ERRORS) {
    inMemoryErrors = inMemoryErrors.slice(-MAX_ERRORS);
  }
  persist();
  return entry;
}

function logError(scope, err) {
  const msg = formatError(err);
  // Use original console.error if available to avoid recursion
  if (originalConsoleError) {
    originalConsoleError(`[${scope}]`, msg);
  } else {
    try { process.stderr.write(`[${scope}] ${msg}\n`); } catch {}
  }
  const entry = appendEntry(scope, msg);
  if (entry) {
    for (const fn of errorListeners) {
      try { fn(entry); } catch { /* listener errors ignored */ }
    }
  }
}

// Called by console.error wrapper to record without re-emitting to console (already printed)
function recordExternalError(scope, errLike) {
  const msg = formatError(errLike);
  appendEntry(scope, msg);
}

function setOriginalConsoleError(fn) { originalConsoleError = fn; }

function registerErrorListener(fn) { if (typeof fn === 'function') errorListeners.push(fn); }

function getRecentErrors(limit = 50) {
  return inMemoryErrors.slice(-limit);
}

function clearErrorLog() {
  inMemoryErrors = [];
  persist();
}

function safeReply(target, content, opts = {}) {
  if (!target) return;
  try {
    if (typeof target.reply === 'function') {
      return target.reply({ content, ...opts }).catch(()=>{});
    }
  } catch {}
}

module.exports = { logError, recordExternalError, setOriginalConsoleError, safeReply, getRecentErrors, clearErrorLog, registerErrorListener };

```

===== FILE: utils/eventsStorage.js =====
```javascript
const fs = require("fs");
const path = require("path");
const { cfgPath } = require('./paths');

const EVENTS_FILE = cfgPath('events.json');

function ensureFile() {
  const dir = path.dirname(EVENTS_FILE);
  if (!fs.existsSync(dir)) fs.mkdirSync(dir, { recursive: true });
  if (!fs.existsSync(EVENTS_FILE)) {
    const initial = { nextId: 1, events: [] };
    fs.writeFileSync(EVENTS_FILE, JSON.stringify(initial, null, 2));
  }
}

function loadObj() {
  ensureFile();
  try {
    let raw = fs.readFileSync(EVENTS_FILE, "utf8");
    // Attempt to heal common JSON mistakes (trailing commas) before parse
    try {
      // Remove trailing commas before } or ]
      raw = raw.replace(/,\s*([}\]])/g, '$1');
    } catch {}
    const data = JSON.parse(raw);
    if (!Array.isArray(data.events)) data.events = [];
    if (typeof data.nextId !== "number") data.nextId = 1;
    return data;
  } catch {
    return { nextId: 1, events: [] };
  }
}

function saveObj(obj) {
  ensureFile();
  fs.writeFileSync(EVENTS_FILE, JSON.stringify(obj, null, 2));
}

function getEvents() { return loadObj().events; }
function getEvent(id) { id = String(id); return loadObj().events.find(e => String(e.id) === id) || null; }
function addEvent(ev) { const obj = loadObj(); const id = String(obj.nextId++); const withId = { id, ...ev }; obj.events.push(withId); saveObj(obj); return withId; }
function updateEvent(id, patch) { id = String(id); const obj = loadObj(); const i = obj.events.findIndex(e => String(e.id) === id); if (i === -1) return null; obj.events[i] = { ...obj.events[i], ...patch }; saveObj(obj); return obj.events[i]; }
function removeEvent(id) { id = String(id); const obj = loadObj(); const i = obj.events.findIndex(e => String(e.id) === id); if (i === -1) return false; obj.events.splice(i,1); saveObj(obj); return true; }

module.exports = { getEvents, getEvent, addEvent, updateEvent, removeEvent };

```

===== FILE: utils/health.js =====
```javascript
const { getEvents, updateEvent } = require('./eventsStorage');
const { ensureAnchor } = require('../commands/schedule');
const { updateStaffMessage } = require('./staffTeam');
const ActiveMenus = require('./activeMenus');

/**
 * Perform startup health checks for dynamic, auto-edited messages (event anchors, staff team message).
 * Returns an array of status objects: { kind, id, name, ok, url, error }
 */
async function runHealthChecks(client) {
  const results = [];
  const guild = client.guilds.cache.first();
  if (!guild) return results;

  // Events (anchor messages)
  try {
    const events = getEvents();
    for (const ev of events) {
      if (!ev.enabled) continue;
      if (!ev.anchorChannelId || !ev.anchorMessageId) {
        // Attempt to (re)create anchor if the event has times/ranges
        try {
          await ensureAnchor(client, ev);
        } catch (e) {
          results.push({ kind: 'event', id: ev.id, name: ev.name, ok: false, error: 'anchor create failed: '+e.message });
          continue;
        }
      }
      if (ev.anchorChannelId && ev.anchorMessageId) {
        try {
          const channel = await client.channels.fetch(ev.anchorChannelId).catch(()=>null);
          if (!channel || !channel.messages) throw new Error('channel inaccessible');
          const msg = await channel.messages.fetch(ev.anchorMessageId).catch(()=>null);
          if (!msg) throw new Error('message missing');

          // Validate notification button for Midnight Bar; if missing attempt repair
          let buttonHealthy = true;
          if (/Midnight Bar/i.test(ev.name || '')) {
            const expectedId = `event_notify_${ev.id}`;
            const hasButton = Array.isArray(msg.components) && msg.components.some(r => r.components?.some?.(c => c.customId === expectedId));
            if (!hasButton) {
              buttonHealthy = false;
              try {
                await ensureAnchor(client, ev); // will enforce button
                const repaired = await channel.messages.fetch(ev.anchorMessageId).catch(()=>null);
                if (repaired) {
                  const repairedHas = Array.isArray(repaired.components) && repaired.components.some(r => r.components?.some?.(c => c.customId === expectedId));
                  buttonHealthy = repairedHas;
                }
              } catch { /* ignore repair errors */ }
            }
          }

          // Auto-fix outdated timestamps for Midnight Bar style message
          try {
            if (/Midnight Bar/i.test(ev.name || '') && ev.ranges && Array.isArray(ev.ranges) && ev.ranges.length) {
              const baseContent = ev.dynamicBaseContent || ev.messageJSON?.content || ev.message || msg.content || '';
              // Pattern '# The Midnight bar is opening:' followed by a discord relative timestamp
              const lineRegex = /(#+\s*The Midnight bar is opening:).*/i;
              // Compute next upcoming opening start epoch from today's or next valid day based on ev.days and first range start
              const range = ev.ranges[0];
              const startStr = range.start; // e.g. '6:00'
              // Parse startStr to hours:minutes
              const [shRaw, smRaw] = startStr.split(':');
              const sh = parseInt(shRaw, 10) || 0; const sm = parseInt(smRaw,10)||0;
              const now = new Date();
              const todayWd = now.getDay();
              const validDays = Array.isArray(ev.days) && ev.days.length ? ev.days : [todayWd];
              let target = null;
              for (let offset=0; offset<8; offset++) {
                const d = new Date(now.getFullYear(), now.getMonth(), now.getDate()+offset, sh, sm, 0, 0);
                const wd = d.getDay();
                if (!validDays.includes(wd)) continue;
                if (d.getTime() <= Date.now()) continue; // we want next future opening
                target = d; break;
              }
              if (!target) {
                // fallback: tomorrow at start time
                target = new Date(now.getFullYear(), now.getMonth(), now.getDate()+1, sh, sm, 0, 0);
              }
              const epoch = Math.floor(target.getTime()/1000);
              const desiredLine = `# The Midnight bar is opening: <t:${epoch}:R>`;
              if (lineRegex.test(baseContent)) {
                const newContent = baseContent.replace(lineRegex, desiredLine);
                if (newContent !== msg.content) {
                  if (ev.messageJSON) {
                    const payload = { ...ev.messageJSON, content: newContent };
                    if (payload.embeds && !Array.isArray(payload.embeds)) payload.embeds = [payload.embeds];
                    await msg.edit(payload).catch(()=>{});
                  } else {
                    await msg.edit({ content: newContent }).catch(()=>{});
                  }
                  if (newContent !== ev.dynamicBaseContent) updateEvent(ev.id, { dynamicBaseContent: newContent });
                }
              }
            }
          } catch (tsErr) { /* ignore timestamp fix errors */ }
          results.push({ kind: 'event', id: ev.id, name: ev.name, ok: buttonHealthy, url: buttonHealthy ? `https://discord.com/channels/${msg.guildId}/${msg.channelId}/${msg.id}` : null, error: buttonHealthy ? undefined : 'notification button missing' });
        } catch (e) {
          results.push({ kind: 'event', id: ev.id, name: ev.name, ok: false, error: e.message });
        }
      }
    }
  } catch (e) {
    results.push({ kind: 'event', id: 'all', name: 'Events', ok: false, error: e.message });
  }

  // Staff Team message
  try {
    const staffMsg = await updateStaffMessage(guild);
    if (staffMsg) {
      results.push({ kind: 'staffTeam', id: staffMsg.id, name: 'Staff Team', ok: true, url: `https://discord.com/channels/${staffMsg.guildId}/${staffMsg.channelId}/${staffMsg.id}` });
    } else {
      results.push({ kind: 'staffTeam', id: 'staff', name: 'Staff Team', ok: false, error: 'update failed' });
    }
  } catch (e) {
    results.push({ kind: 'staffTeam', id: 'staff', name: 'Staff Team', ok: false, error: e.message });
  }

  // ActiveMenus sanity: ensure no session with empty component rows
  try {
    const snapshot = ActiveMenus.snapshotSessions ? ActiveMenus.snapshotSessions() : [];
    let stale = 0; let emptyRows = 0;
    const now = Date.now();
    for (const s of snapshot) {
      if (s.expiresAt && s.expiresAt < now) stale++;
      if (Array.isArray(s.components)) {
        for (const row of s.components) {
          if (row && Array.isArray(row.components) && row.components.length === 0) emptyRows++;
        }
      }
    }
    results.push({ kind: 'activeMenus', id: 'activeMenus', name: 'Active Menus', ok: stale === 0 && emptyRows === 0, error: (stale||emptyRows)?`stale:${stale} emptyRows:${emptyRows}`:undefined });
  } catch (e) {
    results.push({ kind: 'activeMenus', id: 'activeMenus', name: 'Active Menus', ok: false, error: e.message });
  }

  return results;
}

function formatHealthLines(results) {
  return results.map(r => {
    const symbol = r.ok ? '✔️' : '✖️';
    const name = r.name || r.kind;
    const link = r.url ? `[${name}](${r.url})` : name;
    return `${symbol} ${link} ${r.ok ? 'is up and running!' : 'is currently down' + (r.error?` (${r.error})`:'!')}`;
  }).join('\n');
}

module.exports = { runHealthChecks, formatHealthLines };

```

===== FILE: utils/leaderboards.js =====
```javascript
// Shared leaderboard builders extracted from profile command for reuse
const { EmbedBuilder } = require('discord.js');
const theme = require('./theme');
const { applyFooterWithPagination } = require('./ui');
const { createEmbed } = require('./embeds');

function computeEntries(levelsObj = {}) {
  return Object.entries(levelsObj).map(([userId, data]) => ({
    userId,
    xp: data?.xp || 0,
    level: data?.level || 0,
  }));
}

function sortEntries(entries) {
  return entries.sort((a, b) => (b.level - a.level) || (b.xp - a.xp));
}

function computeRank(levelsObj, viewerId) {
  const entries = sortEntries(computeEntries(levelsObj));
  const idx = entries.findIndex(e => String(e.userId) === String(viewerId));
  return idx === -1 ? null : idx + 1;
}

function buildBankSection() {
  const { getTopBank } = require('./bank');
  const topBank = getTopBank(10) || [];
  const bankLines = topBank.map((e, i) => {
    const n = i + 1;
    const medal = n === 1 ? '🥇' : n === 2 ? '🥈' : n === 3 ? '🥉' : `#${n}`;
    return `${medal} <@${e.userId}> — $${e.amount.toLocaleString()}`;
  });
  return `\n\n${theme.emojis.bank} Bank Leaderboard\n${bankLines.length ? bankLines.join('\n') : 'No balances yet.'}`;
}

function buildLeaderboardEmbed(guild, levelsObj, viewerId, page = 1, pageSize = 10, mode = 'text') {
  const entries = sortEntries(computeEntries(levelsObj));
  const totalPages = Math.max(1, Math.ceil(entries.length / pageSize));
  const safePage = Math.min(totalPages, Math.max(1, Math.floor(page)));
  const start = (safePage - 1) * pageSize;
  const pageEntries = entries.slice(start, start + pageSize);
  const lines = pageEntries.map((e, i) => {
    const rankNum = start + i + 1;
    const medal = rankNum === 1 ? '🥇' : rankNum === 2 ? '🥈' : rankNum === 3 ? '🥉' : `#${rankNum}`;
    const isYou = String(e.userId) === String(viewerId);
    const line = `${medal} <@${e.userId}> — Lv. ${e.level}`;
    return isYou ? `**${line} ← You**` : line;
  });
  const rank = computeRank(levelsObj, viewerId);
  const viewerOnPage = pageEntries.some(e => String(e.userId) === String(viewerId));
  const extraLine = !viewerOnPage && rank ? `\n— —\nYou: **#${rank}** <@${viewerId}>` : '';
  const bankSection = buildBankSection();
  const embed = createEmbed({
    title: mode === 'text' ? `${theme.emojis.leaderboard} Leaderboard` : `${theme.emojis.vc} VC Leaderboard`,
    description: (lines.length ? lines.join('\n') + extraLine : 'No data yet.') + bankSection,
    color: mode === 'text' ? theme.colors.warning : theme.colors.danger
  });
  const extraFooter = rank ? `Your rank: #${rank}` : null;
  applyFooterWithPagination(embed, guild, { testingMode: false, page: safePage, totalPages, extra: extraFooter });
  return embed;
}

module.exports = { buildLeaderboardEmbed, buildBankSection, computeRank };

```

===== FILE: utils/leveling.js =====
```javascript
const { addXP, saveLevels } = require("./levels");
const { addCash } = require("./cash");
const { config } = require("./storage");

const userCooldowns = new Map();
const userModifiers = new Map();

function getUserModifier(userId) {
  const data = userModifiers.get(userId);
  return data && typeof data.modifier === 'number' ? data.modifier : 1.0;
}

// Slightly lower per-message XP to slow overall progression
const XP_MIN = 8;
const XP_MAX = 16;
const MODIFIER_CAP = 2.0;
const MODIFIER_STEP = 0.1;

function getRandomXP() {
  return Math.floor(Math.random() * (XP_MAX - XP_MIN + 1)) + XP_MIN;
}

async function handleLeveling(message, LEVEL_ROLES = {}) {
  try {
  if (!message.guild) return; // guild-only leveling
    // Channel gating for leveling
    const chId = message.channel?.id;
    if (!chId) return;
    const mode = config.levelingMode || "blacklist";
    const list = Array.isArray(config.levelingChannelList) ? config.levelingChannelList : [];
    const inList = list.includes(chId);
    if (mode === "blacklist" ? inList : !inList) {
      return; // do not award XP here
    }

    const userId = message.author.id;
    const now = Date.now();
    const lastXP = userCooldowns.get(userId) || 0;

    if (now - lastXP < 60 * 1000) return; // cooldown gate

    let modData = userModifiers.get(userId) || { streak: 0, modifier: 1.0, lastMinute: 0 };
    if (modData.lastMinute && now - modData.lastMinute <= 65 * 1000) {
      modData.streak += 1;
      modData.modifier = Math.min(MODIFIER_CAP, 1.0 + modData.streak * MODIFIER_STEP);
    } else {
      modData.streak = 0;
      modData.modifier = 1.0;
    }
    modData.lastMinute = now;
    userModifiers.set(userId, modData);

    // Skip XP if member has a blacklisted role
    const member = await message.guild.members.fetch(userId).catch(() => null);
    if (!member) return;
    const roleBlacklist = Array.isArray(config.roleXPBlacklist) ? config.roleXPBlacklist : [];
    if (roleBlacklist.length && member.roles.cache.some(r => roleBlacklist.includes(r.id))) {
      return;
    }

    const baseXP = getRandomXP();
    const globalMult = typeof config.globalXPMultiplier === 'number' && Number.isFinite(config.globalXPMultiplier) ? Math.max(0, config.globalXPMultiplier) : 1.0;
    const totalXP = Math.floor(baseXP * modData.modifier * globalMult);
    const leveledUp = addXP(userId, totalXP);
    saveLevels();

    userCooldowns.set(userId, now);

  if (leveledUp) {
      const key = String(leveledUp);
      const configured = config.levelRewards ? config.levelRewards[key] : null;
      const rewards = Array.isArray(configured)
        ? configured
        : (configured ? [configured] : (LEVEL_ROLES[leveledUp] ? [LEVEL_ROLES[leveledUp]] : []));
      if (rewards.length && member) {
        for (const roleId of rewards) {
          if (!member.roles.cache.has(roleId)) {
            await member.roles.add(roleId).catch(() => {});
          }
        }
      }
  // Cash reward: base grows per level (expandable rule)
  const cashReward = Math.max(0, Math.floor(50 + leveledUp * 10));
  addCash(userId, cashReward);
  await message.reply(`🎉 Congrats <@${userId}>, you reached level ${leveledUp}! You earned ${cashReward} Cash.`).catch(() => {});
    }
  } catch (e) {
    // ignore leveling errors
  }
}

module.exports = { handleLeveling, getUserModifier };

```

===== FILE: utils/levels.js =====
```javascript
const fs = require("fs");
const path = require("path");
const { cfgPath } = require('./paths');
const { enqueueWrite } = require('./writeQueue');

const LEVELS_FILE = cfgPath('levels.json');

// in-memory cache
let levels = {};
try {
  if (fs.existsSync(LEVELS_FILE)) {
    levels = JSON.parse(fs.readFileSync(LEVELS_FILE, "utf8")) || {};
  }
} catch {
  levels = {};
}

let pendingSave = false;
function saveLevels() {
  if (pendingSave) return; // coalesce rapid calls
  pendingSave = true;
  enqueueWrite(LEVELS_FILE, () => {
    pendingSave = false;
    return JSON.stringify(levels, null, 2);
  }, { delay: 250 });
}

function getXP(userId) {
  return levels[userId]?.xp || 0;
}

function getLevel(userId) {
  return levels[userId]?.level || 0;
}

function xpForLevel(level) {
  // Keep in sync with profile/leaderboard: BASE_XP = 150, exponent 1/0.7
  const BASE_XP = 150;
  return Math.floor(BASE_XP * Math.pow(level, 1 / 0.7));
}

/**
 * Add XP and return the new level if leveled up, or 0 if not.
 */
function addXP(userId, amount) {
  const cur = levels[userId] || { xp: 0, level: 0 };
  cur.xp += Math.max(0, Number(amount) || 0);

  let newLevel = 0;
  while (cur.xp >= xpForLevel(newLevel + 1)) newLevel++;
  const oldLevel = cur.level || 0;
  cur.level = newLevel;
  levels[userId] = cur;

  if (newLevel !== oldLevel) {
    // Invalidate leaderboard cache for text leveling
    try { require('../services/leaderboardService').invalidate('text'); } catch {}
  }
  saveLevels(); // always schedule save (coalesced)
  return newLevel > oldLevel ? newLevel : 0;
}

module.exports = {
  levels,
  saveLevels,
  getXP,
  getLevel,
  addXP
};
```

===== FILE: utils/logChannels.js =====
```javascript
module.exports = {
  MESSAGE_LOG_CHANNEL: "1232701769859993622",
  ROLE_LOG_CHANNEL: "1232739307736010854",
  MOD_ACTION_LOG_CHANNEL: "1232701769859993627",
  CONFIG_LOG_CHANNEL: "1413966369296220233",
  MEMBER_LEAVE_LOG_CHANNEL: "1232701769859993628",
  TEST_LOG_CHANNEL: "1413966369296220233"
};


```

===== FILE: utils/memberLogs.js =====
```javascript
const { config } = require("./storage");
const theme = require("./theme");
const { applyStandardFooter } = require("./ui");
const { MEMBER_LEAVE_LOG_CHANNEL, TEST_LOG_CHANNEL } = require("./logChannels");
const { logError } = require("./errorUtil");
const { createEmbed, safeAddField } = require('./embeds');

/**
 * Logs when a member leaves the guild.
 */
async function logMemberLeave(client, member, isTest = false) {
  const logChannelId = config.testingMode || isTest ? TEST_LOG_CHANNEL : MEMBER_LEAVE_LOG_CHANNEL;
  let channel = null;
  try { channel = await client.channels.fetch(logChannelId).catch(() => null); } catch (e) { logError('memberLogs:fetch', e); }
  if (!channel || !member || !member.user) return;

  const joinedAt = member.joinedTimestamp;
  const leftAt = Date.now();
  let duration = "Unknown";
  if (joinedAt) {
    const diffMs = leftAt - joinedAt;
    const days = Math.floor(diffMs / (1000 * 60 * 60 * 24));
    const hours = Math.floor((diffMs / (1000 * 60 * 60)) % 24);
    const mins = Math.floor((diffMs / (1000 * 60)) % 60);
    duration = `${days}d ${hours}h ${mins}m`;
  }

  const embed = createEmbed({
    title: `${theme.emojis.warn} Member Left`,
    color: theme.colors.warning
  }).setAuthor({ name: member.user.tag, iconURL: member.user.displayAvatarURL({ dynamic: true }) });
  safeAddField(embed, "Member", `<@${member.id}>`, true);
  safeAddField(embed, "Joined", joinedAt ? `<t:${Math.floor(joinedAt / 1000)}:R>` : "Unknown", true);
  safeAddField(embed, "Time in Server", duration, true);
  applyStandardFooter(embed, member.guild, { testingMode: config.testingMode });

  try { await channel.send({ embeds: [embed], allowedMentions: { parse: [] } }); } catch (e) { logError('memberLogs:send', e); }
}

module.exports = {
  logMemberLeave
};

```

===== FILE: utils/messageLogs.js =====
```javascript
const { config } = require("./storage");
const theme = require("./theme");
const { applyStandardFooter } = require("./ui");
const { MESSAGE_LOG_CHANNEL, TEST_LOG_CHANNEL } = require("./logChannels");
const { logError } = require("./errorUtil");
const { createEmbed, safeAddField } = require('./embeds');

async function logMessageDelete(client, message) {
  const logChannelId = config.testingMode ? TEST_LOG_CHANNEL : MESSAGE_LOG_CHANNEL;
  const channel = await client.channels.fetch(logChannelId).catch(e => { logError('messageLogs:deleteFetch', e); return null; });
  if (!channel || !message || !message.guild || !message.author || message.author.bot) return;

  const embed = createEmbed({
    title: `${theme.emojis.delete} Message Deleted`,
    description: message.content || "*No content*",
    color: theme.colors.danger
  }).setAuthor({ name: message.author.tag, iconURL: message.author.displayAvatarURL({ dynamic: true }) });
  safeAddField(embed, "Channel", `<#${message.channel.id}>`, true);
  applyStandardFooter(embed, message.guild, { testingMode: config.testingMode });

  try { await channel.send({ embeds: [embed], allowedMentions: { parse: [] } }); } catch (e) { logError('messageLogs:deleteSend', e); }
}

async function logMessageEdit(client, oldMessage, newMessage) {
  const logChannelId = config.testingMode ? TEST_LOG_CHANNEL : MESSAGE_LOG_CHANNEL;
  const channel = await client.channels.fetch(logChannelId).catch(e => { logError('messageLogs:editFetch', e); return null; });
  if (!channel || !oldMessage || !newMessage) return;
  if (!newMessage.guild || (newMessage.author && newMessage.author.bot)) return;

  const embed = createEmbed({
    title: `${theme.emojis.edit} Message Edited`,
    color: theme.colors.warning
  }).setAuthor({ name: (newMessage.author && newMessage.author.tag) || "Unknown", iconURL: newMessage.author ? newMessage.author.displayAvatarURL({ dynamic: true }) : undefined });
  safeAddField(embed, "Channel", `<#${newMessage.channel.id}>`, true);
  safeAddField(embed, "Before", oldMessage.content || "*No content*");
  safeAddField(embed, "After", newMessage.content || "*No content*");
  applyStandardFooter(embed, newMessage.guild, { testingMode: config.testingMode });

  try { await channel.send({ embeds: [embed] }); } catch (e) { logError('messageLogs:editSend', e); }
}

module.exports = { logMessageDelete, logMessageEdit };
```

===== FILE: utils/modLogs.js =====
```javascript
const { ActionRowBuilder, ButtonBuilder, ButtonStyle } = require("discord.js");
const ms = require("ms");
const { config } = require("./storage");
const theme = require("./theme");
const { createEmbed } = require('./embeds');
const { MOD_ACTION_LOG_CHANNEL, TEST_LOG_CHANNEL } = require("./logChannels");
const { applyStandardFooter } = require("./ui");

// Testing mode routes to test channel; otherwise prefer config.modLogChannelId, then MOD_ACTION_LOG_CHANNEL

/**
 * Logs moderation actions in the user action channel only
 * @param {import('discord.js').Client} client
 * @param {import('discord.js').GuildMember|import('discord.js').User} target
 * @param {import('discord.js').User|{id:string,tag?:string}} moderator
 * @param {string} action - e.g. "muted", "unmuted", "banned", "warned", "warning removed"
 * @param {string|null} reason
 * @param {boolean} isPunishment
 * @param {string|null} duration - human readable (e.g., "1 hour")
 * @param {number|null} currentWarnings
 * @returns {Promise<import('discord.js').Message| null>}
 */
async function sendModLog(
  client,
  target,
  moderator,
  action,
  reason = null,
  isPunishment = true,
  duration = null,
  currentWarnings = null
) {
  const isTest = !!config.testingMode;
  const channelId = isTest ? TEST_LOG_CHANNEL : (config.modLogChannelId || MOD_ACTION_LOG_CHANNEL);
  const channel = await client.channels.fetch(channelId).catch(() => null);
  if (!channel) return null;

  // Normalize objects
  const targetUser = target?.user || target;
  const modUser = moderator?.user || moderator;
  const targetId = targetUser?.id || target?.id || "Unknown";
  const modId = modUser?.id || moderator?.id || "Unknown";
  const targetTag = targetUser?.tag || targetUser?.username || targetId;
  const modTag = modUser?.tag || modUser?.username || modId;

  // Colors
  let color = theme.colors.primary;
  const a = String(action || "").toLowerCase();
  if (a.includes("warn")) color = theme.colors.warning;
  if (a.includes("removed")) color = theme.colors.success;
  if (a.includes("mute") || a.includes("ban") || a.includes("kick")) color = theme.colors.danger;

  // Build a modern, stacked description similar to DM style
  // Extract any "warnings remaining until <punishment>" line from reason to place in footer (not for warn logs)
  let footerRemaining = null;
  let cleanReason = reason ? String(reason) : null;
  if (cleanReason) {
    const lines = cleanReason.split(/\n+/);
    const idx = lines.findIndex(l => /\b\d+\s+warning(s)?\s+remaining\s+until\s+(mute|kick)\b/i.test(l));
    if (idx !== -1 && a !== "warned") { // do not show remaining footer on warn logs
      footerRemaining = lines[idx].trim();
      lines.splice(idx, 1);
      cleanReason = lines.join("\n").trim();
    }
  }

  const descParts = [];
  if (cleanReason) {
    descParts.push(`📝 **Reason**\n${cleanReason}`);
  }
  if (duration) {
    descParts.push(`⏰ **Duration**\n${duration}`);
  }

  // Auto moderation note if this action itself is a mute/kick and we know the warnings count
  const bottomParts = [];
  const isAutoMute = a.includes("mute") && isPunishment && duration && typeof currentWarnings === "number";
  if (isAutoMute) {
    const durMs = typeof duration === "string" ? (ms(duration) || 0) : 0;
    const endTs = durMs > 0 ? `<t:${Math.floor((Date.now() + durMs) / 1000)}:R>` : null;
    bottomParts.push(`🚨 This user has been muted due to reaching ${currentWarnings} warning${currentWarnings === 1 ? "" : "s"}.${endTs ? `\n⏰ Ends ${endTs}` : ""}`);
  }
  const isAutoKick = a.includes("kick") && isPunishment && typeof currentWarnings === "number";
  if (isAutoKick) {
    bottomParts.push(`🚨 This user has been kicked due to reaching ${currentWarnings} warning${currentWarnings === 1 ? "" : "s"}.`);
  }

  const toTitleCase = (s) => String(s || "").replace(/\w\S*/g, (t) => t.charAt(0).toUpperCase() + t.substr(1));
  let actionTitle = toTitleCase(action);
  actionTitle = actionTitle.replace(/\bX(\d+)\b/g, (m, n) => `x${n}`);

  const userObj = target?.user || target; // target can be GuildMember or User
  const displayName = target?.displayName || userObj?.username || `User ${target?.id || "Unknown"}`;
  const avatarURL = typeof userObj?.displayAvatarURL === "function"
    ? userObj.displayAvatarURL({ dynamic: true })
    : undefined;

  const embed = createEmbed({
    color,
    title: targetTag,
    description: [descParts.join("\n\n"), bottomParts.length ? bottomParts.join("\n\n") : null].filter(Boolean).join("\n\n"),
    timestamp: false
  }).setAuthor({ name: modTag, iconURL: modUser?.displayAvatarURL ? modUser.displayAvatarURL({ dynamic: true }) : undefined });
  // keep explicit addFields order to preserve layout
  embed.addFields(
    { name: `${theme.emojis.action} Action`, value: `**${actionTitle}**`, inline: true },
    { name: `${theme.emojis.target} Target`, value: `<@${targetId}>`, inline: true },
    { name: `${theme.emojis.moderator} Moderator`, value: `<@${modId}>`, inline: true }
  );

  // Always prefer a footer over timestamp; include emojis
  if (footerRemaining) {
    embed.setFooter({ text: `${theme.emojis.counter} ${footerRemaining} • ${theme.emojis.id} ${targetId}` });
  } else {
    // Apply standard footer for server/testing context then append ID line
    applyStandardFooter(embed, channel.guild, { testingMode: config.testingMode });
    // Merge existing footer text with ID token
    const existing = embed.data.footer?.text || '';
    embed.setFooter({ text: `${existing}${existing ? ' • ' : ''}${theme.emojis.id} ${targetId}` });
  }

  const avatarUrl = targetUser?.displayAvatarURL ? targetUser.displayAvatarURL({ dynamic: true, size: 256 }) : null;
  if (avatarUrl) embed.setThumbnail(avatarUrl);

  // Staff-only quick-action buttons (compact: open submenus)
  const userIdSafe = String(targetId);
  const { semanticButton } = require('./ui');
  const rows = [ new ActionRowBuilder().addComponents(
    semanticButton('nav', { id: `modact:menu:warnings:${userIdSafe}`, label: 'Warnings', emoji: theme.emojis.warn }),
    semanticButton('nav', { id: `modact:menu:mute:${userIdSafe}`, label: 'Mute', emoji: theme.emojis.mute }),
    semanticButton('nav', { id: `modact:init:kick:${userIdSafe}`, label: 'Kick', emoji: theme.emojis.kick }),
    semanticButton('danger', { id: `modact:init:ban:${userIdSafe}`, label: 'Ban', emoji: theme.emojis.ban })
  ) ];

  try {
  return await channel.send({ embeds: [embed], components: rows, allowedMentions: { parse: [] } });
  } catch {
    return null;
  }
}

module.exports = { sendModLog };

```

===== FILE: utils/paths.js =====
```javascript
const fs = require('fs');
const path = require('path');

function findProjectRoot(startDir) {
  let dir = startDir;
  const root = path.parse(dir).root;
  while (dir && dir !== root) {
    try {
      if (fs.existsSync(path.join(dir, 'package.json'))) return dir;
    } catch {}
    dir = path.dirname(dir);
  }
  // Fallback to CWD when package.json not found
  return process.cwd();
}

const projectRoot = findProjectRoot(__dirname);

function cfgPath(...parts) { return path.join(projectRoot, 'config', ...parts); }
function dataPath(...parts) { return path.join(projectRoot, ...parts); }

module.exports = { projectRoot, cfgPath, dataPath };

```

===== FILE: utils/permissionsCache.js =====
```javascript
// Simple permission result cache to reduce repeated role/permission scanning.
// Not persisted; safe to lose on restart.
const cache = new Map(); // key guildId:userId -> { ok, expires }
const TTL = 60 * 1000; // 60s

function getCached(guildId, userId) {
  const key = guildId + ':' + userId;
  const v = cache.get(key);
  if (!v) return null;
  if (v.expires < Date.now()) { cache.delete(key); return null; }
  return v.ok;
}

function setCached(guildId, userId, ok) {
  cache.set(guildId + ':' + userId, { ok, expires: Date.now() + TTL });
}

function sweep() {
  const now = Date.now();
  for (const [k,v] of cache.entries()) if (v.expires < now) cache.delete(k);
}
setInterval(sweep, TTL).unref?.();

module.exports = { getCached, setCached };
```

===== FILE: utils/policy.js =====
```javascript
// Declarative permission policies for commands
const { isModerator } = require('../commands/moderation/permissions');
function isOwnerId(id) { return String(id) === String(process.env.OWNER_ID); }
const policies = {
  config: (ctx) => isOwnerId(ctx.author?.id || ctx.user?.id),
  test: (ctx) => isOwnerId(ctx.author?.id || ctx.user?.id),
  purge: (ctx) => isModerator(ctx.member),
  mute: (ctx) => isModerator(ctx.member),
  unmute: (ctx) => isModerator(ctx.member),
  timeout: (ctx) => isModerator(ctx.member),
  untimeout: (ctx) => isModerator(ctx.member),
  ban: (ctx) => isModerator(ctx.member),
  kick: (ctx) => isModerator(ctx.member),
  warn: (ctx) => isModerator(ctx.member),
  removewarn: (ctx) => isModerator(ctx.member)
};
function checkPolicy(command, ctx) {
  const fn = policies[command];
  if (!fn) return true; // permissive by default
  try { return !!fn(ctx); } catch { return false; }
}
module.exports = { checkPolicy };
```

===== FILE: utils/processHandlers.js =====
```javascript
// Deprecated legacy process handler module.
// Crash handling has moved to crashReporter.js (early init, unified fatal snapshot + heartbeat).
// This stub remains only to avoid breaking any stale require calls.
module.exports = function() { /* no-op (deprecated) */ };
```

===== FILE: utils/roleLogs.js =====
```javascript
const { EmbedBuilder } = require("discord.js");
const { config } = require("./storage");
const theme = require("./theme");
const { applyStandardFooter } = require("./ui");
const { ROLE_LOG_CHANNEL, TEST_LOG_CHANNEL } = require("./logChannels");
const { logError } = require("./errorUtil");

async function logRoleChange(client, member, role, action) {
  if (config.roleLogBlacklist.includes(role.id)) return;

  const logChannelId = config.testingMode ? TEST_LOG_CHANNEL : ROLE_LOG_CHANNEL;
  const channel = await client.channels.fetch(logChannelId).catch(err => { logError('roleLogs:fetch', err); return null; });
  if (!channel) return;

  const embed = new EmbedBuilder()
    .setTitle(`${action === "add" ? theme.emojis.enable : theme.emojis.disable} Role ${action === "add" ? "Added" : "Removed"}`)
    .setColor(action === "add" ? theme.colors.success : theme.colors.danger)
    .setAuthor({ name: member.user.tag, iconURL: member.user.displayAvatarURL({ dynamic: true }) })
    .addFields(
      { name: "Role", value: `<@&${role.id}>`, inline: true },
      { name: "Member", value: `<@${member.id}>`, inline: true }
    )
    .setTimestamp();
  applyStandardFooter(embed, member.guild, { testingMode: config.testingMode });

  try { await channel.send({ embeds: [embed], allowedMentions: { parse: [] } }); } catch (e) { logError('roleLogs:send', e); }
}

module.exports = {
  logRoleChange
};
```

===== FILE: utils/sanitize.js =====
```javascript
// Global mention sanitization utility (wrap outbound content before send when in testing or forced safe mode)
function sanitizeMentions(content, { codeWrap = true } = {}) {
  if (!content || typeof content !== 'string') return content;
  return content.replace(/<@&?\d+>/g, m => codeWrap ? `\`${m}\`` : m);
}
module.exports = { sanitizeMentions };
```

===== FILE: utils/scheduleStorage.js =====
```javascript
const fs = require("fs");
const path = require("path");
const { cfgPath } = require('./paths');

const SCHEDULES_FILE = cfgPath('schedules.json');

function ensureFile() {
  const dir = path.dirname(SCHEDULES_FILE);
  if (!fs.existsSync(dir)) fs.mkdirSync(dir, { recursive: true });
  if (!fs.existsSync(SCHEDULES_FILE)) {
    const initial = { nextId: 1, schedules: [] };
    fs.writeFileSync(SCHEDULES_FILE, JSON.stringify(initial, null, 2));
  }
}

function loadObj() {
  ensureFile();
  try {
    const data = JSON.parse(fs.readFileSync(SCHEDULES_FILE, "utf8"));
    if (Array.isArray(data)) return { nextId: 1, schedules: data };
    if (!Array.isArray(data.schedules)) data.schedules = [];
    if (typeof data.nextId !== "number") data.nextId = 1;
    return data;
  } catch {
    return { nextId: 1, schedules: [] };
  }
}

function saveObj(obj) {
  ensureFile();
  fs.writeFileSync(SCHEDULES_FILE, JSON.stringify(obj, null, 2));
}

function getSchedules() { return loadObj().schedules; }
function getSchedule(id) { id = String(id); return loadObj().schedules.find(s => String(s.id) === id) || null; }
function addSchedule(schedule) { const obj = loadObj(); const id = String(obj.nextId++); const withId = { id, ...schedule }; obj.schedules.push(withId); saveObj(obj); return withId; }
function updateSchedule(id, patch) {
  id = String(id);
  const obj = loadObj();
  const i = obj.schedules.findIndex(x => String(x.id) === id);
  if (i === -1) return null;
  obj.schedules[i] = { ...obj.schedules[i], ...patch };
  saveObj(obj);
  return obj.schedules[i];
}
function removeSchedule(id) {
  id = String(id);
  const obj = loadObj();
  const i = obj.schedules.findIndex(x => String(x.id) === id);
  if (i === -1) return false;
  obj.schedules.splice(i, 1);
  saveObj(obj);
  return true;
}

module.exports = { getSchedules, getSchedule, addSchedule, updateSchedule, removeSchedule };

```

===== FILE: utils/scheduler.js =====
```javascript
const { addSchedule, updateSchedule, getSchedules } = require("./scheduleStorage");
const { getEvents, updateEvent } = require("./eventsStorage");
const { applyTimestampPlaceholders } = require('./timestampPlaceholders');
const { config } = require('./storage');
const ms = require("ms");
const { ActionRowBuilder, StringSelectMenuBuilder } = require('discord.js');
const theme = require('./theme');
const { createEmbed } = require('./embeds');
const { CONFIG_LOG_CHANNEL } = require('./logChannels');
const { buildClockInEmbed } = require('./clockinEmbed');

function applyPlaceholdersToJsonPayload(payload, ev) {
  if (!payload || typeof payload !== 'object') return payload;
  const repl = (s) => applyTimestampPlaceholders(String(s), ev);
  const sanitize = (s) => (config.testingMode ? String(s).replace(/<@&?\d+>/g, m=>`\`${m}\``) : s);
  const fixStr = (s) => sanitize(repl(s));
  const copy = { ...payload };
  if (typeof copy.content === 'string') copy.content = fixStr(copy.content).slice(0, 2000);
  if (Array.isArray(copy.embeds)) {
    copy.embeds = copy.embeds.map(e => {
      if (!e || typeof e !== 'object') return e;
      const ee = { ...e };
      if (typeof ee.title === 'string') ee.title = fixStr(ee.title);
      if (typeof ee.description === 'string') ee.description = fixStr(ee.description);
      if (ee.footer && typeof ee.footer.text === 'string') ee.footer = { ...ee.footer, text: fixStr(ee.footer.text) };
      if (ee.author && typeof ee.author.name === 'string') ee.author = { ...ee.author, name: fixStr(ee.author.name) };
      if (Array.isArray(ee.fields)) ee.fields = ee.fields.map(f => {
        if (!f || typeof f !== 'object') return f;
        const ff = { ...f };
        if (typeof ff.name === 'string') ff.name = fixStr(ff.name).slice(0, 256);
        if (typeof ff.value === 'string') ff.value = fixStr(ff.value).slice(0, 1024);
        return ff;
      });
      return ee;
    });
  }
  return copy;
}

/**
 * Schedule object shape (stored in schedules.json):
 * {
 *   id: "1",
 *   name: "Reminder",
 *   channelId: "123...",
 *   message: "Hello world",
 *   type: "once" | "daily" | "weekly" | "monthly" | "interval",
 *   time: "HH:MM" (24h),
 *   date: "YYYY-MM-DD" (for once),
 *   days: [0..6] (for weekly, 0=Sunday),
 *   intervalDays: number (for interval),
 *   repeats: null | number (remaining repeats, null = infinite),
 *   enabled: true,
 *   nextRun: 1690000000000 (timestamp ms)
 * }
 */

function parseTimeToMsToday(timeStr) {
  // timeStr: "HH:MM"
  const [hh, mm] = (timeStr || "00:00").split(":").map(Number);
  const now = new Date();
  const t = new Date(now.getFullYear(), now.getMonth(), now.getDate(), hh || 0, mm || 0, 0, 0);
  return t.getTime();
}

function computeNextRun(schedule) {
  const now = Date.now();
  const type = schedule.type || "once";

  const timeMsOfDay = (() => {
    if (!schedule.time) return 0;
    const [hh = 0, mm = 0] = schedule.time.split(":").map(Number);
    return hh * 3600000 + (mm || 0) * 60000;
  })();

  if (type === "once") {
    if (schedule.date && schedule.time) {
      const [y, m, d] = schedule.date.split("-").map(Number);
  const [hh = 0, mm = 0] = (schedule.time || "00:00").split(":").map(Number);
  const next = new Date(y, (m || 1) - 1, d || 1, hh, mm, 0, 0);
  const ts = next.getTime();
  return ts > now ? ts : null; // if time is in the past, do not reschedule
    }
    // fallback: schedule.nextRun if present
    return schedule.nextRun || null;
  }

  if (type === "daily") {
    // today at time
    let candidate = new Date();
    candidate.setHours(...((schedule.time || "00:00").split(":").map(Number)), 0, 0);
    if (candidate.getTime() <= now) candidate = new Date(candidate.getTime() + 24 * 3600000);
    return candidate.getTime();
  }

  if (type === "interval") {
    // intervalDays and nextRun
    if (schedule.nextRun && schedule.nextRun > now) return schedule.nextRun;
    // schedule.intervalDays given
    const days = Math.max(1, Number(schedule.intervalDays) || 1);
    const base = schedule.nextRun && schedule.nextRun > 0 ? schedule.nextRun : now;
    return new Date(base + days * 24 * 3600000).getTime();
  }

  if (type === "weekly") {
    // schedule.days array of weekday numbers [0..6]
    const days = Array.isArray(schedule.days) && schedule.days.length ? schedule.days : [1]; // default Monday
    const nowDate = new Date();
    const [hh = 0, mm = 0] = (schedule.time || "00:00").split(":").map(Number);

    // search next 14 days for the next scheduled day/time
    for (let offset = 0; offset < 14; offset++) {
      const d = new Date(nowDate.getTime() + offset * 24 * 3600000);
      const wd = d.getDay(); // 0..6
      if (days.includes(wd)) {
        const candidate = new Date(d.getFullYear(), d.getMonth(), d.getDate(), hh, mm, 0, 0);
        if (candidate.getTime() > now) return candidate.getTime();
      }
    }
    // fallback
    return now + 24 * 3600000;
  }

  if (type === "monthly") {
    // schedule.dayOfMonth
    const day = Math.max(1, Number(schedule.dayOfMonth) || 1);
    const [hh = 0, mm = 0] = (schedule.time || "00:00").split(":").map(Number);
    const base = new Date();
    const year = base.getFullYear();
    const month = base.getMonth();
    const lastDayThisMonth = new Date(year, month + 1, 0).getDate();
    const dom = Math.min(day, lastDayThisMonth);
    let candidate = new Date(year, month, dom, hh, mm, 0, 0);
    if (candidate.getTime() <= now) {
      const nextMonth = month + 1;
      const lastDayNextMonth = new Date(year, nextMonth + 1, 0).getDate();
      const dom2 = Math.min(day, lastDayNextMonth);
      const next = new Date(year, nextMonth, dom2, hh, mm, 0, 0);
      return next.getTime();
    }
    return candidate.getTime();
  }

  return null;
}

async function runScheduleOnce(client, schedule) {
  try {
  const chId = config.testingMode ? (schedule.logChannelId || CONFIG_LOG_CHANNEL || schedule.channelId) : schedule.channelId;
  const channel = await client.channels.fetch(chId).catch(() => null);
    if (!channel || !channel.send) throw new Error("Invalid channel");
    // Best-effort dedup if loop jitter causes double fire
    try {
      const { seenRecently } = require('./sendOnce');
      const key = `sched:${schedule.id}:${chId}`;
      if (seenRecently(key, 8000)) return; // skip duplicate within 8s
    } catch {}
    // Support simple content or JSON payloads + timestamp placeholders
    // If messageJSON exists, prefer its content (even if empty) and do not fallback to the raw string in schedule.message.
    let content = '';
    if (schedule.messageJSON && typeof schedule.messageJSON === 'object') {
      let payload = { ...schedule.messageJSON };
      if (payload.embeds && !Array.isArray(payload.embeds)) payload.embeds = [payload.embeds];
      payload = applyPlaceholdersToJsonPayload(payload, schedule.eventRef || {});
      await channel.send(payload);
    } else {
      const raw = schedule.message || 'Scheduled message';
      content = applyTimestampPlaceholders(raw, schedule.eventRef || {});
      if (config.testingMode && content) content = content.replace(/<@&?\d+>/g, m=>`\`${m}\``);
      await channel.send({ content });
    }
    console.log(`Scheduled message sent for schedule ${schedule.id}`);
  } catch (err) {
    console.error("Failed to send scheduled message:", err);
  }
}

function computeAfterRun(schedule) {
  // manage repeats and compute nextRun or mark disabled/finished
  if (schedule.repeats !== null && typeof schedule.repeats !== "undefined") {
    schedule.repeats = Number(schedule.repeats) - 1;
    if (schedule.repeats <= 0) {
      schedule.enabled = false;
      schedule.nextRun = null;
      return schedule;
    }
  }
  // One-off schedules should disable after first run unless explicitly repeated
  if ((schedule.type || 'once') === 'once') {
    schedule.enabled = false;
    schedule.nextRun = null;
    return schedule;
  }
  // nextRun based on schedule type
  schedule.nextRun = computeNextRun(schedule);
  return schedule;
}

function startScheduler(client, opts = {}) {
  const tickInterval = opts.intervalMs || 15 * 1000;
  // Configurable clock-in dedup window (ms) via env or opts
  const CLOCKIN_DEDUP_MS = Number(process.env.CLOCKIN_DEDUP_MS) || opts.clockInDedupMs || (5 * 60 * 1000);
  const CLOCKIN_ORPHAN_MAX = Number(process.env.CLOCKIN_ORPHAN_MAX) || 10; // retain at most this many ids

  // ensure existing schedules have nextRun computed
  const schedules = getSchedules();
  for (const s of schedules) {
    if (!s.nextRun || s.nextRun < Date.now()) {
      const nr = computeNextRun(s);
      if (nr) updateSchedule(s.id, { nextRun: nr });
    }
  }

  setInterval(async () => {
    const list = getSchedules();
    const now = Date.now();
    for (const schedule of list) {
      try {
        if (!schedule.enabled) continue;
        if (!schedule.nextRun) {
          const nr = computeNextRun(schedule);
          await updateSchedule(schedule.id, { nextRun: nr });
          continue;
        }
        if (schedule.nextRun <= now + 5000) { // allow small drift
          await runScheduleOnce(client, schedule);
          const after = computeAfterRun({ ...schedule });
          await updateSchedule(schedule.id, after);
        }
      } catch (err) {
        console.error("Scheduler loop error for schedule", schedule.id, err);
      }
    }
    // Handle multi-daily events and dynamic anchor updates
    try {
      const events = getEvents();
      const nowDt = new Date();
      const currentDay = nowDt.getDay();
      const hh = nowDt.getHours().toString().padStart(2, "0");
      const mm = nowDt.getMinutes().toString().padStart(2, "0");
      const currentHM = `${hh}:${mm}`;
      for (const ev of events) {
        if (!ev.enabled) continue;
        if (ev.type !== "multi-daily") continue;
        if (Array.isArray(ev.days) && ev.days.length && !ev.days.includes(currentDay)) continue;
        if (!Array.isArray(ev.times)) continue;
        const now = Date.now();
        // Determine if we have anchor message semantics (single persistent message)
  const hasAnchor = ev.anchorMessageId && ev.anchorChannelId;
  // Parse potential ranges for status detection
        let status = 'upcoming'; // upcoming | open | closed (post)
        let activeRange = null;
        if (Array.isArray(ev.ranges) && ev.ranges.length) {
          for (const r of ev.ranges) {
            if (!r || !r.start || !r.end) continue;
            const [sh, sm] = r.start.split(':').map(n=>parseInt(n,10));
            const [eh, em] = r.end.split(':').map(n=>parseInt(n,10));
            if ([sh,sm,eh,em].some(n => Number.isNaN(n))) continue;
            const startMinutes = sh*60+sm;
            const endMinutes = eh*60+em;
            const curMinutes = parseInt(hh,10)*60+parseInt(mm,10);
            if (curMinutes >= startMinutes && curMinutes < endMinutes) { status='open'; activeRange = r; break; }
            if (curMinutes >= endMinutes) { status='closed'; }
          }
        } else {
          // Fallback: treat individual times as fire moments (legacy behavior)
          if (ev.times.includes(currentHM)) {
            const lastKey = `__lastFired_${currentHM}`;
            if (!(ev[lastKey] && now - ev[lastKey] < 60000)) {
              try {
                const channel = await client.channels.fetch(ev.channelId).catch(() => null);
                if (channel && channel.send && !hasAnchor) {
                  if (ev.messageJSON && typeof ev.messageJSON === 'object') {
                    const payload = { ...ev.messageJSON };
                    if (!payload.content && !payload.embeds) payload.content = ev.message || `Event: ${ev.name}`;
                    if (payload.content && payload.content.length > 2000) payload.content = payload.content.slice(0,1997)+'...';
                    if (payload.embeds && !Array.isArray(payload.embeds)) payload.embeds = [payload.embeds];
                    await channel.send(payload).catch(()=>{});
                  } else {
                    await channel.send({ content: ev.message || `Event: ${ev.name}` }).catch(()=>{});
                  }
                }
              } catch (e) { console.error('Event dispatch failed', ev.id, e); }
              ev[lastKey] = now; updateEvent(ev.id, { [lastKey]: now });
            }
          }
        }

        // --- Automated relative messages (autoMessages) ---
    if (Array.isArray(ev.autoMessages) && ev.autoMessages.length) {
          const curMinutes = parseInt(hh,10)*60 + parseInt(mm,10);
          for (const m of ev.autoMessages) {
            if (!m || !m.enabled) continue;
      // Skip if manually triggered recently and skip window active
      if (!config.testingMode && m.__skipUntil && m.__skipUntil > Date.now()) continue;
            const offset = Number(m.offsetMinutes)||0; // minutes before event time (0 = at start)
            for (const t of ev.times) {
              const [th, tm] = t.split(':').map(x=>parseInt(x,10));
              if (Number.isNaN(th) || Number.isNaN(tm)) continue;
              const eventStartMin = th*60+tm;
              // Skip offsets that would land on previous day to avoid midnight duplicates
              if (eventStartMin - offset < 0) continue;
              const targetMin = eventStartMin - offset;
              if (curMinutes === targetMin) {
                const fireKey = `__auto_${m.id}_${t}`;
                if (!(ev[fireKey] && now - ev[fireKey] < 60000)) {
                  try {
                    const targetChannelId = config.testingMode ? CONFIG_LOG_CHANNEL : (m.channelId || ev.channelId);
                    const channel = await client.channels.fetch(targetChannelId).catch(()=>null);
                    if (channel && channel.send) {
                      // TTL send guard to prevent duplicate racing across intervals
                      try {
                        const { seenRecently } = require('./sendOnce');
                        const k = `auto:${ev.id}:${m.id}:${t}:${targetChannelId}`;
                        if (seenRecently(k, 8000)) { throw new Error('dup_guard_skip'); }
                      } catch {}
                      // Clock-In special behavior
                      if (m.isClockIn) {
                        // Maintain per-event clockIn data structure: { positions: {key: [userId]}, messageIds:[], lastEventStart: timestamp }
                        // Modernized positions: Only Instance Master has a cap (1), others unlimited.
                        const POSITIONS = [
                          { key: 'instance_manager', label: '🗝️ Instance Master', short:'IM', max: 1 },
                          { key: 'manager', label: '🛠️ Manager', short:'M' },
                          { key: 'bouncer', label: '🛡️ Bouncer', short:'B' },
                          { key: 'bartender', label: '🍸 Bartender', short:'BT' },
                          { key: 'backup', label: '🎯 Backup', short:'BK' },
                          { key: 'maybe', label: '⏳ Maybe/Late', short:'?' }
                        ];
                        const clockKey = '__clockIn';
                        const state = ev[clockKey] && typeof ev[clockKey]==='object' ? ev[clockKey] : { positions: {}, messageIds: [] };
                        for (const p of POSITIONS) { if (!Array.isArray(state.positions[p.key])) state.positions[p.key] = []; }
                        // --- Deduplication: skip sending if a recent clock-in message already exists ---
                        try {
                          const DEDUP_MS = CLOCKIN_DEDUP_MS;
                          let recentOk = false;
                          const nowTs = Date.now();
                          if (state.lastSentTs && (nowTs - state.lastSentTs) < DEDUP_MS) {
                            recentOk = true;
                          }
                          // Fallback: probe last message id if timestamp missing
                          if (!recentOk && Array.isArray(state.messageIds) && state.messageIds.length) {
                            const lastId = state.messageIds[state.messageIds.length - 1];
                            try {
                              const lastMsg = await channel.messages.fetch(lastId).catch(()=>null);
                              if (lastMsg) {
                                // If last message younger than dedup window, skip
                                if (nowTs - lastMsg.createdTimestamp < DEDUP_MS) recentOk = true;
                              }
                            } catch {}
                          }
                          if (recentOk) {
                            // Ensure state persisted (positions may have changed earlier) but do not send duplicate
                            updateEvent(ev.id, { [clockKey]: state });
                            continue; // skip creating a new clock-in embed
                          }
                        } catch {}
                        // Build embed JSON per the required template
                        const fmtMentions = (arr=[]) => {
                          if (!Array.isArray(arr) || arr.length === 0) return '*None*';
                          const s = arr.map(id=>`<@${id}>`).join(', ');
                          return config.testingMode ? s.replace(/<@&?\d+>/g, m=>`\`${m}\``) : s;
                        };
                        const nameSafe = ev.name || 'Event';
                        const embed = {
                          title: `🕒 Staff Clock In — ${nameSafe}`,
                          description: 'Please select your role below to clock in.\n\n**Instance Manager** is responsible for opening, managing and closing an instance.',
                          color: 3447003,
                          fields: [
                            { name: '📝 Instance Manager (1 slot)', value: `${(state.positions.instance_manager||[]).length} / 1\n${fmtMentions(state.positions.instance_manager)}`, inline: false },
                            { name: '🛠️ Manager',   value: fmtMentions(state.positions.manager),   inline: true },
                            { name: '🛡️ Bouncer',   value: fmtMentions(state.positions.bouncer),   inline: true },
                            { name: '🍸 Bartender', value: fmtMentions(state.positions.bartender), inline: true },
                            { name: '🎯 Backup',    value: fmtMentions(state.positions.backup),    inline: true },
                            { name: '⏳ Maybe / Late', value: fmtMentions(state.positions.maybe), inline: false },
                            { name: 'Eligible roles', value: '<@&1375995842858582096>, <@&1380277718091829368>, <@&1380323145621180466>, <@&1375958480380493844>' }
                          ],
                          footer: { text: `Late Night Hours | Staff clock in for ${nameSafe}` }
                        };
                        const menu = new StringSelectMenuBuilder()
                          .setCustomId(`clockin:${ev.id}:${m.id}`)
                          .setPlaceholder('📋 Select your position')
                          .addOptions([
                            { label: 'Instance Manager', value: 'instance_manager', description: '1 slot available', emoji: { name: '📝' } },
                            { label: 'Manager',          value: 'manager',                              emoji: { name: '🛠️' } },
                            { label: 'Bouncer',          value: 'bouncer',                              emoji: { name: '🛡️' } },
                            { label: 'Bartender',        value: 'bartender',                            emoji: { name: '🍸' } },
                            { label: 'Backup',           value: 'backup',                               emoji: { name: '🎯' } },
                            { label: 'Maybe / Late',     value: 'maybe',                                emoji: { name: '⏳' } }
                          ]);
                        const row = new ActionRowBuilder().addComponents(menu);
                        const sent = await channel.send({ content: '', embeds: [embed], components: [row] }).catch(()=>null);
                        if (sent) {
                          state.messageIds.push(sent.id);
                          // Cleanup orphaned / non-existent ids beyond cap
                          if (state.messageIds.length > CLOCKIN_ORPHAN_MAX) state.messageIds = state.messageIds.slice(-CLOCKIN_ORPHAN_MAX);
                          state.lastSentTs = Date.now();
                          state.channelId = targetChannelId;
                          updateEvent(ev.id, { [clockKey]: state });
                        }
                      } else if (m.messageJSON && typeof m.messageJSON === 'object') {
                        let payload = { ...m.messageJSON };
                        if (payload.embeds && !Array.isArray(payload.embeds)) payload.embeds = [payload.embeds];
                        payload = applyPlaceholdersToJsonPayload(payload, ev);
                        if (!payload.content && !payload.embeds) payload.content = m.message || `Auto message (${ev.name})`;
                        const sent = await channel.send(payload).catch(()=>null);
                        // Optional auto-delete (skip for testing)
                        try {
                          const delMs = Number(m.deleteAfterMs ?? (config.autoMessages?.defaultDeleteMs || 0));
                          if (!config.testingMode && sent && delMs > 0) {
                            setTimeout(() => { try { sent.delete().catch(()=>{}); } catch {} }, delMs);
                          }
                        } catch {}
                        // Track message for later refresh
                        try {
                          if (sent && sent.id) {
                            const map = ev.__notifMsgs && typeof ev.__notifMsgs==='object' ? { ...ev.__notifMsgs } : {};
                            const rec = map[m.id] && typeof map[m.id]==='object' ? { ...map[m.id] } : { channelId: channel.id, ids: [] };
                            rec.channelId = channel.id;
                            rec.ids = Array.isArray(rec.ids) ? rec.ids : [];
                            rec.ids.push(sent.id);
                            if (rec.ids.length > 20) rec.ids = rec.ids.slice(-20);
                            map[m.id] = rec;
                            updateEvent(ev.id, { __notifMsgs: map });
                          }
                        } catch {}
                      } else {
                        const raw = m.message || `Auto message (${ev.name})`;
                        let content = applyTimestampPlaceholders(raw, ev);
                        if (config.testingMode) content = content.replace(/<@&?\d+>/g, m=>`\`${m}\``);
                        const sent = await channel.send({ content }).catch(()=>null);
                        // Optional auto-delete (skip for testing)
                        try {
                          const delMs = Number(m.deleteAfterMs ?? (config.autoMessages?.defaultDeleteMs || 0));
                          if (!config.testingMode && sent && delMs > 0) {
                            setTimeout(() => { try { sent.delete().catch(()=>{}); } catch {} }, delMs);
                          }
                        } catch {}
                        // Track message for later refresh
                        try {
                          if (sent && sent.id) {
                            const map = ev.__notifMsgs && typeof ev.__notifMsgs==='object' ? { ...ev.__notifMsgs } : {};
                            const rec = map[m.id] && typeof map[m.id]==='object' ? { ...map[m.id] } : { channelId: channel.id, ids: [] };
                            rec.channelId = channel.id;
                            rec.ids = Array.isArray(rec.ids) ? rec.ids : [];
                            rec.ids.push(sent.id);
                            if (rec.ids.length > 20) rec.ids = rec.ids.slice(-20);
                            map[m.id] = rec;
                            updateEvent(ev.id, { __notifMsgs: map });
                          }
                        } catch {}
                      }
                    }
                  } catch (e) {
                    if ((e && String(e.message||e).includes('dup_guard_skip'))) {
                      // skip silently
                    } else {
                      console.error('Auto message dispatch failed', ev.id, m.id, e);
                    }
                  }
                  ev[fireKey] = now; updateEvent(ev.id, { [fireKey]: now });
                }
              }
            }
          }
        }

        // Dynamic anchor update
        if (hasAnchor) {
          try {
            const channel = await client.channels.fetch(ev.anchorChannelId).catch(()=>null);
            if (channel) {
              const msg = await channel.messages.fetch(ev.anchorMessageId).catch(()=>null);
              if (msg) {
                let baseContent = ev.dynamicBaseContent || ev.messageJSON?.content || ev.message || '';
                baseContent = applyTimestampPlaceholders(baseContent, ev);
                if (!baseContent) baseContent = `Event: ${ev.name}`;
                let newContent = baseContent;
                // Replace status line tokens
                // Match entire status line beginning with header (case-insensitive)
                // Match any existing status line variant so we can replace consistently
                const OPEN_TOKEN = /^(# The Midnight bar is.*|🍷The Midnight Bar is currently open!🍷|The Midnight Bar is closed for now\.)$/im;
                if (status === 'open') {
                  newContent = newContent.replace(OPEN_TOKEN, '🍷The Midnight Bar is currently open!🍷');
                } else if (status === 'closed') {
                  try {
                    const { computeNextRange } = require('./timestampPlaceholders');
                    const next = computeNextRange(ev);
                    if (next && OPEN_TOKEN.test(newContent)) {
                      newContent = newContent.replace(OPEN_TOKEN, `# The Midnight bar is opening: <t:${next.startSec}:R>`);
                    } else if (OPEN_TOKEN.test(newContent)) {
                      // Fallback if we cannot compute next
                      newContent = newContent.replace(OPEN_TOKEN, '# The Midnight bar is opening: (soon)');
                    }
                  } catch {
                    if (OPEN_TOKEN.test(newContent)) newContent = newContent.replace(OPEN_TOKEN, '# The Midnight bar is opening: (soon)');
                  }
                } else if (status === 'upcoming') {
                  try {
                    const { computeNextRange } = require('./timestampPlaceholders');
                    const range = computeNextRange(ev);
                    if (range && OPEN_TOKEN.test(newContent)) {
                      const relTs = `<t:${range.startSec}:R>`;
                      newContent = newContent.replace(OPEN_TOKEN, `# The Midnight bar is opening in ${relTs}`);
                    }
                  } catch {}
                }
                // Minimal change detection
                if (newContent !== msg.content) {
                  if (ev.messageJSON) {
                    const payload = { ...ev.messageJSON, content: newContent };
                    if (payload.embeds && !Array.isArray(payload.embeds)) payload.embeds = [payload.embeds];
                    await msg.edit(payload).catch(()=>{});
                  } else {
                    await msg.edit({ content: newContent }).catch(()=>{});
                  }
                }
              }
            }
          } catch (e) { /* ignore anchor update errors */ }
        }
        // Periodic prune of stale clock-in message IDs (deleted messages)
    try {
          if (ev.__clockIn && Array.isArray(ev.__clockIn.messageIds)) {
            const pruneInterval = 5 * 60 * 1000; // 5m
            const nowTs = Date.now();
            if (!ev.__clockIn.lastPruneTs || (nowTs - ev.__clockIn.lastPruneTs) > pruneInterval) {
      const chId = ev.__clockIn.channelId || ev.channelId;
      const channel = chId ? await client.channels.fetch(chId).catch(()=>null) : null;
              if (channel && channel.messages) {
                const kept = [];
                for (const mid of ev.__clockIn.messageIds.slice(-10)) { // only check recent subset
                  const exists = await channel.messages.fetch(mid).then(()=>true).catch(()=>false);
                  if (exists) kept.push(mid);
                }
                if (kept.length !== ev.__clockIn.messageIds.length) {
                  ev.__clockIn.messageIds = kept;
                  ev.__clockIn.lastPruneTs = nowTs;
                  updateEvent(ev.id, { __clockIn: ev.__clockIn });
                } else {
                  ev.__clockIn.lastPruneTs = nowTs;
                  updateEvent(ev.id, { __clockIn: ev.__clockIn });
                }
              }
            }
          }
        } catch {}
      }
    } catch (e) { /* ignore event errors */ }
  }, tickInterval);
}

module.exports = {
  startScheduler,
  computeNextRun,
  computeAfterRun
};

```

===== FILE: utils/sendOnce.js =====
```javascript
// Simple in-memory TTL-based send guard to avoid duplicate sends in race conditions
// Keyed by a caller-provided key, e.g., `${scope}:${channelId}:${eventId}:${notifId}`
// Expires entries after ttlMs. Safe in single-process use; if you shard/process separately,
// consider replacing with a shared store.

const _seen = new Map(); // key -> timestamp

function seenRecently(key, ttlMs = 30000) {
  const now = Date.now();
  // prune sometimes
  if (_seen.size > 2000) {
    for (const [k, ts] of _seen) {
      if (now - ts > ttlMs) _seen.delete(k);
    }
  }
  const last = _seen.get(key) || 0;
  if (now - last < ttlMs) return true;
  _seen.set(key, now);
  return false;
}

module.exports = { seenRecently };

```

===== FILE: utils/shutdownState.js =====
```javascript
const fs = require('fs');
const FILE = './config/lastShutdown.json';

function recordShutdown() {
  try { fs.writeFileSync(FILE, JSON.stringify({ ts: Date.now() })); } catch {}
}

function readLastShutdown() {
  try { if (fs.existsSync(FILE)) return JSON.parse(fs.readFileSync(FILE,'utf8')).ts || null; } catch {}
  return null;
}

module.exports = { recordShutdown, readLastShutdown };

```

===== FILE: utils/singleton.js =====
```javascript
const fs = require('fs');
const path = require('path');

const LOCK_FILE = path.join(__dirname, '..', '.miyako.lock');

function pidAlive(pid) {
  if (!pid) return false;
  try { process.kill(pid, 0); return true; } catch { return false; }
}

function ensureSingleton() {
  try {
    if (fs.existsSync(LOCK_FILE)) {
      try {
        const data = JSON.parse(fs.readFileSync(LOCK_FILE, 'utf8'));
        if (data && pidAlive(data.pid)) {
          console.error(`[singleton] Another Miyako instance appears to be running (PID ${data.pid}). Aborting.`);
          process.exit(1);
        } else {
          // stale lock
          fs.unlinkSync(LOCK_FILE);
        }
      } catch { /* ignore parse errors; treat as stale */ fs.unlinkSync(LOCK_FILE); }
    }
    fs.writeFileSync(LOCK_FILE, JSON.stringify({ pid: process.pid, started: Date.now() }));
    const cleanup = () => { try { if (fs.existsSync(LOCK_FILE)) fs.unlinkSync(LOCK_FILE); } catch {}; };
    process.once('exit', cleanup);
    process.once('SIGINT', () => { cleanup(); process.exit(0); });
    process.once('SIGTERM', () => { cleanup(); process.exit(0); });
  } catch (e) {
    console.warn('[singleton] lock error (continuing anyway):', e.message);
  }
}

module.exports = { ensureSingleton };

```

===== FILE: utils/staffTeam.js =====
```javascript
const { ROLES, ROLE_ORDER, ROLE_EMOJIS, CHANNEL_ID } = require("../config/roles");
const { ActionRowBuilder, ButtonBuilder, ButtonStyle } = require("discord.js");
const { STAFF_MANAGER_ROLE, STAFF_SECURITY_ROLE, STAFF_MODERATOR_ROLE, STAFF_STAFF_ROLE, STAFF_ADMIN_ROLE, ALLOWED_ROLES, CHATBOX_BUTTON_ID } = require("../commands/moderation/permissions");

const BOT_PREFIX = "**🌙 Late Night Hours Staff Team**\n\n";

// Reuse centralized constants for roles and chatbox button; keep channel from roles config

const formatMembersListInline = (membersArray) =>
  membersArray.length ? membersArray.map(m => `<@${m.id}>`).join(", ") : "*None*";

const generateStaffList = async (guild) => {
  await guild.members.fetch();
  let alreadyListed = new Set();
  let output = BOT_PREFIX;

  for (const roleName of ROLE_ORDER) {
    const roleId = ROLES[roleName];
    const emoji = ROLE_EMOJIS[roleName] || "";
    const roleMention = `<@&${roleId}>`;

    const members = guild.members.cache.filter(
      m => m.roles.cache.has(roleId) && !alreadyListed.has(m.id)
    );
    members.forEach(m => alreadyListed.add(m.id));
    const memberList = formatMembersListInline([...members.values()]);

    let header = "# ";
    if (roleName === "Manager" || roleName === "Security") header = "## ";
    if (["Staff","Trainee","Inactive"].includes(roleName)) header = "### ";

    output += `${header}${emoji} ${roleMention} (${members.size})\n${memberList}\n\n`;
  }
  return output;
};

const getStaffMessageRow = () =>
  new ActionRowBuilder().addComponents(
    new ButtonBuilder()
      .setCustomId(CHATBOX_BUTTON_ID)
      .setLabel("Open Staff Chatbox")
      .setStyle(ButtonStyle.Primary)
      .setEmoji("💬")
  );

const updateStaffMessage = async (guild) => {
  try {
    const channel = await guild.channels.fetch(CHANNEL_ID);
    let messages = await channel.messages.fetch({ limit: 50 });
    let staffMessage = messages.find(msg => msg.author.id === guild.client.user.id && msg.content.startsWith(BOT_PREFIX));
    const newContent = await generateStaffList(guild);

    if (staffMessage) {
      await staffMessage.edit({ content: newContent, components: [getStaffMessageRow()] });
    } else {
      staffMessage = await channel.send({ content: newContent, components: [getStaffMessageRow()] });
      try { await staffMessage.pin(); } catch {}
    }
    return staffMessage;
  } catch (err) { console.error("Failed to update staff message:", err); return null; }
};

module.exports = {
  updateStaffMessage,
  ALLOWED_ROLES,
  CHATBOX_BUTTON_ID
};

```

===== FILE: utils/storage.js =====
```javascript
const fs = require("fs");
const path = require("path");

const CONFIG_FILE = path.resolve("./config/botConfig.json");

// Default configuration
const defaultConfig = {
  snipingWhitelist: [],
  moderatorRoles: [],
  warnings: {},
  escalation: {
    muteThreshold: 3,
    muteDuration: 2 * 60 * 60 * 1000,
    kickThreshold: 5
  },
  defaultMuteDuration: 60 * 60 * 1000,
  modLogChannelId: "1232701768383729791",
  testingMode: false,
  roleLogBlacklist: [],
  snipeMode: "whitelist",
  snipingChannelList: [],
  // Level rewards: { [level]: string[] }
  levelRewards: {},
  // VC Level rewards: { [level]: string[] }
  vcLevelRewards: {},
  // Leveling gating
  levelingMode: "blacklist",
  levelingChannelList: [],
  // Leveling role blacklist and multiplier
  roleXPBlacklist: [],
  globalXPMultiplier: 1.0,
  // Economy: cash drops
  cashDrops: {
    dropChance: 0.02, // 2% per message
    minAmount: 25,
    maxAmount: 125,
    lifetimeMs: 60 * 1000,
  },
  maxPurgeLimit: 100,
  blacklistedChannels: [],
  moderatorLogChannelId: null,
  // Auto-messages: default delete-after (ms); 0 disables auto-deletion
  autoMessages: {
    defaultDeleteMs: 0
  }
};

// Setting metadata (timestamps, etc.) persisted separately
let settingMeta = {};
const SETTING_META_FILE = path.resolve('./config/settingMeta.json');
try {
  if (fs.existsSync(SETTING_META_FILE)) {
    settingMeta = JSON.parse(fs.readFileSync(SETTING_META_FILE,'utf8')) || {};
  }
} catch { settingMeta = {}; }
function saveSettingMeta() {
  try { fs.writeFileSync(SETTING_META_FILE, JSON.stringify(settingMeta, null, 2)); } catch {}
}
function touchSettingMeta(key) {
  settingMeta[key] = { lastUpdated: Date.now() };
  saveSettingMeta();
}

function ensureDir() {
  const dir = path.dirname(CONFIG_FILE);
  if (!fs.existsSync(dir)) fs.mkdirSync(dir, { recursive: true });
}

function validateConfig(cfg) {
  if (!Array.isArray(cfg.snipingWhitelist)) cfg.snipingWhitelist = [];
  if (!Array.isArray(cfg.moderatorRoles)) cfg.moderatorRoles = [];
  if (typeof cfg.warnings !== "object" || cfg.warnings === null) cfg.warnings = {};
  if (typeof cfg.escalation !== "object" || cfg.escalation === null) cfg.escalation = { ...defaultConfig.escalation };
  if (typeof cfg.defaultMuteDuration !== "number") cfg.defaultMuteDuration = defaultConfig.defaultMuteDuration;
  if (typeof cfg.modLogChannelId !== "string") cfg.modLogChannelId = defaultConfig.modLogChannelId;
  if (typeof cfg.testingMode !== "boolean") cfg.testingMode = false;
  if (!Array.isArray(cfg.roleLogBlacklist)) cfg.roleLogBlacklist = [];
  if (["whitelist", "blacklist"].includes(cfg.snipeMode) === false) cfg.snipeMode = "whitelist";
  if (!Array.isArray(cfg.snipingChannelList)) cfg.snipingChannelList = [];
  if (typeof cfg.levelRewards !== "object" || cfg.levelRewards === null) cfg.levelRewards = {};
  if (typeof cfg.vcLevelRewards !== "object" || cfg.vcLevelRewards === null) cfg.vcLevelRewards = {};
  if (["whitelist", "blacklist"].includes(cfg.levelingMode) === false) cfg.levelingMode = "blacklist";
  if (!Array.isArray(cfg.levelingChannelList)) cfg.levelingChannelList = [];
  if (!Array.isArray(cfg.roleXPBlacklist)) cfg.roleXPBlacklist = [];
  if (typeof cfg.globalXPMultiplier !== "number" || !Number.isFinite(cfg.globalXPMultiplier)) cfg.globalXPMultiplier = 1.0;
  if (typeof cfg.maxPurgeLimit !== 'number' || cfg.maxPurgeLimit <= 0) cfg.maxPurgeLimit = 100;
  if (!Array.isArray(cfg.blacklistedChannels)) cfg.blacklistedChannels = [];
  if (cfg.moderatorLogChannelId && typeof cfg.moderatorLogChannelId !== 'string') cfg.moderatorLogChannelId = String(cfg.moderatorLogChannelId);

  // Command logging defaults
  if (typeof cfg.commandLogging !== 'object' || cfg.commandLogging === null) cfg.commandLogging = {};
  if (typeof cfg.commandLogging.enabled !== 'boolean') cfg.commandLogging.enabled = false;
  if (!Number.isFinite(cfg.commandLogging.maxEntries)) cfg.commandLogging.maxEntries = 500;
  if (typeof cfg.commandLogging.testingCompare !== 'boolean') cfg.commandLogging.testingCompare = true;
  if (!cfg.commandLogging.logChannelId) cfg.commandLogging.logChannelId = null;
  if (!Number.isFinite(cfg.commandLogging.sendIntervalMs)) cfg.commandLogging.sendIntervalMs = 5000;

  // Auto-messages defaults
  if (typeof cfg.autoMessages !== 'object' || cfg.autoMessages === null) cfg.autoMessages = { ...defaultConfig.autoMessages };
  if (!Number.isFinite(cfg.autoMessages.defaultDeleteMs) || cfg.autoMessages.defaultDeleteMs < 0) cfg.autoMessages.defaultDeleteMs = 0;

  // Sanitize levelRewards to { "level": [roleIds] }
  const cleanedRewards = {};
  for (const [lvl, val] of Object.entries(cfg.levelRewards)) {
    const n = Number(lvl);
    if (!Number.isFinite(n) || n <= 0) continue;
    const arr = Array.isArray(val) ? val : (val ? [val] : []);
    const roleIds = arr
      .map(v => (typeof v === "string" ? v : String(v || "")))
      .map(s => s.replace(/[^0-9]/g, ""))
      .filter(Boolean);
    if (roleIds.length) cleanedRewards[String(n)] = Array.from(new Set(roleIds));
  }
  cfg.levelRewards = cleanedRewards;

  // Sanitize vcLevelRewards similarly
  const cleanedVCRewards = {};
  for (const [lvl, val] of Object.entries(cfg.vcLevelRewards)) {
    const n = Number(lvl);
    if (!Number.isFinite(n) || n <= 0) continue;
    const arr = Array.isArray(val) ? val : (val ? [val] : []);
    const roleIds = arr
      .map(v => (typeof v === "string" ? v : String(v || "")))
      .map(s => s.replace(/[^0-9]/g, ""))
      .filter(Boolean);
    if (roleIds.length) cleanedVCRewards[String(n)] = Array.from(new Set(roleIds));
  }
  cfg.vcLevelRewards = cleanedVCRewards;

  // Ensure escalation sub-keys
  if (typeof cfg.escalation.muteThreshold !== "number") cfg.escalation.muteThreshold = defaultConfig.escalation.muteThreshold;
  if (typeof cfg.escalation.muteDuration !== "number") cfg.escalation.muteDuration = defaultConfig.escalation.muteDuration;
  if (typeof cfg.escalation.kickThreshold !== "number") cfg.escalation.kickThreshold = defaultConfig.escalation.kickThreshold;

  // Validate economy.cashDrops
  if (typeof cfg.cashDrops !== 'object' || cfg.cashDrops === null) cfg.cashDrops = { ...defaultConfig.cashDrops };
  const e = cfg.cashDrops;
  const clamp = (x, lo, hi) => Math.max(lo, Math.min(hi, x));
  e.dropChance = Number.isFinite(e.dropChance) ? clamp(e.dropChance, 0, 1) : defaultConfig.cashDrops.dropChance;
  e.minAmount = Number.isFinite(e.minAmount) ? Math.max(0, Math.floor(e.minAmount)) : defaultConfig.cashDrops.minAmount;
  e.maxAmount = Number.isFinite(e.maxAmount) ? Math.max(e.minAmount, Math.floor(e.maxAmount)) : Math.max(e.minAmount, defaultConfig.cashDrops.maxAmount);
  e.lifetimeMs = Number.isFinite(e.lifetimeMs) ? Math.max(5 * 1000, Math.floor(e.lifetimeMs)) : defaultConfig.cashDrops.lifetimeMs;

  cfg.cashDrops = e;

  return cfg;
}

let config = { ...defaultConfig };

try {
  if (fs.existsSync(CONFIG_FILE)) {
    const loaded = JSON.parse(fs.readFileSync(CONFIG_FILE, "utf8"));

    // Some past corruption placed defaults inside escalation; flatten if necessary
    const cleaned = { ...loaded };
    if (cleaned.escalation && typeof cleaned.escalation === "object") {
      for (const k of [
        "snipingWhitelist","moderatorRoles","warnings","defaultMuteDuration",
        "modLogChannelId","testingMode","roleLogBlacklist","snipeMode","snipingChannelList"
      ]) {
        if (k in cleaned.escalation) delete cleaned.escalation[k];
      }
    }

    config = validateConfig({
      ...defaultConfig,
      ...cleaned,
      escalation: { ...defaultConfig.escalation, ...(cleaned.escalation || {}) }
    });
  } else {
    ensureDir();
    fs.writeFileSync(CONFIG_FILE, JSON.stringify(defaultConfig, null, 2));
    config = { ...defaultConfig };
  }
} catch (err) {
  console.error("[Config] Failed to read/parse config, rewriting defaults:", err?.message || err);
  try {
    ensureDir();
    fs.writeFileSync(CONFIG_FILE, JSON.stringify(defaultConfig, null, 2));
  } catch {}
  config = { ...defaultConfig };
}

function saveConfig() {
  try {
    ensureDir();
    fs.writeFileSync(CONFIG_FILE, JSON.stringify(validateConfig({ ...config }), null, 2));
  } catch (err) {
    console.error("[Config] Failed to save config:", err?.message || err);
  }
}

module.exports = { config, saveConfig };
module.exports.settingMeta = settingMeta;
module.exports.touchSettingMeta = touchSettingMeta;

```

===== FILE: utils/testingBanner.js =====
```javascript
const { EmbedBuilder } = require("discord.js");
const { CONFIG_LOG_CHANNEL } = require("./logChannels");
const theme = require("./theme");
const { applyStandardFooter } = require("./ui");

async function updateTestingStatus(client, enabled, actor) {
  try {
    const channel = await client.channels.fetch(CONFIG_LOG_CHANNEL).catch(() => null);
    if (!channel) return;

    const embed = new EmbedBuilder()
      .setTitle(enabled ? `${theme.emojis.warn} Testing Mode Enabled` : `${theme.emojis.success} Testing Mode Disabled`)
      .setColor(enabled ? theme.colors.warning : theme.colors.primary)
      .setDescription(
        enabled
          ? `Certain logs will be routed to the test channel. The warnings UI may use seeded data.${actor ? `\nTriggered by: <@${actor.id}>` : ""}`
          : `Bot has returned to normal operation.${actor ? `\nTriggered by: <@${actor.id}>` : ""}`
      )
      .setTimestamp();

    applyStandardFooter(embed, channel.guild, { testingMode: enabled });

    await channel.send({ embeds: [embed], allowedMentions: { parse: [] } }).catch(() => {});
  } catch (err) {
    // noop: avoid throwing on banner update
  }
}

module.exports = { updateTestingStatus };

```

===== FILE: utils/text.js =====
```javascript
// Text / string utilities centralizing shared helpers to avoid circular deps.
function toTitleCase(str) {
  if (!str) return str;
  return String(str)
    .replace(/[_\-]+/g, ' ')
    .split(/\s+/)
    .map(w => w.length ? w[0].toUpperCase() + w.slice(1).toLowerCase() : w)
    .join(' ')
    .trim();
}

module.exports = { toTitleCase };

```

===== FILE: utils/theme.js =====
```javascript
// Centralized theme: colors and emojis used across embeds (now supports external override config/theme.json)
const fs = require('fs');
const path = require('path');
const { cfgPath } = require('./paths');
let external = null;
try {
  const ext = cfgPath('theme.json');
  if (fs.existsSync(ext)) external = JSON.parse(fs.readFileSync(ext,'utf8'));
} catch { external = null; }

const baseTheme = {
  colors: {
    primary: 0x5865F2,
    success: 0x00ff00,
    warning: 0xffd700,
    danger: 0xff5555,
    neutral: 0x2f3136,
  },
  emojis: {
    // Generic status
    info: "ℹ️",
    success: "✅",
    warn: "⚠️",
    danger: "🚨",
    error: "❌",
    // Time / meta
    duration: "⏰",
    counter: "🧮",
    id: "🆔",
    // CRUD / navigation
    create: "➕",
    delete: "➖",
    back: "⬅️",
    select: "🎯",
    events: "📅",
    times: "🕒",
    days: "📅",
    message: "📝",
    enable: "✅",
    disable: "🛑",
    toggle: "🔁",
    settings: "⚙️",
    edit: "✏️",
    // Profile / leveling / economy
    profile: "👤",
    rank: "📊",
    leaderboard: "🏆",
    bank: "🏦",
    cash: "💸",
    deposit: "📈",
    withdraw: "📉",
    vc: "🎙️",
    text: "💬",
    // Moderation / targets
    action: "🧰",
    target: "🎯",
    moderator: "🛡️",
    mute: "🔇",
    unmute: "🔊",
    kick: "👢",
    ban: "🔨"
  }
};

const theme = Object.assign({}, baseTheme, external || {});
theme.color = function(name, fallback = 0x2f3136) { return (theme.colors||{})[name] ?? fallback; };
theme.emoji = function(name, fallback = '❔') { return (theme.emojis||{})[name] ?? fallback; };
module.exports = theme;

```

===== FILE: utils/time.js =====
```javascript
const ms = require("ms");

function parseDurationAndReason(args) {
  let duration = null;
  let reasonParts = [];
  for (const arg of args) {
    const parsed = ms(arg);
    if (parsed && !duration) {
      duration = parsed;
    } else {
      reasonParts.push(arg);
    }
  }
  const reason = reasonParts.join(" ").trim() || null;
  return { duration, reason };
}

module.exports = {
  parseDurationAndReason,
  ms
};
```

===== FILE: utils/timestampPlaceholders.js =====
```javascript
// Utility to substitute dynamic timestamp placeholders inside event messages.
// Placeholders supported (case sensitive):
//  - timestamp_opening1 : opening time for first range (or first time entry)
//  - closing1 / timestamp_closing1 : closing time for first range (or second time entry / +2h fallback)
//  - timestamp_opening2 / opening2 : static placeholder provided by user (not yet dynamic)
//  - closing2 / timestamp_closing2 : static placeholder provided by user (not yet dynamic)
// Additional forms can be added easily.

function parseHM(str) {
  if (!str) return { h:0, m:0, ok:false };
  const [h,m] = str.split(':').map(x=>parseInt(x,10));
  if (Number.isNaN(h) || Number.isNaN(m)) return { h:0, m:0, ok:false };
  return { h, m, ok:true };
}

function computeNextRange(ev) {
  const now = new Date();
  // Determine days list; if empty treat all days
  const days = Array.isArray(ev.days) && ev.days.length ? ev.days : [0,1,2,3,4,5,6];
  let startDate = null, endDate = null;
  if (Array.isArray(ev.ranges) && ev.ranges.length) {
    const r = ev.ranges[0];
    if (r && r.start && r.end) {
      const { h:sh, m:sm, ok:okS } = parseHM(r.start);
      const { h:eh, m:em, ok:okE } = parseHM(r.end);
      if (okS && okE) {
        for (let offset=0; offset<30; offset++) {
          const d = new Date(now.getFullYear(), now.getMonth(), now.getDate()+offset, 0,0,0,0);
            if (!days.includes(d.getDay())) continue;
            const s = new Date(d.getFullYear(), d.getMonth(), d.getDate(), sh, sm, 0, 0);
            const e = new Date(d.getFullYear(), d.getMonth(), d.getDate(), eh, em, 0, 0);
            // If end <= start (overnight), push end to next day
            if (e <= s) e.setDate(e.getDate()+1);
            // Accept first future start or ongoing range today
            if (s.getTime() >= now.getTime() - 5*60*1000) { // allow slight past for current range
              startDate = s; endDate = e; break;
            }
        }
      }
    }
  }
  if (!startDate) {
    // Fallback to times
    const times = Array.isArray(ev.times) ? ev.times.filter(Boolean) : [];
    if (times.length) {
      const { h:sh, m:sm, ok:okS } = parseHM(times[0]);
      let eh=sh+2, em=sm; // +2h fallback
      if (times[1]) { const t2 = parseHM(times[1]); if (t2.ok) { eh=t2.h; em=t2.m; } }
      if (okS) {
        for (let offset=0; offset<30; offset++) {
          const d = new Date(now.getFullYear(), now.getMonth(), now.getDate()+offset, 0,0,0,0);
          if (!days.includes(d.getDay())) continue;
          const s = new Date(d.getFullYear(), d.getMonth(), d.getDate(), sh, sm, 0, 0);
          const e = new Date(d.getFullYear(), d.getMonth(), d.getDate(), eh, em, 0, 0);
          if (e <= s) e.setHours(e.getHours()+2);
          if (s.getTime() >= now.getTime() - 5*60*1000) { startDate = s; endDate = e; break; }
        }
      }
    }
  }
  if (!startDate) return null;
  return { startSec: Math.floor(startDate.getTime()/1000), endSec: Math.floor(endDate.getTime()/1000) };
}

function buildTimestampMap(ev) {
  const map = {};
  const r = computeNextRange(ev);
  if (r) {
    map.timestamp_opening1 = `<t:${r.startSec}:t>`;
    map.opening1 = map.timestamp_opening1;
    map.closing1 = `<t:${r.endSec}:t>`;
    map.timestamp_closing1 = map.closing1;
  // Backwards compatible aliases (timestamp_* only; avoid bare common words)
  map.timestamp_opening = map.timestamp_opening1;
  map.timestamp_closing = map.timestamp_closing1;
  // Additional close alias requested: timestamp_close -> timestamp_closing1
  map.timestamp_close = map.timestamp_closing1;
  }
  // Static placeholders for second opening per user instruction
  map.timestamp_opening2 = '<t:1757412000:t>';
  map.opening2 = map.timestamp_opening2;
  map.closing2 = '<t:1757433600:t>';
  map.timestamp_closing2 = map.closing2;
  return map;
}

function applyTimestampPlaceholders(text, ev) {
  if (!text || typeof text !== 'string') return text;
  const map = buildTimestampMap(ev);
  let out = text;
  // First, handle angle-bracket tokens like <timestamp_close:t> or <timestamp_closing:t>
  // We only rewrite those we know, leaving others as-is.
  out = out.replace(/<\s*(timestamp_(?:opening|closing|open|close)\d?|opening\d?|closing\d?|timestamp_(?:opening|closing)|timestamp_close)\s*:\s*t\s*>/g, (m, p1) => {
    const key = String(p1).replace(/\s+/g, '');
    const replacement = map[key] || null;
    return replacement ? replacement : m; // preserve if unknown
  });
  // Then support bare tokens without angle brackets
  for (const [k,v] of Object.entries(map)) {
    if (!v) continue;
    out = out.split(k).join(v);
  }
  return out;
}

module.exports = { applyTimestampPlaceholders, buildTimestampMap, computeNextRange };
```

===== FILE: utils/ui.js =====
```javascript
const { ButtonBuilder, ButtonStyle, EmbedBuilder, ActionRowBuilder } = require('discord.js');
const theme = require('./theme');
const { createEmbed } = require('./embeds');
const { toTitleCase } = require('./text');

// Central toggle state registry (boolean / mode) for consistent UI + future automation.
// Each entry: { key, getter:()=>value, kind:'boolean'|'mode', on?:()=>bool }
const toggleRegistry = [];
function registerToggle(def) {
  if (!def || !def.key || typeof def.getter !== 'function') return;
  if (toggleRegistry.find(t => t.key === def.key)) return; // dedupe
  toggleRegistry.push(def);
}
function getToggleState(key) {
  const t = toggleRegistry.find(x => x.key === key);
  if (!t) return null;
  try {
    const v = t.getter();
    if (t.kind === 'boolean') return { value: !!v, on: !!v };
    if (t.kind === 'mode') return { value: v, on: typeof t.on === 'function' ? !!t.on(v) : !!v };
    return { value: v };
  } catch { return null; }
}

// Unified visual mapping for a toggle state
function getToggleVisual(on) {
  return {
    emoji: on ? (theme.emojis.enable || '✅') : (theme.emojis.disable || '❌'),
    color: on ? theme.colors.success : theme.colors.neutral,
    prefix: on ? '✅' : '❌'
  };
}

// Semantic button helpers (navigation, toggle, confirm, danger, disabled display)
function semanticButton(kind, { id, label, emoji, active = false, enabled = true } = {}) {
  if (!id) return null;
  // Suppress legacy Back buttons per new UX (no explicit back navigation)
  if (label && /^(back)$/i.test(label)) return null;
  if (/(:|_)back$/i.test(id)) return null;
  let style = ButtonStyle.Secondary;
  switch (kind) {
    case 'nav':
      style = active ? ButtonStyle.Primary : ButtonStyle.Secondary; break;
    case 'confirm':
    case 'success':
      style = ButtonStyle.Success; break;
    case 'danger':
      style = ButtonStyle.Danger; break;
    case 'toggle':
      style = active ? ButtonStyle.Success : ButtonStyle.Secondary; break;
    case 'destructive':
      style = ButtonStyle.Danger; break;
    case 'primary':
      style = ButtonStyle.Primary; break;
    default:
      style = ButtonStyle.Secondary;
  }
  // Auto title-case labels universally
  const cased = toTitleCase(label || '');
  const b = new ButtonBuilder().setCustomId(id).setLabel(cased).setStyle(style);
  if (emoji) b.setEmoji(emoji);
  if (!enabled) b.setDisabled(true);
  return b;
}

// Row builders for consistent ordering (navigation | pagination | destructive)
function buildNavRow(buttons) {
  const row = new ActionRowBuilder();
  for (const b of (buttons||[])) { if (b) row.addComponents(b); }
  return row;
}

function buildToggleRow(toggles) { return buildNavRow(toggles); }

function buildDestructiveRow(buttons) { return buildNavRow(buttons); }

function btn(id, label, style = ButtonStyle.Secondary, emoji, disabled = false) {
  const b = new ButtonBuilder().setCustomId(id).setLabel(label).setStyle(style);
  if (emoji) b.setEmoji(emoji);
  if (disabled) b.setDisabled(true);
  return b;
}

function navBtn(id, label, active, emoji) {
  return btn(id, label, active ? ButtonStyle.Primary : ButtonStyle.Secondary, emoji, false);
}

function toggleModeBtn(id, mode, nextModeLabel, isVC) {
  return btn(id, nextModeLabel, isVC ? ButtonStyle.Success : ButtonStyle.Secondary, isVC ? theme.emojis.vc : theme.emojis.text);
}

function backButton(id = 'back', label = 'Back') {
  return btn(id, label, ButtonStyle.Secondary, theme.emojis.back);
}

function primaryEmbed(title, description) {
  return createEmbed({ title, description: description || '', color: theme.colors.primary });
}

function sectionField(name, value, inline = false) {
  return { name, value, inline };
}

function progressBar(current, max, size = 20, { showNumbers = true, allowOverflow = true, style = 'blocks' } = {}) {
  const safeMax = Math.max(1, max);
  const ratio = current / safeMax;
  const capped = Math.min(1, ratio);
  const filled = Math.round(capped * size);
  const empty = size - filled;
  const fullChar = style === 'bars' ? '█' : '█';
  const emptyChar = style === 'bars' ? '░' : '░';
  let bar = `\`${fullChar.repeat(filled)}${emptyChar.repeat(empty)}\``;
  if (allowOverflow && ratio > 1) bar += ` +${((ratio - 1) * 100).toFixed(1)}%`;
  if (showNumbers) bar += ` ${current}/${max}`;
  return bar;
}

function applyStandardFooter(embed, guild, { testingMode } = { testingMode: false }) {
  try {
    embed.setFooter({ text: `${guild?.name || 'Server'}${testingMode ? ' • Testing Mode' : ''}` });
  } catch {}
  return embed;
}

// Generic pagination display helper for consistency
function paginationLabel(page, totalPages) {
  return `Page ${page}/${totalPages}`;
}

// Apply standard footer + pagination (appended) and optional extra text
function applyFooterWithPagination(embed, guild, { testingMode = false, page = null, totalPages = null, extra = null } = {}) {
  const base = `${guild?.name || 'Server'}${testingMode ? ' • Testing Mode' : ''}`;
  const parts = [base];
  if (page && totalPages) parts.push(paginationLabel(page, totalPages));
  if (extra) parts.push(extra);
  try { embed.setFooter({ text: parts.join(' • ') }); } catch {}
  return embed;
}

// Generic pagination row builder (Prev | Page x/y | Next)
function paginationRow(prefix, page, totalPages) {
  const row = new ActionRowBuilder();
  row.addComponents(
    new ButtonBuilder().setCustomId(`${prefix}_prev`).setLabel('◀ Prev').setStyle(ButtonStyle.Secondary).setDisabled(page <= 1),
    new ButtonBuilder().setCustomId(`${prefix}_page`).setLabel(paginationLabel(page, totalPages)).setStyle(ButtonStyle.Secondary).setDisabled(true),
    new ButtonBuilder().setCustomId(`${prefix}_next`).setLabel('Next ▶').setStyle(ButtonStyle.Secondary).setDisabled(page >= totalPages)
  );
  return row;
}

// Standard close row (single row with a destructive-style Close button)
function closeRow(id = 'close_menu', label = 'Close') {
  return new ActionRowBuilder().addComponents(
    new ButtonBuilder().setCustomId(id).setLabel(label).setStyle(ButtonStyle.Danger).setEmoji(theme.emojis.close || '✖')
  );
}

// Toggle embed coloration helper (ON -> success / OFF -> neutral) + indicator prefix
function applyToggleVisual(embed, { on } = { on: false }) {
  try {
    if (!embed || typeof embed.setColor !== 'function') return embed;
    const visual = getToggleVisual(on);
    embed.setColor(visual.color);
    if (embed.data && embed.data.title) {
      const t = embed.data.title.replace(/^([🔴🟢✅❌]\s*)*/, '');
      embed.setTitle(`${visual.prefix} ${t}`);
    }
  } catch {}
  return embed;
}

// Shared builder for setting embeds (category + key + dynamic state) with lastUpdated metadata.
// opts: { title, description, current, toggleKey }
function buildSettingEmbedUnified({ title, description, current, toggleKey, lastUpdatedTs } = {}) {
  const e = createEmbed({ title, description, color: theme.colors.neutral, timestamp: true });
  if (current) e.addFields({ name: 'Current', value: current });
  if (toggleKey) {
    const st = getToggleState(toggleKey);
    if (st && typeof st.on === 'boolean') applyToggleVisual(e, { on: st.on });
  }
  if (lastUpdatedTs) {
    const rel = Math.floor(lastUpdatedTs/1000);
    e.setFooter({ text: `Last Updated: <t:${rel}:R>` });
  }
  return e;
}

module.exports = { btn, navBtn, toggleModeBtn, backButton, primaryEmbed, sectionField, progressBar, applyStandardFooter, paginationLabel, applyFooterWithPagination, paginationRow, closeRow, semanticButton, buildNavRow, buildToggleRow, buildDestructiveRow, toTitleCase, applyToggleVisual, getToggleVisual, registerToggle, getToggleState, buildSettingEmbedUnified };
// Diff-aware message updater to avoid redundant edits (performance + rate limit friendliness)
async function diffEditMessage(target, { embeds, components, content }) {
  try {
    const current = target.embeds || [];
    const curComps = target.components || [];
    const sameEmbeds = JSON.stringify((embeds||[]).map(e=>({ t:e.data?.title, d:e.data?.description, c:e.data?.color }))) === JSON.stringify(current.map(e=>({ t:e.data?.title, d:e.data?.description, c:e.data?.color })));
    const norm = rows => (rows||[]).map(r => (r.components||[]).map(c => ({ id:c.customId, dis:c.data?.disabled, style:c.data?.style, lbl:c.data?.label })).slice(0,25));
    const sameComponents = JSON.stringify(norm(components)) === JSON.stringify(norm(curComps));
    const sameContent = (content ?? target.content) === target.content;
    if (sameEmbeds && sameComponents && sameContent) return false; // no-op
    await target.edit({ embeds, components, content });
    return true;
  } catch { return false; }
}

module.exports.diffEditMessage = diffEditMessage;

```

===== FILE: utils/vcLevels.js =====
```javascript
const fs = require("fs");
const path = require("path");
const { enqueueWrite } = require('./writeQueue');
const { cfgPath } = require('./paths');

const VC_LEVELS_FILE = cfgPath('vcLevels.json');

// in-memory cache
let vcLevels = {};
try {
  if (fs.existsSync(VC_LEVELS_FILE)) {
    const raw = fs.readFileSync(VC_LEVELS_FILE, "utf8");
    vcLevels = JSON.parse(raw || "{}") || {};
  }
} catch {
  vcLevels = {};
}

let pendingSave = false;
function saveVCLevels() {
  if (pendingSave) return;
  pendingSave = true;
  enqueueWrite(VC_LEVELS_FILE, () => {
    pendingSave = false;
    return JSON.stringify(vcLevels, null, 2);
  }, { delay: 250 });
}

function getVCXP(userId) {
  return vcLevels[userId]?.xp || 0;
}

function getVCLevel(userId) {
  return vcLevels[userId]?.level || 0;
}

function xpForLevel(level) {
  const BASE_XP = 150;
  return Math.floor(BASE_XP * Math.pow(level, 1 / 0.7));
}

function addVCXP(userId, amount) {
  if (!Number.isFinite(amount) || amount <= 0) return 0;
  const cur = vcLevels[userId] || { xp: 0, level: 0 };
  cur.xp = Math.max(0, (cur.xp || 0) + amount);
  let newLevel = cur.level || 0;
  while (cur.xp >= xpForLevel(newLevel + 1)) newLevel++;
  const oldLevel = cur.level || 0;
  if (newLevel !== cur.level) cur.level = newLevel;
  vcLevels[userId] = cur;
  saveVCLevels();
  return newLevel > oldLevel ? newLevel : 0;
}

module.exports = {
  vcLevels,
  saveVCLevels,
  getVCXP,
  getVCLevel,
  addVCXP,
};

```

===== FILE: utils/voiceLeveling.js =====
```javascript
const { addVCXP, saveVCLevels } = require("./vcLevels");
const { addCash } = require("./cash");

// Track join times and periodic ticks
const voiceStates = new Map(); // userId -> { joinedAt: number, channelId: string }
let interval = null;

// Configurable constants
const TICK_MS = 60 * 1000; // award per minute
const XP_PER_MIN = 10; // base XP per minute

function startVoiceLeveling(client) {
  if (interval) clearInterval(interval);

  client.on("voiceStateUpdate", (oldState, newState) => {
    const userId = newState.id || oldState.id;
    const wasInVC = !!oldState?.channelId;
    const nowInVC = !!newState?.channelId;
    if (!wasInVC && nowInVC) {
      voiceStates.set(userId, { joinedAt: Date.now(), channelId: newState.channelId });
    } else if (wasInVC && !nowInVC) {
      flushUser(userId);
      voiceStates.delete(userId);
    } else if (wasInVC && nowInVC && oldState.channelId !== newState.channelId) {
      // moved channels: flush then reset
      flushUser(userId);
      voiceStates.set(userId, { joinedAt: Date.now(), channelId: newState.channelId });
    }
  });

  interval = setInterval(() => {
    const now = Date.now();
    for (const [userId, st] of voiceStates.entries()) {
      if (!st || !st.joinedAt) continue;
      const mins = Math.floor((now - st.joinedAt) / TICK_MS);
      if (mins <= 0) continue;
      const gained = mins * XP_PER_MIN;
      const newLevel = addVCXP(userId, gained);
      if (newLevel > 0) {
        // Award Cash on VC level up (separate rule allows easy tuning later)
        const cashReward = Math.max(0, Math.floor(40 + newLevel * 8));
        addCash(userId, cashReward);
      }
      st.joinedAt = st.joinedAt + mins * TICK_MS; // advance checkpoint
    }
    // persist occasionally
    saveVCLevels();
  }, TICK_MS);
  if (typeof interval.unref === "function") interval.unref();
}

function flushUser(userId) {
  const st = voiceStates.get(userId);
  if (!st) return;
  const now = Date.now();
  const mins = Math.floor((now - st.joinedAt) / TICK_MS);
  if (mins > 0) addVCXP(userId, mins * XP_PER_MIN);
  saveVCLevels();
}

module.exports = { startVoiceLeveling };

```

===== FILE: utils/writeQueue.js =====
```javascript
// Simple async write queue to serialize and debounce file writes.
// Provides enqueueWrite(filePath, getContentFn) which batches rapid updates.
const fs = require('fs');
const path = require('path');

const pending = new Map(); // filePath -> { timer, lastContent, created }
let metrics = { enqueued: 0, flushed: 0, lastFlushAt: 0 };
const MAX_FLUSH_INTERVAL_MS = 5000; // force flush at most 5s after first enqueue
let watchdog = null;

function ensureDir(filePath) {
  const dir = path.dirname(filePath);
  if (!fs.existsSync(dir)) {
    try { fs.mkdirSync(dir, { recursive: true }); } catch {}
  }
}

function flush(filePath) {
  const entry = pending.get(filePath);
  if (!entry) return;
  pending.delete(filePath);
  try {
    ensureDir(filePath);
    fs.writeFileSync(filePath, entry.lastContent);
  } catch {}
  metrics.flushed++; metrics.lastFlushAt = Date.now();
}

function flushAll() {
  for (const filePath of Array.from(pending.keys())) {
    try { flush(filePath); } catch {}
  }
}

function enqueueWrite(filePath, getContentFn, { delay = 150 } = {}) {
  let entry = pending.get(filePath);
  const content = getContentFn();
  if (!entry) {
    entry = { timer: null, lastContent: content, created: Date.now() };
    pending.set(filePath, entry);
  } else {
    entry.lastContent = content;
    if (entry.timer) clearTimeout(entry.timer);
  }
  entry.timer = setTimeout(() => flush(filePath), delay);
  if (typeof entry.timer.unref === 'function') entry.timer.unref();
  metrics.enqueued++;
  // Start watchdog to force flush stale entries
  if (!watchdog) {
    watchdog = setInterval(() => {
      const now = Date.now();
      for (const [fp, ent] of pending.entries()) {
        if (now - ent.created > MAX_FLUSH_INTERVAL_MS) {
          try { flush(fp); } catch {}
        }
      }
    }, 2000);
    if (watchdog.unref) watchdog.unref();
  }
}
function getWriteQueueMetrics() { return { ...metrics, pending: pending.size }; }

module.exports = { enqueueWrite, flushAll, getWriteQueueMetrics };

```

===== END REPO CONTEXT =====
